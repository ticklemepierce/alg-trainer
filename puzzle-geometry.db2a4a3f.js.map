{"mappings":"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AA,EAAG;YACD,IADC;YAED,IADA;YAEA,KADA;YAEA,KADA;YAEA,IADA;YAEA,IADA;YAEA,KADA;YAEA,KADA;YAEA,IADA;YAEA,IADA;YAEA,KADA;YAEA,KADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,MADA;YAEA,MADA;YAEA,MADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,KADA;YAEA,KADA;YAEA,KADA;SACA;QAEF,CAAA,EAAG;YACD,IADC;YAED,IADA;YAEA,KADA;YAEA,KADA;YAEA,IADA;YAEA,IADA;YAEA,KADA;YAEA,KADA;YAEA,IADA;YAEA,IADA;YAEA,KADA;YAEA,KADA;SACA;KAAA;AAGJ,IAAA,EAAA,EAAI;QACF,CAAA,EAAG;YACD,OADC;YAED,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;YAEA,OADA;SACA;QAEF,CAAA,EAAG;YACD,IADC;YAED,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;SACA;QAEF,CAAA,EAAG;YACD,IADC;YAED,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;YAEA,IADA;SACA;KAAA;CAAA,AAAA;AAeN,SAAA,yCAAA,GAAsE;IACpE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","sources":["node_modules/cubing/dist/esm/puzzle-geometry/index.js","node_modules/cubing/dist/esm/chunk-NS5XT5ZV.js","node_modules/cubing/src/cubing/puzzle-geometry/FaceNameSwizzler.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/Options.ts","node_modules/cubing/src/cubing/puzzle-geometry/Perm.ts","node_modules/cubing/src/cubing/puzzle-geometry/PermOriSet.ts","node_modules/cubing/src/cubing/puzzle-geometry/PGPuzzles.ts","node_modules/cubing/src/cubing/puzzle-geometry/Quat.ts","node_modules/cubing/src/cubing/puzzle-geometry/PlatonicGenerator.ts","node_modules/cubing/src/cubing/puzzle-geometry/SchreierSims.ts","node_modules/cubing/src/cubing/puzzle-geometry/PuzzleGeometry.ts"],"sourcesContent":["import {\n  PGNotation,\n  PUZZLE_BASE_SHAPES,\n  PUZZLE_CUT_TYPES,\n  PuzzleGeometry,\n  Quat,\n  getPG3DNamedPuzzles,\n  getPuzzleDescriptionString,\n  getPuzzleGeometryByDesc,\n  getPuzzleGeometryByName,\n  parseOptions,\n  parsePuzzleDescription,\n  schreierSims\n} from \"../chunk-NS5XT5ZV.js\";\nimport \"../chunk-NQORDEXF.js\";\nimport \"../chunk-MGJA5U5O.js\";\nexport {\n  PUZZLE_BASE_SHAPES as EXPERIMENTAL_PUZZLE_BASE_SHAPES,\n  PUZZLE_CUT_TYPES as EXPERIMENTAL_PUZZLE_CUT_TYPES,\n  PGNotation as ExperimentalPGNotation,\n  PuzzleGeometry,\n  Quat,\n  getPG3DNamedPuzzles,\n  getPuzzleDescriptionString,\n  getPuzzleGeometryByDesc,\n  getPuzzleGeometryByName,\n  parseOptions,\n  parsePuzzleDescription,\n  schreierSims\n};\n//# sourceMappingURL=index.js.map\n","import {\n  Move,\n  QuantumMove\n} from \"./chunk-NQORDEXF.js\";\n\n// src/cubing/puzzle-geometry/FaceNameSwizzler.ts\nvar FaceNameSwizzler = class {\n  constructor(facenames, gripnames_arg) {\n    this.facenames = facenames;\n    this.prefixFree = true;\n    this.gripnames = [];\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n  setGripNames(names) {\n    this.gripnames = names;\n  }\n  splitByFaceNames(s) {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (s.substr(at).startsWith(this.facenames[i]) && (currentMatch < 0 || this.facenames[i].length > this.facenames[currentMatch].length)) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(\"Could not split \" + s + \" into face names.\");\n      }\n    }\n    return r;\n  }\n  joinByFaceIndices(list) {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n  spinmatch(userinput, longname) {\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  spinmatchv(userinput, longname) {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(userinput.slice(0, userinput.length - 1), longname.slice(0, longname.length - 1));\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n  unswizzle(s) {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts\nvar NullMapper = class {\n  notationToInternal(move) {\n    return move;\n  }\n  notationToExternal(move) {\n    return move;\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts\nvar FTONotationMapper = class {\n  constructor(child, sw) {\n    this.child = child;\n    this.sw = sw;\n  }\n  notationToInternal(move) {\n    if (move.family === \"T\" && move.innerLayer === void 0 && move.outerLayer === void 0) {\n      return new Move(new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer), move.amount);\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n  notationToExternal(move) {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(new QuantumMove(\"T\", move.innerLayer, move.outerLayer), move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts\nvar FaceRenamingMapper = class {\n  constructor(internalNames, externalNames) {\n    this.internalNames = internalNames;\n    this.externalNames = externalNames;\n  }\n  convertString(grip, a, b) {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n  convert(move, a, b) {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(new QuantumMove(ngrip, move.innerLayer, move.outerLayer), move.amount);\n    }\n  }\n  notationToInternal(move) {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n  notationToExternal(move) {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts\nvar MegaminxScramblingNotationMapper = class {\n  constructor(child) {\n    this.child = child;\n  }\n  notationToInternal(move) {\n    if (move.innerLayer === void 0 && move.outerLayer === void 0) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n      if (move.family === \"x\" && Math.abs(move.amount) === 2) {\n        return new Move(\"ERv\", move.amount / 2);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n  notationToExternal(move) {\n    if (move.family === \"ERv\" && Math.abs(move.amount) === 1) {\n      return new Move(new QuantumMove(\"x\", move.innerLayer, move.outerLayer), move.amount * 2);\n    }\n    if (move.family === \"ILv\" && Math.abs(move.amount) === 1) {\n      return new Move(new QuantumMove(\"x\", move.innerLayer, move.outerLayer), -move.amount * 2);\n    }\n    if (move.family === \"Uv\") {\n      return new Move(new QuantumMove(\"y\", move.innerLayer, move.outerLayer), move.amount);\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts\nvar NxNxNCubeMapper = class {\n  constructor(slices) {\n    this.slices = slices;\n  }\n  notationToInternal(move) {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(new QuantumMove(\"D\", (this.slices + 1) / 2), move.amount);\n        } else if (grip === \"M\") {\n          move = new Move(new QuantumMove(\"L\", (this.slices + 1) / 2), move.amount);\n        } else if (grip === \"S\") {\n          move = new Move(new QuantumMove(\"F\", (this.slices + 1) / 2), move.amount);\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(new QuantumMove(\"D\", this.slices - 1, 2), move.amount);\n        } else if (grip === \"m\") {\n          move = new Move(new QuantumMove(\"L\", this.slices - 1, 2), move.amount);\n        } else if (grip === \"s\") {\n          move = new Move(new QuantumMove(\"F\", this.slices - 1, 2), move.amount);\n        }\n      }\n    }\n    return move;\n  }\n  notationToExternal(move) {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts\nvar pyraminxFamilyMap = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\"\n};\nvar tetraminxFamilyMap = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\"\n};\nvar pyraminxFamilyMapWCA = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\"\n};\nvar pyraminxExternalQuantumY = new QuantumMove(\"y\");\nvar pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\nvar PyraminxNotationMapper = class {\n  constructor(child) {\n    this.child = child;\n    this.wcaHack = false;\n    this.map = pyraminxFamilyMap;\n  }\n  notationToInternal(move) {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer), move.amount);\n      }\n    }\n    const newFamily = this.map[move.family];\n    if (newFamily) {\n      return new Move(new QuantumMove(newFamily, move.innerLayer, move.outerLayer), move.amount);\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n  notationToExternal(move) {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(new QuantumMove(external, move.innerLayer, move.outerLayer), move.amount);\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(new QuantumMove(external, move.innerLayer, move.outerLayer), move.amount);\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n};\nvar TetraminxNotationMapper = class extends PyraminxNotationMapper {\n  constructor(child) {\n    super(child);\n    this.wcaHack = true;\n    this.map = tetraminxFamilyMap;\n  }\n};\n\n// src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts\nvar skewbFamilyMap = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\"\n};\nvar skewbExternalQuantumX = new QuantumMove(\"x\");\nvar skewbInternalQuantumX = new QuantumMove(\"Rv\");\nvar skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nvar skewbExternalQuantumY = new QuantumMove(\"y\");\nvar skewbInternalQuantumY = new QuantumMove(\"Uv\");\nvar skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nvar skewbExternalQuantumZ = new QuantumMove(\"z\");\nvar skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nvar skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\nvar SkewbNotationMapper = class {\n  constructor(child) {\n    this.child = child;\n  }\n  notationToInternal(move) {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(new QuantumMove(newFamily, move.outerLayer, move.innerLayer), move.amount);\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n  }\n  notationToExternal(move) {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(new QuantumMove(external, move.innerLayer, move.outerLayer), move.amount);\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n  }\n};\n\n// src/cubing/puzzle-geometry/Options.ts\nfunction parseOptions(argv) {\n  let argp = 0;\n  const options = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]);\n      argp++;\n    } else {\n      throw new Error(\"Bad option: \" + option);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\nvar PuzzleGeometryFullOptions = class {\n  constructor(options = {}) {\n    this.verbosity = 0;\n    this.allMoves = false;\n    this.vertexMoves = false;\n    this.addRotations = false;\n    this.moveList = null;\n    this.fixedOrientation = false;\n    this.fixedPieceType = null;\n    this.orientCenters = false;\n    this.includeCornerOrbits = true;\n    this.includeCenterOrbits = true;\n    this.includeEdgeOrbits = true;\n    this.excludeOrbits = [];\n    this.optimizeOrbits = false;\n    this.grayCorners = false;\n    this.grayCenters = false;\n    this.grayEdges = false;\n    this.puzzleOrientation = null;\n    this.puzzleOrientations = null;\n    this.scrambleAmount = 0;\n    Object.assign(this, options);\n  }\n};\n\n// src/cubing/puzzle-geometry/Perm.ts\nvar zeroCache = [];\nvar iotaCache = [];\nfunction zeros(n) {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\nfunction iota(n) {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\nfunction identity(n) {\n  return new Perm(iota(n));\n}\nfunction factorial(a) {\n  let r = 1n;\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\nfunction gcd(a, b) {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\nfunction lcm(a, b) {\n  return a / gcd(a, b) * b;\n}\nvar Perm = class {\n  constructor(a) {\n    this.n = a.length;\n    this.p = a;\n  }\n  toString() {\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n  mul(p2) {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n  rmul(p2) {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n  inv() {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n  compareTo(p2) {\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n  toGap() {\n    const cyc = new Array();\n    const seen = new Array(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n  order() {\n    let r = 1;\n    const seen = new Array(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n};\n\n// src/cubing/puzzle-geometry/PermOriSet.ts\nvar PGOrbitDef = class {\n  constructor(size, mod) {\n    this.size = size;\n    this.mod = mod;\n  }\n  reassemblySize() {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n};\nvar lastGlobalDefinitionCounter = 0;\nfunction externalName(mapper, moveString) {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\nvar PGOrbitsDef = class {\n  constructor(orbitnames, orbitdefs, solved, movenames, moveops, isRotation, forcenames) {\n    this.orbitnames = orbitnames;\n    this.orbitdefs = orbitdefs;\n    this.solved = solved;\n    this.movenames = movenames;\n    this.moveops = moveops;\n    this.isRotation = isRotation;\n    this.forcenames = forcenames;\n  }\n  transformToKTransformationData(t) {\n    const mp = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n  static transformToKTransformationData(orbitnames, t) {\n    const mp = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n  describeSet(s, r, mapper) {\n    const n = this.orbitdefs[s].size;\n    const m = new Array(n);\n    for (let i = 0; i < n; i++) {\n      m[i] = [];\n    }\n    for (let i = 0; i < this.movenames.length; i++) {\n      if (this.isRotation[i]) {\n        continue;\n      }\n      let mvname = this.movenames[i];\n      if (!this.forcenames[i]) {\n        mvname = externalName(mapper, mvname);\n        if (mvname[mvname.length - 1] === \"'\") {\n          mvname = mvname.substring(0, mvname.length - 1);\n        }\n      }\n      const pd = this.moveops[i].orbits[s];\n      for (let j = 0; j < n; j++) {\n        if (pd.perm[j] != j || pd.ori[j] != 0) {\n          m[j].push(mvname);\n        }\n      }\n    }\n    for (let j = 0; j < n; j++) {\n      r.push(\"# \" + (j + 1) + \" \" + m[j].join(\" \"));\n    }\n  }\n  toKsolve(name, mapper = new NullMapper()) {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(`Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`);\n      this.describeSet(i, result, mapper);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(result, this.orbitnames[i], false, false);\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name2 = this.movenames[i];\n      if (!this.forcenames[i]) {\n        name2 = externalName(mapper, this.movenames[i]);\n      }\n      let doinv = false;\n      if (name2[name2.length - 1] === \"'\") {\n        doinv = true;\n        name2 = name2.substring(0, name2.length - 1);\n      }\n      result.push(\"Move \" + name2);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j].inv().appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(result, this.orbitnames[j], true);\n        }\n      }\n      result.push(\"End\");\n    }\n    return result;\n  }\n  toKPuzzleDefinition(includemoves) {\n    const orbits = {};\n    const start = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod\n      };\n      const startTransformation = this.solved.orbits[i].toKPuzzle();\n      start[this.orbitnames[i]] = {\n        pieces: startTransformation.permutation,\n        orientation: startTransformation.orientation\n      };\n    }\n    const moves = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.transformToKTransformationData(this.moveops[i]);\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      startStateData: start,\n      moves\n    };\n  }\n  optimize() {\n    const neworbitnames = [];\n    const neworbitdefs = [];\n    const newsolved = [];\n    const newmoveops = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        if (!this.isRotation[j]) {\n          for (let k = 0; k < n; k++) {\n            if (this.moveops[j].orbits[i].perm[k] !== k || this.moveops[j].orbits[i].ori[k] !== 0) {\n              changed[k] = true;\n              du.union(k, this.moveops[j].orbits[i].perm[k]);\n            }\n          }\n        }\n      }\n      let keepori = true;\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (this.moveops[j].orbits[i].perm[k] !== k || this.moveops[j].orbits[i].ori[k] !== 0) {\n              for (let o = 0; o < om; o++) {\n                duo.union(k * om + o, this.moveops[j].orbits[i].perm[k] * om + (o + this.moveops[j].orbits[i].ori[k]) % om);\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no = [];\n        const on = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv).killOri());\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(neworbitnames, neworbitdefs, new VisibleState(newsolved), this.movenames, newmoveops.map((_) => new PGTransform(_)), this.isRotation, this.forcenames);\n  }\n  scramble(n) {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n  getScrambleTransformation(n) {\n    if (n < 100) {\n      n = 100;\n    }\n    const pool = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n  reassemblySize() {\n    let n = 1n;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n};\nvar _PGOrbit = class {\n  constructor(perm, ori, orimod) {\n    this.perm = perm;\n    this.ori = ori;\n    this.orimod = orimod;\n  }\n  static e(n, mod) {\n    return new _PGOrbit(iota(n), zeros(n), mod);\n  }\n  mul(b) {\n    const n = this.perm.length;\n    const newPerm = new Array(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new _PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new _PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n  inv() {\n    const n = this.perm.length;\n    const newPerm = new Array(n);\n    const newOri = new Array(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new _PGOrbit(newPerm, newOri, this.orimod);\n  }\n  equal(b) {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  killOri() {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n  toPerm() {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + (this.ori[i] + j) % o;\n      }\n    }\n    return new Perm(newPerm);\n  }\n  identicalPieces() {\n    const done = [];\n    const n = this.perm.length;\n    const r = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === void 0) {\n        const s = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n  order() {\n    return this.toPerm().order();\n  }\n  isIdentity() {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  zeroOris() {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  remap(no, on, nv) {\n    const newPerm = new Array(nv);\n    const newOri = new Array(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new _PGOrbit(newPerm, newOri, this.orimod);\n  }\n  remapVS(no, nv) {\n    const newPerm = new Array(nv);\n    const newOri = new Array(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === void 0) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new _PGOrbit(newPerm, newOri, this.orimod);\n  }\n  appendDefinition(result, name, useVS, concise = true) {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n  toKPuzzle() {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!_PGOrbit.kcache[n]) {\n        _PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return _PGOrbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n};\nvar PGOrbit = _PGOrbit;\nPGOrbit.kcache = [];\nvar PGTransformBase = class {\n  constructor(orbits) {\n    this.orbits = orbits;\n  }\n  internalMul(b) {\n    const newOrbits = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n  internalInv() {\n    const newOrbits = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n  equal(b) {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  killOri() {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n  toPerm() {\n    const perms = new Array();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n  identicalPieces() {\n    const r = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n  order() {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n};\nvar PGTransform = class extends PGTransformBase {\n  constructor(orbits) {\n    super(orbits);\n  }\n  mul(b) {\n    return new PGTransform(this.internalMul(b));\n  }\n  mulScalar(n) {\n    if (n === 0) {\n      return this.e();\n    }\n    let t = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n  inv() {\n    return new PGTransform(this.internalInv());\n  }\n  e() {\n    return new PGTransform(this.orbits.map((_) => PGOrbit.e(_.perm.length, _.orimod)));\n  }\n};\nvar VisibleState = class extends PGTransformBase {\n  constructor(orbits) {\n    super(orbits);\n  }\n  mul(b) {\n    return new VisibleState(this.internalMul(b));\n  }\n};\nvar DisjointUnion = class {\n  constructor(n) {\n    this.n = n;\n    this.heads = new Array(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n  find(v) {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n  union(a, b) {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n};\nfunction showcanon(g, disp) {\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti;\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if ((st >> mv & 1) === 0 && (st & commutes[mv] & (1 << mv) - 1) === 0) {\n          const nst = st & commutes[mv] | 1 << mv;\n          if (nextlev[nst] === void 0) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n\n// src/cubing/puzzle-geometry/PGPuzzles.ts\nvar PGPuzzles = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\": \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\": \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\": \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\": \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\": \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\": \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"tetraminx\": \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"teraminx\": \"d f 0.64 f 0.76 f 0.88\",\n  \"petaminx\": \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  \"examinx\": \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  \"zetaminx\": \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  \"yottaminx\": \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  \"pentultimate\": \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  \"starminx\": \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\"\n};\n\n// src/cubing/puzzle-geometry/Quat.ts\nvar eps = 1e-9;\nfunction centermassface(face) {\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1 / face.length);\n}\nfunction solvethreeplanes(p1, p2, p3, planes) {\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (planes[i].a > 0 && dt > planes[i].a || planes[i].a < 0 && dt < planes[i].a) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\nvar Quat = class {\n  constructor(a, b, c, d) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n  }\n  mul(q) {\n    return new Quat(this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d, this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c, this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b, this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a);\n  }\n  toString() {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n  dist(q) {\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  len() {\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n  cross(q) {\n    return new Quat(0, this.c * q.d - this.d * q.c, this.d * q.b - this.b * q.d, this.b * q.c - this.c * q.b);\n  }\n  dot(q) {\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n  normalize() {\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  makenormal() {\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n  normalizeplane() {\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  smul(m) {\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n  sum(q) {\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n  sub(q) {\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  angle() {\n    return 2 * Math.acos(this.a);\n  }\n  invrot() {\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n  det3x3(a00, a01, a02, a10, a11, a12, a20, a21, a22) {\n    return a00 * (a11 * a22 - a12 * a21) + a01 * (a12 * a20 - a10 * a22) + a02 * (a10 * a21 - a11 * a20);\n  }\n  rotateplane(q) {\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n  orthogonal() {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n  pointrotation(b) {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n  unproject(b) {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n  rotatepoint(q) {\n    return q.mul(this).mul(q.invrot());\n  }\n  rotateface(face) {\n    return face.map((_) => _.rotatepoint(this));\n  }\n  intersect3(p2, p3) {\n    const det = this.det3x3(this.b, this.c, this.d, p2.b, p2.c, p2.d, p3.b, p3.c, p3.d);\n    if (Math.abs(det) < eps) {\n      return false;\n    }\n    return new Quat(0, this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) / det, this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) / det, this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) / det);\n  }\n  side(x) {\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n  cutface(face) {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << this.side(face[i].dot(this) - d) + 1;\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      const inout = face.map((_) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r2 = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r2).sum(face[kk].smul(r2));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n  cutfaces(faces) {\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n  faceside(face) {\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n  sameplane(p) {\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n  makecut(r) {\n    return new Quat(r, this.b, this.c, this.d);\n  }\n};\n\n// src/cubing/puzzle-geometry/PlatonicGenerator.ts\nvar eps2 = 1e-9;\nfunction cube() {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\nfunction tetrahedron() {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\nfunction dodecahedron() {\n  const d36 = 2 * Math.PI / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5)\n  ];\n}\nfunction icosahedron() {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = 2 * Math.PI / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0)\n  ];\n}\nfunction octahedron() {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\nfunction closure(g) {\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps2 || negns.dist(q[k]) < eps2) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\nfunction uniqueplanes(p, g) {\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps2) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\nfunction getface(planes) {\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps2) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (; ; ) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n\n// src/cubing/puzzle-geometry/SchreierSims.ts\nvar FactoredNumber = class {\n  constructor() {\n    this.mult = [];\n  }\n  multiply(n) {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (this.mult[f] !== void 0) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (this.mult[n] !== void 0) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n  toString() {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (this.mult[i] !== void 0) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n};\nfunction schreierSims(g, disp) {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs = [];\n  let sgsi = [];\n  let sgslen = [];\n  let Tk = [];\n  let Tklen = [];\n  function resolve(p) {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k, p, len) {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k, p, len) {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs() {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1n;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1n;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(`${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`);\n    }\n    return sz;\n  }\n  return getsgs();\n}\n\n// src/cubing/puzzle-geometry/PuzzleGeometry.ts\nfunction tstart(s) {\n  return s;\n}\nfunction tend(_) {\n}\nvar Face = class {\n  constructor(q) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n  get(off) {\n    return new Quat(0, this.coords[3 * off], this.coords[3 * off + 1], this.coords[3 * off + 2]);\n  }\n  centermass() {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n  rotate(q) {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n  rotateforward() {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n};\nvar FaceTree = class {\n  constructor(face, left, right) {\n    this.face = face;\n    this.left = left;\n    this.right = right;\n  }\n  split(q) {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === void 0) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n  collect(arr, leftfirst) {\n    if (this.left === void 0) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n};\nfunction expandfaces(rots, faces) {\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\nvar eps3 = 1e-9;\nvar copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nvar permissivieMoveParsing = false;\nfunction defaultnets() {\n  return {\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"]\n    ],\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"]\n    ],\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"]\n    ],\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"]\n    ]\n  };\n}\nfunction defaultcolors() {\n  return {\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\"\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\"\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\"\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\"\n    }\n  };\n}\nvar orientationDefaults = {\n  4: {\n    v: [\"DFR\", \"DLF\", \"DRL\", \"FLR\"],\n    e: [\"FR\", \"LF\", \"DF\", \"DL\", \"RD\", \"RL\"],\n    c: [\"DF\", \"FD\", \"RL\", \"LR\"]\n  },\n  6: {\n    v: [\"URF\", \"UBR\", \"ULB\", \"UFL\", \"DFR\", \"DRB\", \"DBL\", \"DLF\"],\n    e: [\"UF\", \"UR\", \"UB\", \"UL\", \"DF\", \"DR\", \"DB\", \"DL\", \"FR\", \"FL\", \"BR\", \"BL\"],\n    c: [\"UB\", \"LU\", \"FU\", \"RU\", \"BU\", \"DF\"]\n  },\n  8: {\n    v: [\"UBBBRR\", \"URFL\", \"ULBLBB\", \"DBRBBBL\", \"DBLLF\", \"DFRBR\"],\n    e: [\n      \"UL\",\n      \"UBB\",\n      \"UR\",\n      \"BRD\",\n      \"BLD\",\n      \"FD\",\n      \"BRR\",\n      \"FR\",\n      \"FL\",\n      \"BLL\",\n      \"BLBB\",\n      \"BRBB\"\n    ],\n    c: [\"BBU\", \"LU\", \"RU\", \"BRD\", \"FD\", \"BLD\", \"DF\", \"UBB\"]\n  },\n  12: {\n    v: [\n      \"URF\",\n      \"UFL\",\n      \"ULBL\",\n      \"UBLBR\",\n      \"UBRR\",\n      \"DEBF\",\n      \"DBFI\",\n      \"DIA\",\n      \"DAC\",\n      \"DCE\",\n      \"LAI\",\n      \"ALF\",\n      \"FCA\",\n      \"CFR\",\n      \"REC\",\n      \"ERBR\",\n      \"BRBFE\",\n      \"BFBRBL\",\n      \"BLIBF\",\n      \"IBLL\"\n    ],\n    e: [\n      \"UF\",\n      \"UR\",\n      \"UBR\",\n      \"UBL\",\n      \"UL\",\n      \"ER\",\n      \"EBR\",\n      \"EBF\",\n      \"ED\",\n      \"EC\",\n      \"IBF\",\n      \"IBL\",\n      \"IL\",\n      \"IA\",\n      \"ID\",\n      \"AC\",\n      \"CF\",\n      \"FA\",\n      \"BFBR\",\n      \"BRBL\",\n      \"BLBF\",\n      \"CD\",\n      \"AD\",\n      \"AL\",\n      \"FL\",\n      \"FR\",\n      \"CR\",\n      \"BFD\",\n      \"BRR\",\n      \"BLL\"\n    ],\n    c: [\n      \"UF\",\n      \"FU\",\n      \"DBF\",\n      \"BFD\",\n      \"AD\",\n      \"CD\",\n      \"BRU\",\n      \"BLU\",\n      \"LA\",\n      \"RA\",\n      \"EBR\",\n      \"IBL\"\n    ]\n  },\n  20: {\n    v: [\n      \"FLPQU\",\n      \"FUGER\",\n      \"FRCAL\",\n      \"HCREI\",\n      \"ISBDH\",\n      \"JSIEG\",\n      \"BSJMK\",\n      \"MQPOK\",\n      \"ONDBK\",\n      \"NOPLA\",\n      \"UQMJG\",\n      \"DNACH\"\n    ],\n    e: [\n      \"FU\",\n      \"FL\",\n      \"FR\",\n      \"EG\",\n      \"ER\",\n      \"EI\",\n      \"SJ\",\n      \"SI\",\n      \"SB\",\n      \"KM\",\n      \"KB\",\n      \"KO\",\n      \"PQ\",\n      \"PO\",\n      \"PL\",\n      \"UG\",\n      \"JG\",\n      \"MQ\",\n      \"UQ\",\n      \"HC\",\n      \"HD\",\n      \"ND\",\n      \"NA\",\n      \"JM\",\n      \"CA\",\n      \"AL\",\n      \"CR\",\n      \"HI\",\n      \"DB\",\n      \"NO\"\n    ],\n    c: [\n      \"FU\",\n      \"UF\",\n      \"GE\",\n      \"EG\",\n      \"JS\",\n      \"SJ\",\n      \"MK\",\n      \"KM\",\n      \"QP\",\n      \"PQ\",\n      \"LA\",\n      \"AL\",\n      \"RC\",\n      \"CR\",\n      \"IH\",\n      \"HI\",\n      \"BD\",\n      \"DB\",\n      \"ON\",\n      \"NO\"\n    ]\n  }\n};\nfunction defaultOrientations() {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ],\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]]\n    ]\n  };\n}\nfunction findelement(a, p) {\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps3) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\nfunction getPG3DNamedPuzzles() {\n  return PGPuzzles;\n}\nfunction getPuzzleDescriptionString(puzzleName) {\n  return PGPuzzles[puzzleName];\n}\nvar PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"];\nvar PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"];\nfunction parsePuzzleDescription(s) {\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (shape !== \"o\" && shape !== \"c\" && shape !== \"i\" && shape !== \"d\" && shape !== \"t\") {\n    return null;\n  }\n  const cuts = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i],\n      distance: parseFloat(a[i + 1])\n    });\n  }\n  return { shape, cuts };\n}\nfunction getPuzzleGeometryByDesc(desc, options = {}) {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(parsed, Object.assign({}, { allMoves: true }, options));\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\nfunction getPuzzleGeometryByName(puzzleName, options) {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\nfunction getmovename(geo, bits, slices) {\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw new Error(`We only support slice and outer block moves right now. ${bits}`);\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\nfunction splitByFaceNames(s, facenames) {\n  const r = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (s.substr(at).startsWith(facename[1]) && facename[1].length > currentMatch.length) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\nfunction toCoords(q, maxdist) {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\nfunction toFaceCoords(q, maxdist) {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\nvar PuzzleGeometry = class {\n  constructor(puzzleDescription, options) {\n    this.puzzleDescription = puzzleDescription;\n    this.cmovesbyslice = [];\n    this.duplicatedFaces = [];\n    this.duplicatedCubies = [];\n    this.fixedCubie = -1;\n    this.net = [];\n    this.colors = [];\n    this.notationMapper = new NullMapper();\n    this.addNotationMapper = \"\";\n    this.setReidOrder = false;\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n  create(puzzleDescription) {\n    const { shape, cuts } = puzzleDescription;\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false;\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cut.cutType);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    const facenames = [];\n    const faceplanes = [];\n    const vertexnames = [];\n    const edgenames = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a, p, name) {\n      for (const el of a) {\n        if (el[0].dist(p) < eps3) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex = {};\n    const faceindextoname = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === void 0) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== void 0 && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== void 0 && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    const oridata = orientationDefaults[this.baseFaceCount];\n    const markedface = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      markedface[1 << i] = i;\n    }\n    {\n      const oriprefs = oridata[\"v\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"e\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"c\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        const bits = 1 << fn[0] | 1 << this.baseFaceCount;\n        markedface[bits] = fn[1];\n      }\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      const f1 = edgenames[i][1];\n      const f2 = edgenames[i][2];\n      let c1 = faceindextoname[f1];\n      const c2 = faceindextoname[f2];\n      const bits = 1 << f1 | 1 << f2;\n      if (markedface[bits] == f1) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      let bits = 0;\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        bits |= 1 << facenametoindex[vertexnames[i][j][0]];\n      }\n      const fi = markedface[bits];\n      let st = -1;\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (fi === facenametoindex[vertexnames[i][j][0]]) {\n          st = j;\n        }\n      }\n      if (st < 0) {\n        throw new Error(\"Internal error; couldn't find face name when fixing corners\");\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    this.markedface = markedface;\n    if (this.options.verbosity > 1) {\n      console.log(\"# Face names: \" + facenames.map((_) => _[1]).join(\" \"));\n      console.log(\"# Edge names: \" + edgenames.map((_) => _[1]).join(\" \"));\n      console.log(\"# Vertex names: \" + vertexnames.map((_) => _[1]).join(\" \"));\n    }\n    const geonormals = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Distances: face \" + 1 + \" edge \" + this.edgedistance + \" vertex \" + this.vertexdistance);\n    }\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    const simplerot = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps3) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array(faces.length);\n    const sortme = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm2 = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps3) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm2.dist(sortme[kk][1]) < eps3) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(\"# Short edge is \" + this.shortedge);\n    }\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(this.swizzler, new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]));\n      if (!sawedge && !sawvertex) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(this.swizzler, new FaceNameSwizzler([\n        \"U\",\n        \"F\",\n        \"L\",\n        \"BL\",\n        \"BR\",\n        \"R\",\n        \"FR\",\n        \"FL\",\n        \"DL\",\n        \"B\",\n        \"DR\",\n        \"D\"\n      ]));\n    }\n  }\n  keyface(face) {\n    return this.keyface2(face.centermass());\n  }\n  keyface2(cm) {\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + t % 47);\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) + sfcc(33 + 47 + Math.floor((t - 47) / 47) % 47) + sfcc(33 + t % 47);\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n  keyface3(face) {\n    const cm = face.centermass();\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n  findface(cm) {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key);\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)[i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps3) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n  project2d(facen, edgen, targvec) {\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(0, targvec[0].b - x1.dot(face[edgen]), targvec[0].c - y1.dot(face[edgen]), 0);\n    return [x1, y1, off];\n  }\n  allstickers() {\n    const t1 = tstart(\"allstickers\");\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    const moveplanesets = [];\n    const moveplanenormals = [];\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps3) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    const moverotations = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps3) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps3) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps3) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps3) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"SkewbMapper\" && moveplanesets[0].length === 1) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (moveplanesets[0].length === 2 && moveplanesets[0][0].a === 0.333333333333333 && moveplanesets[0][1].a === 1.66666666666667) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(this.notationMapper);\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(this.notationMapper, this.swizzler);\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    const facelisthash = /* @__PURE__ */ new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s);\n        arr.push(i);\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = s + \" \" + suff;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubies: \" + facelisthash.size);\n    }\n    const cubies = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        continue;\n      }\n      if (facelist.length > 1) {\n        const cm = facelist.map((_) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1e3) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        let bits = 0;\n        for (const f of facelist) {\n          bits |= 1 << Math.floor(f / this.stickersperface);\n        }\n        const markedface = this.markedface[bits];\n        let mini = -1;\n        for (let i = 0; i < facelist.length; i++) {\n          if (Math.floor(facelist[i] / this.stickersperface) === markedface) {\n            mini = i;\n          }\n        }\n        if (mini < 0) {\n          throw new Error(\"Could not find marked face in list\");\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    const getcolorkey = (cubienum) => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      if (seen[i]) {\n        continue;\n      }\n      const cubiekeymap = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === void 0 || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === void 0) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq = this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (this.setReidOrder && 4 <= this.stickersperface && this.stickersperface <= 9) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\"\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"]\n      ];\n      const reidmap = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << cubie[j].charCodeAt(k) - 65;\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |= 1 << this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65;\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (this.options.fixedPieceType === \"v\" && cubies[i].length > 2 || this.options.fixedPieceType === \"e\" && cubies[i].length === 2 || this.options.fixedPieceType === \"f\" && cubies[i].length === 1) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\"Could not find a cubie of type \" + this.options.fixedPieceType + \" to fix.\");\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n    tend(t1);\n  }\n  unswizzle(mv) {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n  stringToBlockMove(mv) {\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = void 0;\n    let hislice = void 0;\n    if (p[2] !== void 0) {\n      if (p[3] === void 0) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== void 0) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== void 0) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n  parseMove(move) {\n    const bm = this.notationMapper.notationToInternal(move);\n    if (bm === null) {\n      throw new Error(\"Bad move \" + move.family);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== void 0 || move.outerLayer !== void 0) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === void 0) {\n      throw new Error(\"Bad grip in move \" + move.family);\n    }\n    if (move.outerLayer !== void 0) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== void 0) {\n      if (move.outerLayer === void 0) {\n        hislice = move.innerLayer;\n        if (grip <= \"Z\") {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (loslice < 0 || loslice > this.moveplanesets[msi].length || hislice < 0 || hislice > this.moveplanesets[msi].length) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice + \" vs \" + this.moveplanesets[msi].length);\n    }\n    if (!permissivieMoveParsing && loslice === 0 && hislice === this.moveplanesets[msi].length && !fullrotation) {\n      throw new Error(\"! full puzzle rotations must be specified with v suffix.\");\n    }\n    return [void 0, msi, loslice, hislice, firstgrip, move.amount];\n  }\n  parsemove(mv) {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n  genperms() {\n    const t1 = tstart(\"genperms\");\n    if (this.cmovesbyslice.length > 0) {\n      return;\n    }\n    const cmovesbyslice = [];\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          const center = this.basefaces[i].centermass();\n          if (center.dist(this.facecentermass[kk]) < eps3) {\n            const bits = 1 << i | 1 << this.baseFaceCount;\n            const towards = this.markedface[bits];\n            const normal = this.baseplanes[towards].makenormal();\n            let hiv = -1;\n            let hii = -1;\n            for (let ii = 0; ii < this.faces[kk].length; ii++) {\n              const pt = this.faces[kk].get(ii);\n              const t = normal.dot(pt.sub(center));\n              if (t > hiv) {\n                hiv = t;\n                hii = ii;\n              }\n            }\n            const hii2 = (hii + 1) % this.faces[kk].length;\n            if (Math.abs(normal.dot(this.faces[kk].get(hii2).sub(center)) - hiv) < eps3) {\n              hii = hii2;\n            }\n            if (hii != 0) {\n              const qs = [];\n              for (let ii = 0; ii < this.faces[kk].length; ii++) {\n                qs.push(this.faces[kk].get((ii + hii) % this.faces[kk].length));\n              }\n              this.faces[kk] = new Face(qs);\n            }\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (; ; ) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps3) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        if (b.length > 2 && this.options.orientCenters && (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)) {\n          if (this.facecentermass[i].dist(this.basefaces[this.getfaceindex(i)].centermass()) < eps3) {\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps3) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\"Couldn't find rotation of center faces; ignoring for now.\");\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        if (b.length === 2 && this.options.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(b[0], (this.movesetorders[k] - ii) % this.movesetorders[k]);\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist = [];\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n  getboundarygeometry() {\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals\n    };\n  }\n  getmovesets(k) {\n    const slices = this.moveplanesets[k].length;\n    let r = [];\n    if (this.parsedmovelist !== void 0) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j][0] === o[0] && newr[j][1] === o[1] && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    return r;\n  }\n  graybyori(cubie) {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ori === 1 && (this.options.grayCenters || !this.options.includeCenterOrbits) || ori === 2 && (this.options.grayEdges || !this.options.includeEdgeOrbits) || ori > 2 && (this.options.grayCorners || !this.options.includeCornerOrbits);\n  }\n  skipbyori(cubie) {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ori === 1 && !this.options.includeCenterOrbits || ori === 2 && !this.options.includeEdgeOrbits || ori > 2 && !this.options.includeCornerOrbits;\n  }\n  skipcubie(fi) {\n    return this.skipbyori(fi);\n  }\n  header(comment) {\n    return comment + copyright + \"\\n\" + comment + \"\\n\";\n  }\n  writegap() {\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = \"M_\" + externalName(this.notationMapper, os.movenames[i]);\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      mvs.push(movename);\n      if (doinv) {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().inv().toGap() + \";\");\n      } else {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\"ip:=[\" + ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") + \"];\");\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n  writeksolve(name = \"PuzzleGeometryPuzzle\") {\n    const od = this.getOrbitsDef(false);\n    return this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\");\n  }\n  getKPuzzleDefinition(fortwisty = true, includemoves = true) {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    internalDefinition.experimentalPuzzleDescription = this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n  getMoveFromBits(moverange, amount, inverted, axiscmoves, setmoves, movesetorder) {\n    const moveorbits = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] = (mperm[(ii + oinc) % mperm.length] - mperm[(ii + 1) % mperm.length] + 2 * this.orbitoris[setnum]) % this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array(oris[ii].length);\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n  omitSet(name) {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n  diffmvsets(a, b, slices, neg) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (a[i][0] + b[j][1] === slices && a[i][1] + b[j][0] === slices && a[i + 1] === b[j + 1]) {\n            found = true;\n          }\n        } else {\n          if (a[i][0] === b[j][0] && a[i][1] === b[j][1] && a[i + 1] === b[j + 1]) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getOrbitsDef(fortwisty, includemoves = true) {\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames = [];\n    const setdefs = [];\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    const hasrotation = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const slices = this.moveplanesets[k].length;\n      let sawone = false;\n      const moveset = mps[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        if (moveset[i][0] === 0 && moveset[i][1] === slices) {\n          sawone = true;\n        }\n      }\n      hasrotation[k] = sawone;\n    }\n    if (this.options.moveList && this.options.addRotations) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        if (hasrotation[k]) {\n          addrot[k] = 3;\n          continue;\n        }\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps3) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps3) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (cmp.length !== mps[k].length || this.moveplanesets[k].length !== this.moveplanesets[found].length || this.diffmvsets(cmp, mps[k], this.moveplanesets[found].length, neg)) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0 && !hasrotation[k]) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i][0] === moveset[j][0] && moveset[i][1] === moveset[j][1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(new PGOrbitDef(this.cubieords[i], this.options.fixedOrientation ? 1 : this.orbitoris[i]));\n    }\n    const solved = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(new PGOrbit(p, o, this.options.fixedOrientation ? 1 : this.orbitoris[i]));\n    }\n    const movenames = [];\n    const forcenames = [];\n    const moves = [];\n    const isrots = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          let nameoverride;\n          let inverted = false;\n          if (this.parsedmovelist !== void 0) {\n            for (const parsedmove of this.parsedmovelist) {\n              if (parsedmove[1] !== k) {\n                continue;\n              }\n              let r2 = [];\n              if (parsedmove[4]) {\n                r2 = [parsedmove[2], parsedmove[3]];\n              } else {\n                r2 = [slices - parsedmove[3], slices - parsedmove[2]];\n              }\n              if (r2[0] === movebits[0] && r2[1] === movebits[1]) {\n                nameoverride = parsedmove[0];\n                inverted = !parsedmove[4];\n              }\n            }\n          }\n          if (nameoverride) {\n            movenames.push(nameoverride);\n            forcenames.push(true);\n          } else {\n            const mna = getmovename(movesetgeo, movebits, slices);\n            inverted = mna[1];\n            const movename = mna[0];\n            if (moveset[i + 1] === 1) {\n              movenames.push(movename);\n            } else {\n              movenames.push(movename + moveset[i + 1]);\n            }\n            forcenames.push(false);\n          }\n          isrots.push(movebits[0] === 0 && movebits[1] === slices);\n          const mv = this.getMoveFromBits(movebits, moveset[i + 1], inverted, this.cmovesbyslice[k], setmoves, this.movesetorders[k]);\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(setnames, setdefs, new VisibleState(solved), movenames, moves, isrots, forcenames);\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n  getScramble(n = 0) {\n    const od = this.getOrbitsDef(false);\n    return od.transformToKTransformationData(od.getScrambleTransformation(n));\n  }\n  getMovesAsPerms() {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n  showcanon(disp) {\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n  getsolved() {\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n  getOrientationRotation(desiredRotation) {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1 = null;\n    let feature2 = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot.unproject(direction1).pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n  getInitial3DRotation() {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n  generate2dmapping(w = 800, h = 500, trim = 10, threed = false, twodshrink = 0.92) {\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a, n) {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = 2 * Math.PI / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length;\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0]\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos = {};\n    const bg = this.getboundarygeometry();\n    const edges2 = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff]\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0)\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn]\n        ];\n        extendedges(edges2[f1], polyn);\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn].sum(thisface[(caf0 + j + polyn - 1) % polyn]).smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps3) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0)\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn, q) => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c\n        ];\n      }\n    };\n    return mappt2d;\n  }\n  generatesvg(w = 800, h = 500, trim = 10, threed = false) {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id, pts, color) {\n      return '<polygon id=\"' + id + '\" class=\"sticker\" style=\"fill: ' + color + '\" points=\"' + pts.map((p) => p[0] + \" \" + p[1]).join(\" \") + '\"/>\\n';\n    }\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html = '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n<style type=\"text/css\"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\\n' + svg.join(\"\") + \"</svg>\";\n    return html;\n  }\n  get3d(options) {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie) ? \"#808080\" : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true\n          });\n        }\n      }\n    }\n    const grips = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1);\n    const g = function() {\n      const irot = rot.invrot();\n      return function(facenum, coords) {\n        let q = new Quat(0, coords[0] * maxdist, -coords[1] * maxdist, coords[2] * maxdist);\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    }().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g }\n    };\n  }\n  getGeoNormal(geoname) {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        if (Math.abs(r[0]) < eps3 && Math.abs(r[2]) < eps3) {\n          r[0] = 0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return void 0;\n  }\n  getfaceindex(facenum) {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n  textForTwizzleExplorer() {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n  writeSchreierSims(tw) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n};\nvar PGNotation = class {\n  constructor(pg, od) {\n    this.pg = pg;\n    this.orbitNames = od.orbitnames;\n  }\n  lookupMove(move) {\n    const mv = this.pg.parseMove(move);\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (parsedmove[1] === mv[1] && parsedmove[2] === mv[2] && parsedmove[3] === mv[3] && parsedmove[4] === mv[4]) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(bits, mv[5], !mv[4], this.pg.cmovesbyslice[mv[1]], void 0, this.pg.movesetorders[mv[1]]);\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n};\n\nexport {\n  parseOptions,\n  Quat,\n  schreierSims,\n  getPG3DNamedPuzzles,\n  getPuzzleDescriptionString,\n  PUZZLE_BASE_SHAPES,\n  PUZZLE_CUT_TYPES,\n  parsePuzzleDescription,\n  getPuzzleGeometryByDesc,\n  getPuzzleGeometryByName,\n  PuzzleGeometry,\n  PGNotation\n};\n//# sourceMappingURL=chunk-NS5XT5ZV.js.map\n","// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(\"Could not split \" + s + \" into face names.\");\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /* same as above, but permit both to have v's on the end. */\n  public spinmatchv(userinput: string, longname: string): boolean {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1),\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n","import type { Move } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move | null {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move | null {\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper, private sw: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n","// Sits on top of a (possibly null) notation mapper, and\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n\n        // TODO: Figure out if `cubing/alg` should parse `R++` to a family of `R++`.\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n      if (move.family === \"x\" && Math.abs(move.amount) === 2) {\n        return new Move(\"ERv\", move.amount / 2);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"ERv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        move.amount * 2,\n      );\n    }\n    if (move.family === \"ILv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        -move.amount * 2,\n      );\n    }\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst pyraminxFamilyMap: Record<string, string> = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n};\nconst tetraminxFamilyMap: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\",\n};\n\nconst pyraminxFamilyMapWCA: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n};\n\nconst pyraminxExternalQuantumY = new QuantumMove(\"y\");\nconst pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  protected wcaHack: boolean = false;\n  map: Record<string, string> = pyraminxFamilyMap;\n\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount,\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class TetraminxNotationMapper extends PyraminxNotationMapper {\n  wcaHack = true;\n\n  constructor(child: FaceNameSwizzler) {\n    super(child);\n    this.map = tetraminxFamilyMap;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst skewbFamilyMap: Record<string, string> = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\",\n};\n\n// TODO: combine using a similar table.\nconst skewbExternalQuantumX = new QuantumMove(\"x\");\nconst skewbInternalQuantumX = new QuantumMove(\"Rv\");\nconst skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nconst skewbExternalQuantumY = new QuantumMove(\"y\");\nconst skewbInternalQuantumY = new QuantumMove(\"Uv\");\nconst skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nconst skewbExternalQuantumZ = new QuantumMove(\"z\");\nconst skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nconst skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount,\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n    /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n    /*\n       *   See (1) above.\n       *\n    if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    // } else {\n    //   return null;\n    // }\n  }\n}\n","import { parsePuzzleDescription, PuzzleDescription } from \"./PuzzleGeometry\";\n\nexport function parseOptions(argv: string[]): {\n  puzzleDescription: PuzzleDescription | null;\n  options: PuzzleGeometryOptions;\n} {\n  let argp = 0;\n  const options: PuzzleGeometryOptions = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]); // TODO: Validate input.\n      argp++;\n    } else {\n      throw new Error(\"Bad option: \" + option);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\n\ntype FaceName = string;\ntype OrientationDirection = [number, number, number];\nexport type FaceBasedOrientationDescription = [\n  [FaceName, OrientationDirection],\n  [FaceName, OrientationDirection],\n];\nexport type BaseFaceCount = 4 | 6 | 8 | 12 | 20;\nexport type FaceBasedOrientationDescriptionLookup = Record<\n  BaseFaceCount,\n  FaceBasedOrientationDescription\n>;\n\nfunction asstructured(v: any): any {\n  if (typeof v === \"string\") {\n    return JSON.parse(v);\n  }\n  return v;\n}\nfunction asboolean(v: any): boolean {\n  if (typeof v === \"string\") {\n    if (v === \"false\") {\n      return false;\n    }\n    return true;\n  } else {\n    return v ? true : false;\n  }\n}\n\nexport class PuzzleGeometryFullOptions {\n  verbosity: number = 0; // verbosity (console.log)\n\n  allMoves: boolean = false; // generate all slice moves in ksolve\n  outerBlockMoves: boolean; // generate outer block moves\n  vertexMoves: boolean = false; // generate vertex moves\n  addRotations: boolean = false; // add symmetry information to ksolve output\n  moveList: string[] | null = null; // move list to generate\n\n  fixedOrientation: boolean = false; // eliminate any orientations\n  fixedPieceType: null | \"e\" | \"v\" | \"f\" = null; // fix a piece?\n  orientCenters: boolean = false; // orient centers?\n\n  // TODO: Group these into a single object?\n  includeCornerOrbits: boolean = true; // include corner orbits\n  includeCenterOrbits: boolean = true; // include center orbits\n  includeEdgeOrbits: boolean = true; // include edge orbits\n  // Overrides the previous options.\n  excludeOrbits: string[] = []; // exclude these orbits\n  optimizeOrbits: boolean = false; // optimize PermOri\n\n  grayCorners: boolean = false; // make corner sets gray\n  grayCenters: boolean = false; // make center sets gray\n  grayEdges: boolean = false; // make edge sets gray\n\n  puzzleOrientation: FaceBasedOrientationDescription | null = null; // single puzzle orientation from options\n  puzzleOrientations: FaceBasedOrientationDescriptionLookup | null = null; // puzzle orientation override object from options // TODO: is this needed?\n\n  scrambleAmount: number = 0; // scramble?\n\n  constructor(options: PuzzleGeometryOptions = {}) {\n    Object.assign(this, options);\n  }\n}\n\nexport type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;\n\nexport function parsePGOptionList(optionlist?: any[]): PuzzleGeometryOptions {\n  const options: PuzzleGeometryOptions = {};\n  if (optionlist !== undefined) {\n    if (optionlist.length % 2 !== 0) {\n      throw new Error(\"Odd length in option list?\");\n    }\n    for (let i = 0; i < optionlist.length; i += 2) {\n      if (optionlist[i] === \"verbose\") {\n        options.verbosity = (options.verbosity ?? 0) + 1;\n      } else if (optionlist[i] === \"quiet\") {\n        options.verbosity = 0;\n      } else if (optionlist[i] === \"allmoves\") {\n        options.allMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"outerblockmoves\") {\n        options.outerBlockMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"vertexmoves\") {\n        options.vertexMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"rotations\") {\n        options.addRotations = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"cornersets\") {\n        options.includeCornerOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"centersets\") {\n        options.includeCenterOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"edgesets\") {\n        options.includeEdgeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"omit\") {\n        options.excludeOrbits = optionlist[i + 1];\n      } else if (optionlist[i] === \"graycorners\") {\n        options.grayCorners = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"graycenters\") {\n        options.grayCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"grayedges\") {\n        options.grayEdges = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"movelist\") {\n        options.moveList = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"killorientation\") {\n        options.fixedOrientation = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"optimize\") {\n        options.optimizeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"scramble\") {\n        options.scrambleAmount = optionlist[i + 1];\n      } else if (optionlist[i] === \"fix\") {\n        options.fixedPieceType = optionlist[i + 1];\n      } else if (optionlist[i] === \"orientcenters\") {\n        options.orientCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientation\") {\n        options.puzzleOrientation = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientations\") {\n        options.puzzleOrientations = asstructured(optionlist[i + 1]);\n      } else {\n        throw new Error(\n          \"Bad option while processing option list \" + optionlist[i],\n        );\n      }\n    }\n  }\n  return options;\n}\n","const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): bigint {\n  let r = 1n;\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","import { Move } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\"; // TODO\nimport { NullMapper } from \"./notation-mapping\";\nimport type { NotationMapper } from \"./notation-mapping/NotationMapper\";\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class PGOrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): bigint {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n}\n\nlet lastGlobalDefinitionCounter = 0;\n\nexport function externalName(\n  mapper: NotationMapper,\n  moveString: string,\n): string {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\n\nexport class PGOrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    private orbitdefs: PGOrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: PGTransform[],\n    public isRotation: boolean[],\n    public forcenames: boolean[],\n  ) {}\n\n  public transformToKTransformationData(t: PGTransform): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public static transformToKTransformationData(\n    orbitnames: string[],\n    t: PGTransform,\n  ): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  private describeSet(s: number, r: string[], mapper: NotationMapper): void {\n    const n = this.orbitdefs[s].size;\n    const m = new Array(n);\n    for (let i = 0; i < n; i++) {\n      m[i] = [];\n    }\n    for (let i = 0; i < this.movenames.length; i++) {\n      if (this.isRotation[i]) {\n        continue;\n      }\n      let mvname = this.movenames[i];\n      if (!this.forcenames[i]) {\n        mvname = externalName(mapper, mvname);\n        if (mvname[mvname.length - 1] === \"'\") {\n          mvname = mvname.substring(0, mvname.length - 1);\n        }\n      }\n      const pd = this.moveops[i].orbits[s];\n      for (let j = 0; j < n; j++) {\n        if (pd.perm[j] != j || pd.ori[j] != 0) {\n          m[j].push(mvname);\n        }\n      }\n    }\n    for (let j = 0; j < n; j++) {\n      r.push(\"# \" + (j + 1) + \" \" + m[j].join(\" \"));\n    }\n  }\n\n  public toKsolve(\n    name: string,\n    mapper: NotationMapper = new NullMapper(),\n  ): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`,\n      );\n      this.describeSet(i, result, mapper);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false,\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name = this.movenames[i];\n      if (!this.forcenames[i]) {\n        name = externalName(mapper, this.movenames[i]);\n      }\n      let doinv = false;\n      if (name[name.length - 1] === \"'\") {\n        doinv = true;\n        name = name.substring(0, name.length - 1);\n      }\n      result.push(\"Move \" + name);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j]\n            .inv()\n            .appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true,\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition {\n    const orbits: KPuzzleDefinition[\"orbits\"] = {};\n    const start: KPuzzleDefinition[\"startStateData\"] = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod,\n      };\n      const startTransformation = this.solved.orbits[i].toKPuzzle();\n      start[this.orbitnames[i]] = {\n        pieces: startTransformation.permutation,\n        orientation: startTransformation.orientation,\n      };\n    }\n    const moves: { [moveName: string]: any } = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.transformToKTransformationData(\n          this.moveops[i],\n        );\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      startStateData: start,\n      moves,\n    };\n  }\n\n  public optimize(): PGOrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: PGOrbitDef[] = [];\n    const newsolved: PGOrbit[] = [];\n    const newmoveops: PGOrbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      // don't consider rotations when optimizing\n      for (let j = 0; j < this.moveops.length; j++) {\n        if (!this.isRotation[j]) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              changed[k] = true;\n              du.union(k, this.moveops[j].orbits[i].perm[k]);\n            }\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n      this.isRotation,\n      this.forcenames,\n    );\n  }\n\n  // replace the solved state with a new scrambled state.\n  public scramble(n: number): void {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  public getScrambleTransformation(n: number): PGTransform {\n    // don't let n be too tiny\n    if (n < 100) {\n      n = 100;\n    }\n    const pool: PGTransform[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n\n  public reassemblySize(): bigint {\n    let n = 1n;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class PGOrbit {\n  private static kcache: Record<string, number[]>[] = [];\n\n  public static e(n: number, mod: number): PGOrbit {\n    return new PGOrbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: PGOrbit): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: PGOrbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private zeroOris(): boolean {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public appendDefinition(\n    result: string[],\n    name: string,\n    useVS: boolean,\n    concise: boolean = true,\n  ): void {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_: number) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array<number>(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n\n  // TODO: return type\n  public toKPuzzle(): Record<string, number[]> {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!PGOrbit.kcache[n]) {\n        PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return PGOrbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n}\nexport class PGTransformBase {\n  constructor(public orbits: PGOrbit[]) {}\n  public internalMul(b: PGTransformBase): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  protected internalInv(): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: PGTransformBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected killOri(): this {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n}\nexport class PGTransform extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): PGTransform {\n    return new PGTransform(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): PGTransform {\n    if (n === 0) {\n      return this.e();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let t: PGTransform = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): PGTransform {\n    return new PGTransform(this.internalInv());\n  }\n\n  public e(): PGTransform {\n    return new PGTransform(\n      this.orbits.map((_: PGOrbit) => PGOrbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  private heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"0: canonseq 1\");\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(`${d}\": canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n","export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"tetraminx\": \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"teraminx\": \"d f 0.64 f 0.76 f 0.88\",\n  \"petaminx\": \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  \"examinx\": \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  \"zetaminx\": \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  \"yottaminx\": \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  \"pentultimate\": \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  \"starminx\": \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face: Quat[] = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): bigint {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): bigint {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1n;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1n;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n","import { Move, QuantumMove } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n  TetraminxNotationMapper,\n} from \"./notation-mapping\";\nimport {\n  BaseFaceCount,\n  FaceBasedOrientationDescription,\n  FaceBasedOrientationDescriptionLookup,\n  PuzzleGeometryFullOptions,\n  PuzzleGeometryOptions,\n} from \"./Options\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  externalName,\n  PGOrbit,\n  PGOrbitDef,\n  PGOrbitsDef,\n  PGTransform,\n  showcanon,\n  VisibleState,\n} from \"./PermOriSet\";\nimport { PGPuzzles, PuzzleDescriptionString, PuzzleName } from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, Quat } from \"./Quat\";\nimport { schreierSims } from \"./SchreierSims\";\n\nexport interface TextureMapper {\n  getuv(fn: number, threed: number[]): number[];\n}\n\nexport interface StickerDatSticker {\n  coords: number[];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n  face: number;\n  isDup?: boolean;\n}\n\nexport interface StickerDatFace {\n  coords: number[];\n  name: string;\n}\n\nexport type StickerDatAxis = {\n  coordinates: number[];\n  quantumMove: Move;\n  order: number;\n};\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): Move | null;\n  notationMapper: NotationMapper;\n  textureMapper: TextureMapper;\n}\n\n// you can fill these in to help with timing if you want\nfunction tstart(s: string): string {\n  return s;\n}\n\nfunction tend(_: string): void {}\n\nclass Face {\n  private coords: number[];\n  public length: number;\n  constructor(q: Quat[]) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n\n  get(off: number): Quat {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2],\n    );\n  }\n\n  centermass(): Quat {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n\n  rotate(q: Quat): Face {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n\n  rotateforward(): Face {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n}\n\nexport class FaceTree {\n  constructor(\n    private face: Quat[],\n    private left?: FaceTree,\n    private right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Face[], leftfirst: boolean): Face[] {\n    if (this.left === undefined) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport function expandfaces(rots: Quat[], faces: Face[]): Face[] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// Orientation conventions are specified here.  For each of the five platonic\n// solids, by face count, we have three lists of \"cubie names\" consisting of\n// a concatenation of face names.  For vertex (corner) and edge cubies, the\n// first face in the concatenated name is the one that will be marked.\n// For center orientations, the first face specifies which center we are\n// referring to, and the second face specifies the direction of the mark for\n// that face.\n\nconst orientationDefaults = {\n  4: {\n    v: [\"DFR\", \"DLF\", \"DRL\", \"FLR\"],\n    e: [\"FR\", \"LF\", \"DF\", \"DL\", \"RD\", \"RL\"],\n    c: [\"DF\", \"FD\", \"RL\", \"LR\"],\n  },\n  6: {\n    v: [\"URF\", \"UBR\", \"ULB\", \"UFL\", \"DFR\", \"DRB\", \"DBL\", \"DLF\"],\n    e: [\"UF\", \"UR\", \"UB\", \"UL\", \"DF\", \"DR\", \"DB\", \"DL\", \"FR\", \"FL\", \"BR\", \"BL\"],\n    c: [\"UB\", \"LU\", \"FU\", \"RU\", \"BU\", \"DF\"],\n  },\n  8: {\n    v: [\"UBBBRR\", \"URFL\", \"ULBLBB\", \"DBRBBBL\", \"DBLLF\", \"DFRBR\"],\n    e: [\n      \"UL\",\n      \"UBB\",\n      \"UR\",\n      \"BRD\",\n      \"BLD\",\n      \"FD\",\n      \"BRR\",\n      \"FR\",\n      \"FL\",\n      \"BLL\",\n      \"BLBB\",\n      \"BRBB\",\n    ],\n    c: [\"BBU\", \"LU\", \"RU\", \"BRD\", \"FD\", \"BLD\", \"DF\", \"UBB\"],\n  },\n  12: {\n    v: [\n      \"URF\",\n      \"UFL\",\n      \"ULBL\",\n      \"UBLBR\",\n      \"UBRR\",\n      \"DEBF\",\n      \"DBFI\",\n      \"DIA\",\n      \"DAC\",\n      \"DCE\",\n      \"LAI\",\n      \"ALF\",\n      \"FCA\",\n      \"CFR\",\n      \"REC\",\n      \"ERBR\",\n      \"BRBFE\",\n      \"BFBRBL\",\n      \"BLIBF\",\n      \"IBLL\",\n    ],\n    e: [\n      \"UF\",\n      \"UR\",\n      \"UBR\",\n      \"UBL\",\n      \"UL\",\n      \"ER\",\n      \"EBR\",\n      \"EBF\",\n      \"ED\",\n      \"EC\",\n      \"IBF\",\n      \"IBL\",\n      \"IL\",\n      \"IA\",\n      \"ID\",\n      \"AC\",\n      \"CF\",\n      \"FA\",\n      \"BFBR\",\n      \"BRBL\",\n      \"BLBF\",\n      \"CD\",\n      \"AD\",\n      \"AL\",\n      \"FL\",\n      \"FR\",\n      \"CR\",\n      \"BFD\",\n      \"BRR\",\n      \"BLL\",\n    ],\n    c: [\n      \"UF\",\n      \"FU\",\n      \"DBF\",\n      \"BFD\",\n      \"AD\",\n      \"CD\",\n      \"BRU\",\n      \"BLU\",\n      \"LA\",\n      \"RA\",\n      \"EBR\",\n      \"IBL\",\n    ],\n  },\n  20: {\n    v: [\n      \"FLPQU\",\n      \"FUGER\",\n      \"FRCAL\",\n      \"HCREI\",\n      \"ISBDH\",\n      \"JSIEG\",\n      \"BSJMK\",\n      \"MQPOK\",\n      \"ONDBK\",\n      \"NOPLA\",\n      \"UQMJG\",\n      \"DNACH\",\n    ],\n    e: [\n      \"FU\",\n      \"FL\",\n      \"FR\",\n      \"EG\",\n      \"ER\",\n      \"EI\",\n      \"SJ\",\n      \"SI\",\n      \"SB\",\n      \"KM\",\n      \"KB\",\n      \"KO\",\n      \"PQ\",\n      \"PO\",\n      \"PL\",\n      \"UG\",\n      \"JG\",\n      \"MQ\",\n      \"UQ\",\n      \"HC\",\n      \"HD\",\n      \"ND\",\n      \"NA\",\n      \"JM\",\n      \"CA\",\n      \"AL\",\n      \"CR\",\n      \"HI\",\n      \"DB\",\n      \"NO\",\n    ],\n    c: [\n      \"FU\",\n      \"UF\",\n      \"GE\",\n      \"EG\",\n      \"JS\",\n      \"SJ\",\n      \"MK\",\n      \"KM\",\n      \"QP\",\n      \"PQ\",\n      \"LA\",\n      \"AL\",\n      \"RC\",\n      \"CR\",\n      \"IH\",\n      \"HI\",\n      \"BD\",\n      \"DB\",\n      \"ON\",\n      \"NO\",\n    ],\n  },\n};\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): FaceBasedOrientationDescriptionLookup {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n  };\n}\n\nfunction findelement(a: Quat[][], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getPG3DNamedPuzzles(): {\n  [s: string]: PuzzleDescriptionString;\n} {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getPuzzleDescriptionString(\n  puzzleName: PuzzleName,\n): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport const PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"] as const;\nexport type PuzzleBaseShape = typeof PUZZLE_BASE_SHAPES[number];\n\nexport const PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"] as const;\nexport type PuzzleCutType = typeof PUZZLE_CUT_TYPES[number];\n\nexport type PuzzleCutDescription = { cutType: PuzzleCutType; distance: number };\nexport type PuzzleDescription = {\n  shape: PuzzleBaseShape;\n  cuts: PuzzleCutDescription[];\n};\n\nexport function parsePuzzleDescription(\n  s: PuzzleDescriptionString,\n): PuzzleDescription | null {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (\n    shape !== \"o\" &&\n    shape !== \"c\" &&\n    shape !== \"i\" &&\n    shape !== \"d\" &&\n    shape !== \"t\"\n  ) {\n    return null;\n  }\n  const cuts: PuzzleCutDescription[] = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i] as PuzzleCutType,\n      distance: parseFloat(a[i + 1]),\n    });\n  }\n  return { shape, cuts };\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: PuzzleGeometryOptions = {},\n): PuzzleGeometry {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true } as PuzzleGeometryOptions, options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options?: PuzzleGeometryOptions,\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(\n  geo: any,\n  bits: number[],\n  slices: number,\n): [string, boolean] {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0] as string;\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw new Error(\n      `We only support slice and outer block moves right now. ${bits}`,\n    );\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: [Quat[], string][]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (\n        s.substr(at).startsWith(facename[1]) &&\n        facename[1].length > currentMatch.length\n      ) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Face, maxdist: number): number[] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\n\n/** @category PuzzleGeometry */\nexport class PuzzleGeometry {\n  private rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  private baseplanes: Quat[]; // planes, corresponding to faces\n  private facenames: [Quat[], string][]; // face names\n  private faceplanes: [Quat, string][]; // face planes\n  private edgenames: [Quat, string][]; // edge names\n  private vertexnames: [Quat, string][]; // vertexnames\n  private geonormals: [Quat, string, string][]; // all geometric directions, with names and types\n  private moveplanes: Quat[]; // the planes that split moves\n  private moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: Quat[][]; // the move planes, in parallel sets\n  private moveplanenormals: Quat[]; // one move plane\n  public movesetorders: number[]; // the order of rotations for each move set\n  public movesetgeos: [string, string, string, string, number][]; // geometric feature information for move sets\n  private basefaces: Face[]; // polytope faces before cuts\n  private faces: Face[]; // all the stickers\n  private facecentermass: Quat[]; // center of mass of all faces\n  private baseFaceCount: BaseFaceCount; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public shortedge: number; // number of stickers per face\n  private markedface: number[]; // given a bitmap of faces, identify the marked one\n  public cubies: number[][]; // the cubies\n  private vertexdistance: number; // vertex distance\n  private edgedistance: number; // edge distance\n  private facetocubie: number[]; // map a face to a cubie index\n  private facetoord: number[]; // map a face to a cubie ord\n  private moverotations: Quat[][]; // move rotations\n  private facelisthash: Map<string, number[]>; // face list by key\n  private cubiesetnames: string[]; // cubie set names\n  private cubieords: number[]; // the size of each orbit\n  private cubiesetnums: number[];\n  private cubieordnums: number[];\n  private orbitoris: number[]; // the orientation size of each orbit\n  private cubievaluemap: number[]; // the map for identical cubies\n  private cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  public parsedmovelist: [\n    string | undefined,\n    number,\n    number,\n    number,\n    boolean,\n    number,\n  ][]; // parsed move list\n\n  private duplicatedFaces: number[] = []; // which faces are duplicated\n  private duplicatedCubies: number[] = []; // which cubies are duplicated\n  private fixedCubie: number = -1; // fixed cubie, if any\n  private net: string[][] = [];\n  private colors: any = [];\n  private swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  private addNotationMapper: string = \"\";\n  private setReidOrder: boolean = false;\n\n  private options: PuzzleGeometryFullOptions;\n\n  constructor(\n    public puzzleDescription: PuzzleDescription,\n    options: PuzzleGeometryOptions,\n  ) {\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n\n  public create(puzzleDescription: PuzzleDescription): void {\n    const { shape, cuts } = puzzleDescription;\n\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length as BaseFaceCount;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cut.cutType);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n! where\n    //   n planes meet at a vertex.  We set names by choosing the marked face\n    //   first, and going counterclockwise around.\n    //\n    const facenames: [Quat[], string][] = [];\n    const faceplanes: [Quat, string][] = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (const el of a) {\n        if (el[0].dist(p) < eps) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: string[] = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    const oridata = orientationDefaults[this.baseFaceCount];\n    const markedface = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      markedface[1 << i] = i;\n    }\n    // FIXME  eliminate the duplications below\n    {\n      const oriprefs = oridata[\"v\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"e\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"c\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        const bits = (1 << fn[0]) | (1 << this.baseFaceCount);\n        markedface[bits] = fn[1];\n      }\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      const f1 = edgenames[i][1];\n      const f2 = edgenames[i][2];\n      let c1 = faceindextoname[f1];\n      const c2 = faceindextoname[f2];\n      const bits = (1 << f1) | (1 << f2);\n      if (markedface[bits] == f1) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; proper orientation.\n    for (let i = 0; i < vertexnames.length; i++) {\n      let bits = 0;\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        bits |= 1 << facenametoindex[vertexnames[i][j][0]];\n      }\n      const fi = markedface[bits];\n      let st = -1;\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (fi === facenametoindex[vertexnames[i][j][0]]) {\n          st = j;\n        }\n      }\n      if (st < 0) {\n        throw new Error(\n          \"Internal error; couldn't find face name when fixing corners\",\n        );\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    this.markedface = markedface;\n    if (this.options.verbosity > 1) {\n      console.log(\"# Face names: \" + facenames.map((_) => _[1]).join(\" \"));\n      // TODO\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      console.log(\"# Edge names: \" + edgenames.map((_) => _[1]).join(\" \"));\n      // TODO\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      console.log(\"# Vertex names: \" + vertexnames.map((_) => _[1]).join(\" \"));\n    }\n    const geonormals: [Quat, string, string][] = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        \"# Distances: face \" +\n          1 +\n          \" edge \" +\n          this.edgedistance +\n          \" vertex \" +\n          this.vertexdistance,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    // the faces when rotated don't preserve the vertex order at this\n    // point.  to improve 3d rendering speed, we would like to preserve\n    // vertex order on rotation.  First, let's see what rotations preserve\n    // the base face; these are the ones we want to work with.\n    const simplerot: Quat[] = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array<boolean>(faces.length);\n    const sortme: [number, Quat, number][] = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm.dist(sortme[kk][1]) < eps) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(\"# Short edge is \" + this.shortedge);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!sawedge && !sawvertex) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  private keyface(face: Face): string {\n    return this.keyface2(face.centermass());\n  }\n\n  private keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + (t % 47));\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s =\n            s +\n            sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) +\n            sfcc(33 + 47 + (Math.floor((t - 47) / 47) % 47)) +\n            sfcc(33 + (t % 47));\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  private keyface3(face: Face): number[] {\n    const cm = face.centermass();\n    // take a face and figure out the sides of each move plane\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n\n  private findface(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key)!;\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)![i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  private project2d(\n    facen: number,\n    edgen: number,\n    targvec: Quat[],\n  ): [Quat, Quat, Quat] {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    const t1 = tstart(\"allstickers\");\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos: [string, string, string, string, number][] = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (\n          moveplanesets[0].length === 2 &&\n          moveplanesets[0][0].a === 0.333333333333333 &&\n          moveplanesets[0][1].a === 1.66666666666667\n        ) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const facelisthash = new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s)!;\n        arr.push(i);\n        //  If we find a core cubie, split it up into multiple cubies,\n        //  because ksolve doesn't handle orientations that are not\n        //  cyclic, and the rotation group of the core is not cyclic.\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = s + \" \" + suff;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubies: \" + facelisthash.size);\n    }\n    const cubies: number[][] = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        // this is the original \"cubie\" of a split core; we ignore it.\n        continue;\n      }\n      //  Sort the faces around each corner so they are counterclockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      if (facelist.length > 1) {\n        const cm = facelist.map((_: number) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1000) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        // set the orientations by finding the marked face and putting it first.\n        let bits = 0;\n        for (const f of facelist) {\n          bits |= 1 << Math.floor(f / this.stickersperface);\n        }\n        const markedface = this.markedface[bits]!;\n        let mini = -1;\n        for (let i = 0; i < facelist.length; i++) {\n          if (Math.floor(facelist[i] / this.stickersperface) === markedface) {\n            mini = i;\n          }\n        }\n        if (mini < 0) {\n          throw new Error(\"Could not find marked face in list\");\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      if (seen[i]) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq =\n              this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (\n      this.setReidOrder &&\n      4 <= this.stickersperface &&\n      this.stickersperface <= 9\n    ) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << (cubie[j].charCodeAt(k) - 65);\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |=\n              1 <<\n              (this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65);\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.options.fixedPieceType === \"v\" && cubies[i].length > 2) ||\n          (this.options.fixedPieceType === \"e\" && cubies[i].length === 2) ||\n          (this.options.fixedPieceType === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          \"Could not find a cubie of type \" +\n            this.options.fixedPieceType +\n            \" to fix.\",\n        );\n      }\n    }\n    // show the orbits\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n    tend(t1);\n  }\n\n  public unswizzle(mv: Move): Move | null {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  private stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(\n    move: Move,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw new Error(\"Bad move \" + move.family);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + move.family);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        // big assumption here!  if outerlayer not specified, but inner\n        // layer is (like 2U), we use the case of the family (upper vs\n        // lower) to decide if it should be a slice turn or a wide turn.\n        if (grip <= \"Z\") {\n          // uppercase; slice move\n          loslice = hislice;\n        } else {\n          // lowercase; wide move\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\n        \"Bad slice spec \" +\n          loslice +\n          \" \" +\n          hislice +\n          \" vs \" +\n          this.moveplanesets[msi].length,\n      );\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    return [undefined, msi, loslice, hislice, firstgrip, move.amount];\n  }\n\n  private parsemove(\n    mv: string,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    const t1 = tstart(\"genperms\");\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    //\n    //  We also rotate the vertices of the face to enforce the orientation\n    //  preferences for the oriented center stickers.\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          const center = this.basefaces[i].centermass();\n          if (center.dist(this.facecentermass[kk]) < eps) {\n            const bits = (1 << i) | (1 << this.baseFaceCount);\n            const towards = this.markedface[bits];\n            const normal = this.baseplanes[towards].makenormal();\n            let hiv = -1;\n            let hii = -1;\n            for (let ii = 0; ii < this.faces[kk].length; ii++) {\n              const pt = this.faces[kk].get(ii);\n              const t = normal.dot(pt.sub(center));\n              if (t > hiv) {\n                hiv = t;\n                hii = ii;\n              }\n            }\n            // if two pts have the same distance, prefer the second\n            const hii2 = (hii + 1) % this.faces[kk].length;\n            if (\n              Math.abs(normal.dot(this.faces[kk].get(hii2).sub(center)) - hiv) <\n              eps\n            ) {\n              hii = hii2;\n            }\n            // remake the face to preserve orientations\n            if (hii != 0) {\n              const qs = [];\n              for (let ii = 0; ii < this.faces[kk].length; ii++) {\n                qs.push(this.faces[kk].get((ii + hii) % this.faces[kk].length));\n              }\n              this.faces[kk] = new Face(qs);\n            }\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.options.orientCenters &&\n          (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            this.facecentermass[i].dist(\n              this.basefaces[this.getfaceindex(i)].centermass(),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        // b.length == 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.options.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k],\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist: [\n        string | undefined,\n        number,\n        number,\n        number,\n        boolean,\n        number,\n      ][] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n\n  private getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  private getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    let r: any[] = [];\n    if (this.parsedmovelist !== undefined) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    // TODO\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return r;\n  }\n\n  private graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 &&\n        (this.options.grayCenters || !this.options.includeCenterOrbits)) ||\n      (ori === 2 &&\n        (this.options.grayEdges || !this.options.includeEdgeOrbits)) ||\n      (ori > 2 &&\n        (this.options.grayCorners || !this.options.includeCornerOrbits))\n    );\n  }\n\n  private skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.options.includeCenterOrbits) ||\n      (ori === 2 && !this.options.includeEdgeOrbits) ||\n      (ori > 2 && !this.options.includeCornerOrbits)\n    );\n  }\n\n  private skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  private header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = \"M_\" + externalName(this.notationMapper, os.movenames[i]);\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      if (doinv) {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().inv().toGap() + \";\");\n      } else {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      \"ip:=[\" +\n        ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") +\n        \"];\",\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\"): string {\n    const od = this.getOrbitsDef(false);\n    return (\n      this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\")\n    );\n  }\n\n  public getKPuzzleDefinition(\n    fortwisty: boolean = true,\n    includemoves: boolean = true,\n  ): KPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    (internalDefinition as any).experimentalPuzzleDescription =\n      this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): PGTransform {\n    const moveorbits: PGOrbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  private omitSet(name: string): boolean {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private diffmvsets(a: any[], b: any[], slices: number, neg: boolean) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (\n            a[i][0] + b[j][1] === slices &&\n            a[i][1] + b[j][0] === slices &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        } else {\n          if (\n            a[i][0] === b[j][0] &&\n            a[i][1] === b[j][1] &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: This is only public for testing; can we make it private again?\n  public getOrbitsDef(\n    fortwisty: boolean,\n    includemoves: boolean = true,\n  ): PGOrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames: string[] = [];\n    const setdefs: PGOrbitDef[] = [];\n    // if both a movelist and rotations are needed, don't add rotations\n    // that do not preserve the movelist.\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    const hasrotation = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const slices = this.moveplanesets[k].length;\n      // if the move set includes a rotation around this axis, don't add any more\n      let sawone = false;\n      const moveset = mps[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        if (moveset[i][0] === 0 && moveset[i][1] === slices) {\n          sawone = true;\n        }\n      }\n      hasrotation[k] = sawone;\n    }\n    if (this.options.moveList && this.options.addRotations) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        // if the move set includes a rotation around this axis, don't add any more\n        if (hasrotation[k]) {\n          addrot[k] = 3;\n          continue;\n        }\n        // does a rotation around k preserve the move set?\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (\n              cmp.length !== mps[k].length ||\n              this.moveplanesets[k].length !==\n                this.moveplanesets[found].length ||\n              this.diffmvsets(\n                cmp,\n                mps[k],\n                this.moveplanesets[found].length,\n                neg,\n              )\n            ) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0 && !hasrotation[k]) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (\n            moveset[i][0] === moveset[j][0] &&\n            moveset[i][1] === moveset[j][1]\n          ) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieords[i],\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: PGOrbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const movenames: string[] = [];\n    const forcenames: boolean[] = [];\n    const moves: PGTransform[] = [];\n    const isrots: boolean[] = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          // did these movebits come from a specified move?\n          // if they did, we need to use that name.\n          let nameoverride: string | undefined;\n          let inverted = false;\n          if (this.parsedmovelist !== undefined) {\n            for (const parsedmove of this.parsedmovelist) {\n              if (parsedmove[1] !== k) {\n                continue;\n              }\n              let r = [];\n              if (parsedmove[4]) {\n                r = [parsedmove[2], parsedmove[3]];\n              } else {\n                r = [slices - parsedmove[3], slices - parsedmove[2]];\n              }\n              if (r[0] === movebits[0] && r[1] === movebits[1]) {\n                nameoverride = parsedmove[0];\n                inverted = !parsedmove[4];\n              }\n            }\n          }\n          if (nameoverride) {\n            movenames.push(nameoverride);\n            forcenames.push(true);\n          } else {\n            const mna = getmovename(movesetgeo, movebits, slices);\n            inverted = mna[1];\n            const movename = mna[0];\n            if (moveset[i + 1] === 1) {\n              movenames.push(movename);\n            } else {\n              movenames.push(movename + moveset[i + 1]);\n            }\n            forcenames.push(false);\n          }\n          isrots.push(movebits[0] === 0 && movebits[1] === slices);\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesbyslice[k],\n            setmoves,\n            this.movesetorders[k],\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n      isrots,\n      forcenames,\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n\n  public getScramble(n: number = 0): KTransformationData {\n    const od = this.getOrbitsDef(false);\n    return od.transformToKTransformationData(od.getScrambleTransformation(n));\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  private getOrientationRotation(desiredRotation: any[]): Quat {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  private getInitial3DRotation(): Quat {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription: FaceBasedOrientationDescription | null = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n\n  private generate2dmapping(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n    twodshrink: number = 0.92,\n  ): (fn: number, q: Quat) => number[] {\n    // generate a mapping to use for 2D for textures, svg\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: Record<string, Quat[]> = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c,\n        ];\n      }\n    };\n    return mappt2d;\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return (\n        '<polygon id=\"' +\n        id +\n        '\" class=\"sticker\" style=\"fill: ' +\n        color +\n        '\" points=\"' +\n        pts.map((p) => p[0] + \" \" + p[1]).join(\" \") +\n        '\"/>\\n'\n      );\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id =\n          this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html =\n      '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") +\n      \"</svg>\";\n    return html;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(options?: { stickerColors?: string[] }): StickerDat {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist: number = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum,\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order,\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order,\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1.0);\n    const g = (function () {\n      const irot = rot.invrot();\n      return function (facenum: number, coords: number[]): number[] {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist,\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g },\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n\n  public textForTwizzleExplorer(): string {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n\n  writeSchreierSims(tw: (s: string) => void) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n}\n\nexport class PGNotation {\n  private orbitNames: string[];\n  constructor(private pg: PuzzleGeometry, od: PGOrbitsDef) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformationData | null {\n    const mv = this.pg.parseMove(move);\n    // if a move list subset is defined, don't return moves outside the subset.\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (\n          parsedmove[1] === mv[1] &&\n          parsedmove[2] === mv[2] &&\n          parsedmove[3] === mv[3] &&\n          parsedmove[4] === mv[4]\n        ) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n}\n"],"names":[],"version":3,"file":"puzzle-geometry.db2a4a3f.js.map"}