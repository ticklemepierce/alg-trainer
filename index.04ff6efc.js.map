{"mappings":"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AAY;YAC5B,OAAA,CAAQ,SAAR,EAAA,CAAA,CAAA;SAAQ,CAAA,CAAA;KAAA;IAAA,OAIL,OAAA,CAAQ,KAAA,EAAO;QACpB,OAAO,IAAI,2BAAA,CAAM,CAAC,OAAA,GAAY;YAC5B,OAAA,CAAQ,KAAR,CAAA,CAAA;SAAQ,CAAA,CAAA;KAAA;IAAA,OAIL,MAAA,CAAO,KAAA,EAAO;QACnB,OAAO,IAAI,2BAAA,CAAM,CAAC,QAAA,EAAU,MAAA,GAAW;YACrC,MAAA,CAAO,KAAP,CAAA,CAAA;SAAO,CAAA,CAAA;KAAA;IAIX,IAAA,CAAK,WAAA,EAAa,UAAA,EAAY;QAC5B,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,QAAA,IAAY,IAAI,OAAA,CAAQ,IAAA,CAAK,SAAlD,CAAA,CAAA;QAGA,OAAO,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,WAAA,EAAa,UAAvC,CAAA,CAAA;KAAuC;IAGzC,KAAA,CAAM,UAAA,EAAY;QAChB,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,QAAA,IAAY,IAAI,OAAA,CAAQ,IAAA,CAAK,SAAlD,CAAA,CAAA;QAGA,OAAO,IAAA,CAAK,QAAA,CAAS,KAAA,CAAM,UAA3B,CAAA,CAAA;KAA2B;CAAA,AAAA;AAIxB,SAAA,yCAAA,CAAiB,SAAA,EAAuB;IAC7C,OAAO,IAAI,2BAAA,CAAM,CAAC,OAAA,GAAY;QAC5B,OAAA,CAAQ,SAAR,EAAA,CAAA,CAAA;KAAQ,CAAA,CAAA;CAAA;;;;;;;;;;;A,I,mC,G,C,G,E,M,E,G,G;I,I,C,M,C,G,C,G,C,E,M,S,C,S,G,G,C,C;C,A;A,I,yC,G,C,G,E,M,E,M,G;I,mC,C,G,E,M,E,yB,C,C;I,O,M,G,M,C,I,C,G,C,G,M,C,G,C,G,C,C;C,A;A,I,yC,G,C,G,E,M,E,K,G;I,I,M,C,G,C,G,C,E,M,S,C,mD,C,C;I,M,Y,O,G,M,C,G,C,G,C,G,M,C,G,C,G,E,K,C,C;C,A;A,I,yC,G,C,G,E,M,E,K,E,M,G;I,mC,C,G,E,M,E,wB,C,C;I,M,G,M,C,I,C,G,E,K,C,G,M,C,G,C,G,E,K,C,C;I,O,K,C;C,A;A,I,yC,G,C,G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","sources":["node_modules/@parcel/runtime-js/lib/runtime-fddd857769b7264e.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/cubing/dist/esm/chunk-RECTK3R2.js","node_modules/cubing/src/cubing/twisty/model/PromiseFreshener.ts","node_modules/cubing/src/cubing/twisty/model/props/TwistyProp.ts","node_modules/cubing/src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts","node_modules/cubing/src/cubing/twisty/views/3D/TAU.ts","node_modules/cubing/src/cubing/twisty/heavy-code-imports/3d.ts","node_modules/cubing/dist/esm/chunk-YBDBUTYE.js","node_modules/cubing/src/cubing/vendor/p-lazy/p-lazy.ts","node_modules/cubing/dist/esm/chunk-MGJA5U5O.js","node_modules/@parcel/runtime-js/lib/runtime-7affda4427b20b24.js","node_modules/cubing/dist/esm/chunk-NQORDEXF.js","node_modules/cubing/src/cubing/alg/common.ts","node_modules/cubing/src/cubing/alg/iteration.ts","node_modules/cubing/src/cubing/alg/limits.ts","node_modules/cubing/src/cubing/alg/AlgBuilder.ts","node_modules/cubing/src/cubing/alg/debug.ts","node_modules/cubing/src/cubing/alg/units/containers/Commutator.ts","node_modules/cubing/src/cubing/alg/units/containers/Conjugate.ts","node_modules/cubing/src/cubing/alg/units/leaves/LineComment.ts","node_modules/cubing/src/cubing/alg/units/leaves/Newline.ts","node_modules/cubing/src/cubing/alg/units/leaves/Pause.ts","node_modules/cubing/src/cubing/alg/parse.ts","node_modules/cubing/src/cubing/alg/warnOnce.ts","node_modules/cubing/src/cubing/alg/units/QuantumWithAmount.ts","node_modules/cubing/src/cubing/alg/units/leaves/Move.ts","node_modules/cubing/src/cubing/alg/units/containers/Grouping.ts","node_modules/cubing/src/cubing/alg/is.ts","node_modules/cubing/src/cubing/alg/traversal.ts","node_modules/cubing/src/cubing/alg/Alg.ts","node_modules/cubing/src/cubing/alg/example.ts","node_modules/cubing/src/cubing/alg/keyboard.ts","node_modules/cubing/src/cubing/alg/url.ts","node_modules/cubing/src/cubing/alg/operation.ts","node_modules/cubing/dist/esm/chunk-LNUPGLIU.js","node_modules/cubing/src/cubing/puzzles/events.ts","node_modules/cubing/src/cubing/puzzles/stickerings/cube-stickerings.ts","node_modules/cubing/src/cubing/puzzles/async/lazy-cached.ts","node_modules/cubing/src/cubing/puzzles/async/async-pg3d.ts","node_modules/cubing/src/cubing/puzzles/implementations/2x2x2/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/clock/index.ts","node_modules/cubing/src/cubing/puzzles/stickerings/fto-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/fto/index.ts","node_modules/cubing/src/cubing/puzzles/stickerings/megaminx-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/megaminx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/pyraminx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/square1/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/kilominx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/redi-cube/index.ts","node_modules/cubing/src/cubing/puzzles/index.ts","node_modules/cubing/dist/esm/chunk-VYMKSHDI.js","node_modules/cubing/src/cubing/puzzles/stickerings/appearance.ts","node_modules/cubing/src/cubing/puzzles/stickerings/puzzle-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts","node_modules/cubing/src/cubing/puzzles/customPGPuzzleLoader.ts","node_modules/cubing/src/cubing/puzzles/cubing-private/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts","node_modules/cubing/dist/esm/chunk-VY7VF4MA.js","node_modules/cubing/src/cubing/kpuzzle/combine.ts","node_modules/cubing/src/cubing/kpuzzle/construct.ts","node_modules/cubing/src/cubing/kpuzzle/KState.ts","node_modules/cubing/src/cubing/kpuzzle/KTransformation.ts","node_modules/cubing/src/cubing/kpuzzle/calculate.ts","node_modules/cubing/src/cubing/kpuzzle/KPuzzle.ts","node_modules/@parcel/runtime-js/lib/runtime-b00f945a81c68652.js","node_modules/@parcel/runtime-js/lib/runtime-200700551729c090.js","node_modules/@parcel/runtime-js/lib/runtime-52c5656c8ffda7ea.js","node_modules/@parcel/runtime-js/lib/runtime-7d1797917bdde2c4.js"],"sourcesContent":["require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"bJecT\\\":\\\"index.04ff6efc.js\\\",\\\"hb4G1\\\":\\\"twisty-dynamic-3d-UJR5FP6R.c10267fc.js\\\",\\\"eXwSi\\\":\\\"puzzle-geometry.db2a4a3f.js\\\",\\\"35dX4\\\":\\\"puzzles-dynamic-side-events-HOXBZYWI.1477501b.js\\\",\\\"CLUvY\\\":\\\"puzzles-dynamic-3x3x3-NB2PEZTV.372c3936.js\\\",\\\"4VSor\\\":\\\"puzzles-dynamic-unofficial-MGVOFUDR.98e1c48f.js\\\"}\"));","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import {\n  from\n} from \"./chunk-YBDBUTYE.js\";\nimport {\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet,\n  __privateWrapper\n} from \"./chunk-MGJA5U5O.js\";\n\n// src/cubing/twisty/model/PromiseFreshener.ts\nvar _latestAssignedIdx, _latestResolvedIdx;\nvar PromiseFreshener = class {\n  constructor() {\n    __privateAdd(this, _latestAssignedIdx, 0);\n    __privateAdd(this, _latestResolvedIdx, 0);\n  }\n  async queue(p) {\n    const idx = ++__privateWrapper(this, _latestAssignedIdx)._;\n    const result = await p;\n    if (idx > __privateGet(this, _latestResolvedIdx)) {\n      __privateSet(this, _latestResolvedIdx, idx);\n      return {\n        fresh: true,\n        result\n      };\n    } else {\n      return { fresh: false };\n    }\n  }\n};\n_latestAssignedIdx = new WeakMap();\n_latestResolvedIdx = new WeakMap();\nvar _latestAssignedIdx2, _latestResolvedIdx2;\nvar StaleDropper = class {\n  constructor() {\n    __privateAdd(this, _latestAssignedIdx2, 0);\n    __privateAdd(this, _latestResolvedIdx2, 0);\n  }\n  queue(p) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++__privateWrapper(this, _latestAssignedIdx2)._;\n        const result = await p;\n        if (idx > __privateGet(this, _latestResolvedIdx2)) {\n          __privateSet(this, _latestResolvedIdx2, idx);\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n};\n_latestAssignedIdx2 = new WeakMap();\n_latestResolvedIdx2 = new WeakMap();\n\n// src/cubing/twisty/model/props/TwistyProp.ts\nvar globalSourceGeneration = 0;\nvar _children, _rawListeners, _scheduleRawDispatch, scheduleRawDispatch_fn, _rawDispatchPending, _dispatchRawListeners, dispatchRawListeners_fn, _freshListeners;\nvar TwistyPropParent = class {\n  constructor() {\n    __privateAdd(this, _scheduleRawDispatch);\n    __privateAdd(this, _dispatchRawListeners);\n    __privateAdd(this, _children, /* @__PURE__ */ new Set());\n    this.lastSourceGeneration = 0;\n    __privateAdd(this, _rawListeners, /* @__PURE__ */ new Set());\n    __privateAdd(this, _rawDispatchPending, false);\n    __privateAdd(this, _freshListeners, /* @__PURE__ */ new Map());\n  }\n  canReuse(v1, v2) {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n  canReuseValue(_v1, _v2) {\n    return false;\n  }\n  debugGetChildren() {\n    return Array.from(__privateGet(this, _children).values());\n  }\n  addChild(child) {\n    __privateGet(this, _children).add(child);\n  }\n  removeChild(child) {\n    __privateGet(this, _children).delete(child);\n  }\n  markStale(sourceEvent) {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of __privateGet(this, _children)) {\n      child.markStale(sourceEvent);\n    }\n    __privateMethod(this, _scheduleRawDispatch, scheduleRawDispatch_fn).call(this);\n  }\n  addRawListener(listener, options) {\n    __privateGet(this, _rawListeners).add(listener);\n    if (options?.initial) {\n      listener();\n    }\n  }\n  removeRawListener(listener) {\n    __privateGet(this, _rawListeners).delete(listener);\n  }\n  addFreshListener(listener) {\n    const staleDropper = new StaleDropper();\n    let lastResult = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    __privateGet(this, _freshListeners).set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n  removeFreshListener(listener) {\n    this.removeRawListener(__privateGet(this, _freshListeners).get(listener));\n    __privateGet(this, _freshListeners).delete(listener);\n  }\n};\n_children = new WeakMap();\n_rawListeners = new WeakMap();\n_scheduleRawDispatch = new WeakSet();\nscheduleRawDispatch_fn = function() {\n  if (!__privateGet(this, _rawDispatchPending)) {\n    __privateSet(this, _rawDispatchPending, true);\n    setTimeout(() => __privateMethod(this, _dispatchRawListeners, dispatchRawListeners_fn).call(this), 0);\n  }\n};\n_rawDispatchPending = new WeakMap();\n_dispatchRawListeners = new WeakSet();\ndispatchRawListeners_fn = function() {\n  if (!__privateGet(this, _rawDispatchPending)) {\n    throw new Error(\"Invalid dispatch state!\");\n  }\n  for (const listener of __privateGet(this, _rawListeners)) {\n    listener();\n  }\n  __privateSet(this, _rawDispatchPending, false);\n};\n_freshListeners = new WeakMap();\nvar _value;\nvar TwistyPropSource = class extends TwistyPropParent {\n  constructor(initialValue) {\n    super();\n    __privateAdd(this, _value, void 0);\n    __privateSet(this, _value, from(() => this.getDefaultValue()));\n    if (initialValue) {\n      __privateSet(this, _value, this.deriveFromPromiseOrValue(initialValue, __privateGet(this, _value)));\n    }\n  }\n  set(input) {\n    __privateSet(this, _value, this.deriveFromPromiseOrValue(input, __privateGet(this, _value)));\n    const sourceEventDetail = {\n      sourceProp: this,\n      value: __privateGet(this, _value),\n      generation: ++globalSourceGeneration\n    };\n    this.markStale(new CustomEvent(\"stale\", {\n      detail: sourceEventDetail\n    }));\n  }\n  async get() {\n    return __privateGet(this, _value);\n  }\n  async deriveFromPromiseOrValue(input, oldValuePromise) {\n    return this.derive(await input, oldValuePromise);\n  }\n};\n_value = new WeakMap();\nvar SimpleTwistyPropSource = class extends TwistyPropSource {\n  derive(input) {\n    return input;\n  }\n};\nvar NO_VALUE = Symbol(\"no value\");\nvar _parents, _cachedLastSuccessfulCalculation, _cachedLatestGenerationCalculation, _getParents, getParents_fn, _cacheDerive, cacheDerive_fn;\nvar TwistyPropDerived = class extends TwistyPropParent {\n  constructor(parents, userVisibleErrorTracker) {\n    super();\n    this.userVisibleErrorTracker = userVisibleErrorTracker;\n    __privateAdd(this, _getParents);\n    __privateAdd(this, _cacheDerive);\n    __privateAdd(this, _parents, void 0);\n    __privateAdd(this, _cachedLastSuccessfulCalculation, null);\n    __privateAdd(this, _cachedLatestGenerationCalculation, null);\n    __privateSet(this, _parents, parents);\n    for (const parent of Object.values(parents)) {\n      parent.addChild(this);\n    }\n  }\n  async get() {\n    const generation = this.lastSourceGeneration;\n    if (__privateGet(this, _cachedLatestGenerationCalculation)?.generation === generation) {\n      return __privateGet(this, _cachedLatestGenerationCalculation).output;\n    }\n    const latestGenerationCalculation = {\n      generation,\n      output: __privateMethod(this, _cacheDerive, cacheDerive_fn).call(this, __privateMethod(this, _getParents, getParents_fn).call(this), generation, __privateGet(this, _cachedLastSuccessfulCalculation))\n    };\n    __privateSet(this, _cachedLatestGenerationCalculation, latestGenerationCalculation);\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n};\n_parents = new WeakMap();\n_cachedLastSuccessfulCalculation = new WeakMap();\n_cachedLatestGenerationCalculation = new WeakMap();\n_getParents = new WeakSet();\ngetParents_fn = async function() {\n  const inputValuePromises = {};\n  for (const [key, parent] of Object.entries(__privateGet(this, _parents))) {\n    inputValuePromises[key] = parent.get();\n  }\n  const inputs = {};\n  for (const key in __privateGet(this, _parents)) {\n    inputs[key] = await inputValuePromises[key];\n  }\n  return inputs;\n};\n_cacheDerive = new WeakSet();\ncacheDerive_fn = async function(inputsPromise, generation, cachedLatestGenerationCalculation = null) {\n  const inputs = await inputsPromise;\n  const cache = (output) => {\n    __privateSet(this, _cachedLastSuccessfulCalculation, {\n      inputs,\n      output: Promise.resolve(output),\n      generation\n    });\n    return output;\n  };\n  if (!cachedLatestGenerationCalculation) {\n    return cache(await this.derive(inputs));\n  }\n  const cachedInputs = cachedLatestGenerationCalculation.inputs;\n  for (const key in __privateGet(this, _parents)) {\n    const parent = __privateGet(this, _parents)[key];\n    if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n      return cache(await this.derive(inputs));\n    }\n  }\n  return cachedLatestGenerationCalculation.output;\n};\nvar _disconnectionFunctions;\nvar FreshListenerManager = class {\n  constructor() {\n    __privateAdd(this, _disconnectionFunctions, []);\n  }\n  addListener(prop, listener) {\n    let disconnected = false;\n    const wrappedListener = (value) => {\n      if (disconnected) {\n        return;\n      }\n      listener(value);\n    };\n    prop.addFreshListener(wrappedListener);\n    __privateGet(this, _disconnectionFunctions).push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n  addMultiListener3(props, listener) {\n    this.addMultiListener(props, listener);\n  }\n  addMultiListener(props, listener) {\n    let disconnected = false;\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        return;\n      }\n      const promises = props.map((prop) => prop.get());\n      const values = await Promise.all(promises);\n      listener(values);\n    };\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n    __privateGet(this, _disconnectionFunctions).push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n  disconnect() {\n    for (const disconnectionFunction of __privateGet(this, _disconnectionFunctions)) {\n      disconnectionFunction();\n    }\n  }\n};\n_disconnectionFunctions = new WeakMap();\n\n// src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts\nvar hintFaceletStyles = {\n  floating: true,\n  none: true\n};\nvar HintFaceletProp = class extends SimpleTwistyPropSource {\n  getDefaultValue() {\n    return \"auto\";\n  }\n};\n\n// src/cubing/twisty/views/3D/TAU.ts\nvar TAU = Math.PI * 2;\nvar DEGREES_PER_RADIAN = 360 / TAU;\n\n// src/cubing/twisty/heavy-code-imports/3d.ts\nvar cachedConstructorProxy = null;\nasync function proxy3D() {\n  return cachedConstructorProxy ?? (cachedConstructorProxy = import(\"./twisty-dynamic-3d-UJR5FP6R.js\"));\n}\nvar THREEJS = from(async () => (await proxy3D()).T3I);\n\nexport {\n  StaleDropper,\n  TwistyPropSource,\n  SimpleTwistyPropSource,\n  NO_VALUE,\n  TwistyPropDerived,\n  FreshListenerManager,\n  hintFaceletStyles,\n  HintFaceletProp,\n  TAU,\n  DEGREES_PER_RADIAN,\n  proxy3D,\n  THREEJS\n};\n//# sourceMappingURL=chunk-RECTK3R2.js.map\n","// TODO: Pick a much better name.\nexport class PromiseFreshener<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  // TODO: reject instead? Drop?\n  async queue(\n    p: Promise<T>,\n  ): Promise<{ fresh: false } | { fresh: true; result: T }> {\n    const idx = ++this.#latestAssignedIdx;\n    const result = await p;\n    if (idx > this.#latestResolvedIdx) {\n      this.#latestResolvedIdx = idx;\n      return {\n        fresh: true,\n        result: result,\n      };\n    } else {\n      return { fresh: false };\n    }\n  }\n}\n\n// This will silenty drop a queued Promise (i.e. not resolve it) if a\n// newer queued one already resolved first. This is useful for classes that want\n// to know the \"latest\" state of something without jumping back to an older\n// value by accident.\n// TODO: Remove this because it's too easy to misuse?\nexport class StaleDropper<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  queue(p: Promise<T>): Promise<T> {\n    // This is a very rare case where we *do* want to drop a Promise sometimes.\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++this.#latestAssignedIdx;\n        const result = await p;\n        if (idx > this.#latestResolvedIdx) {\n          this.#latestResolvedIdx = idx;\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n}\n","import { from } from \"../../../vendor/p-lazy/p-lazy\";\nimport { StaleDropper } from \"../PromiseFreshener\";\nimport type { UserVisibleErrorTracker } from \"../UserVisibleErrorTracker\";\n\n/*eslint @typescript-eslint/ban-types:off */\ntype InputRecord = {};\n\nexport type InputProps<T extends InputRecord> = {\n  [s in keyof T]: TwistyPropParent<T[s]>;\n};\n\ntype InputPromises<T extends InputRecord> = {\n  [s in keyof T]: Promise<T[s]>;\n};\n\ninterface SourceEventDetail<OutputType> {\n  sourceProp: TwistyPropSource<OutputType, any>;\n  value: Promise<OutputType>; // TODO: remove?\n  generation: number;\n}\n\ntype SourceEvent<T> = CustomEvent<SourceEventDetail<T>>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\n// Values of T must be immutable.\nlet globalSourceGeneration = 0; // This is incremented before being used, so 1 will be the first active value.\nexport abstract class TwistyPropParent<T> {\n  public abstract get(): Promise<T>;\n\n  // Don't overwrite this. Overwrite `canReuseValue` instead.\n  canReuse(v1: T, v2: T): boolean {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n\n  // Overwrite with a cheap semantic comparison when possible.\n  // Note that this is not called if `v1 === v2` (in which case the value is automatically reused).\n  canReuseValue(_v1: T, _v2: T): boolean {\n    return false;\n  }\n\n  debugGetChildren(): Array<TwistyPropDerived<any, any>> {\n    return Array.from(this.#children.values());\n  }\n\n  // Propagation\n\n  #children: Set<TwistyPropDerived<any, any>> = new Set();\n  protected addChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.add(child);\n  }\n\n  protected removeChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.delete(child);\n  }\n\n  protected lastSourceGeneration: number = 0;\n  // Synchronously marks all descendants as stale. This doesn't actually\n  // literally mark as stale, but it updates the last source generation, which\n  // is used to tell if a cahced result is stale.\n  protected markStale(sourceEvent: SourceEvent<any>): void {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      // The full stale propagation is synchronous, so there should not be a new one yet.\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      // Already propagated.\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of this.#children) {\n      child.markStale(sourceEvent);\n    }\n    // We schedule sending out events *after* the (synchronous) propagation has happened, in\n    // case one of the listeners updates a source again.\n    this.#scheduleRawDispatch();\n  }\n\n  #rawListeners: Set<() => void> = new Set();\n  /** @deprecated */\n  addRawListener(listener: () => void, options?: { initial: boolean }): void {\n    this.#rawListeners.add(listener);\n    if (options?.initial) {\n      listener(); // TODO: wrap in a try?\n    }\n  }\n\n  /** @deprecated */\n  removeRawListener(listener: () => void): void {\n    this.#rawListeners.delete(listener);\n  }\n\n  /** @deprecated */\n  #scheduleRawDispatch(): void {\n    if (!this.#rawDispatchPending) {\n      this.#rawDispatchPending = true;\n      setTimeout(() => this.#dispatchRawListeners(), 0);\n    }\n  }\n\n  #rawDispatchPending: boolean = false;\n  #dispatchRawListeners(): void {\n    if (!this.#rawDispatchPending) {\n      throw new Error(\"Invalid dispatch state!\");\n    }\n    for (const listener of this.#rawListeners) {\n      listener(); // TODO: wrap in a try?\n    }\n    this.#rawDispatchPending = false;\n  }\n\n  #freshListeners: Map<(value: T) => void, () => void> = new Map();\n  // TODO: Pick a better name.\n  addFreshListener(listener: (value: T) => void): void {\n    const staleDropper: StaleDropper<T> = new StaleDropper<T>();\n    let lastResult: T | null = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    this.#freshListeners.set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n\n  removeFreshListener(listener: (value: T) => void): void {\n    this.removeRawListener(this.#freshListeners.get(listener)!); // TODO: throw a custom error?\n    this.#freshListeners.delete(listener);\n  }\n}\n\nexport abstract class TwistyPropSource<\n  OutputType,\n  InputType = OutputType,\n> extends TwistyPropParent<OutputType> {\n  #value: Promise<OutputType>;\n\n  public abstract getDefaultValue(): PromiseOrValue<OutputType>;\n\n  constructor(initialValue?: PromiseOrValue<InputType>) {\n    super();\n    this.#value = from(() => this.getDefaultValue());\n    if (initialValue) {\n      this.#value = this.deriveFromPromiseOrValue(initialValue, this.#value);\n    }\n  }\n\n  set(input: PromiseOrValue<InputType>): void {\n    this.#value = this.deriveFromPromiseOrValue(input, this.#value);\n\n    const sourceEventDetail: SourceEventDetail<OutputType> = {\n      sourceProp: this,\n      value: this.#value,\n      generation: ++globalSourceGeneration,\n    };\n    this.markStale(\n      new CustomEvent<SourceEventDetail<OutputType>>(\"stale\", {\n        detail: sourceEventDetail,\n      }),\n    );\n  }\n\n  async get(): Promise<OutputType> {\n    return this.#value;\n  }\n\n  async deriveFromPromiseOrValue(\n    input: PromiseOrValue<InputType>,\n    oldValuePromise: Promise<OutputType>,\n  ): Promise<OutputType> {\n    return this.derive(await input, oldValuePromise);\n  }\n\n  // TODO: add an indirect layer to cache the derivation?\n  protected abstract derive(\n    input: InputType,\n    oldValuePromise: Promise<OutputType>,\n  ): PromiseOrValue<OutputType>;\n}\n\nexport abstract class SimpleTwistyPropSource<\n  SimpleType,\n> extends TwistyPropSource<SimpleType> {\n  derive(input: SimpleType): PromiseOrValue<SimpleType> {\n    return input;\n  }\n}\n\n// TODO: Can we support `null` as a valid output value without loosening type\n// safety?\nexport const NO_VALUE = Symbol(\"no value\");\nexport type NoValueType = typeof NO_VALUE;\n\nexport abstract class TwistyPropDerived<\n  InputTypes extends InputRecord,\n  OutputType,\n> extends TwistyPropParent<OutputType> {\n  // cachedInputs:\n  #parents: InputProps<InputTypes>;\n\n  constructor(\n    parents: InputProps<InputTypes>,\n    protected userVisibleErrorTracker?: UserVisibleErrorTracker,\n  ) {\n    super();\n    this.#parents = parents;\n    for (const parent of Object.values(parents)) {\n      (\n        parent as TwistyPropDerived<InputProps<InputTypes>, OutputType>\n      ).addChild(this);\n    }\n  }\n\n  #cachedLastSuccessfulCalculation: {\n    inputs: InputTypes;\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  #cachedLatestGenerationCalculation: {\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  public async get(): Promise<OutputType> {\n    const generation = this.lastSourceGeneration;\n\n    if (this.#cachedLatestGenerationCalculation?.generation === generation) {\n      return this.#cachedLatestGenerationCalculation.output;\n    }\n\n    const latestGenerationCalculation = {\n      generation,\n      output: this.#cacheDerive(\n        this.#getParents(),\n        generation,\n        this.#cachedLastSuccessfulCalculation,\n      ),\n    };\n    this.#cachedLatestGenerationCalculation = latestGenerationCalculation;\n\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n\n  async #getParents(): Promise<InputTypes> {\n    const inputValuePromises: InputPromises<InputRecord> = {} as any; // TODO\n    for (const [key, parent] of Object.entries(this.#parents)) {\n      (inputValuePromises as Record<string, Promise<unknown>>)[key] = (\n        parent as TwistyPropParent<unknown>\n      ).get();\n    }\n\n    const inputs: InputTypes = {} as any; // TODO\n    for (const key in this.#parents) {\n      inputs[key] = (await (\n        inputValuePromises as Record<string, Promise<unknown>>\n      )[key]) as any;\n    }\n    return inputs;\n  }\n\n  async #cacheDerive(\n    inputsPromise: PromiseOrValue<InputTypes>,\n    generation: number,\n    cachedLatestGenerationCalculation: {\n      inputs: InputTypes;\n      output: Promise<OutputType>;\n      generation: number;\n    } | null = null,\n  ): Promise<OutputType> {\n    const inputs = await inputsPromise;\n\n    const cache = (output: OutputType): OutputType => {\n      this.#cachedLastSuccessfulCalculation = {\n        inputs,\n        output: Promise.resolve(output),\n        generation,\n      };\n      return output;\n    };\n\n    if (!cachedLatestGenerationCalculation) {\n      return cache(await this.derive(inputs));\n    }\n\n    const cachedInputs = cachedLatestGenerationCalculation.inputs;\n    for (const key in this.#parents) {\n      const parent = this.#parents[key];\n      if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n        return cache(await this.derive(inputs));\n      }\n    }\n\n    return cachedLatestGenerationCalculation.output;\n  }\n\n  protected abstract derive(input: InputTypes): PromiseOrValue<OutputType>;\n}\n\nexport class FreshListenerManager {\n  #disconnectionFunctions: (() => void)[] = [];\n\n  addListener<T>(\n    prop: TwistyPropParent<T>,\n    listener: (value: T) => void,\n  ): void {\n    let disconnected = false;\n    const wrappedListener = (value: T) => {\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      listener(value);\n    };\n\n    prop.addFreshListener(wrappedListener);\n\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n\n  // TODO: Figure out the signature to let us do overloads\n  /** @deprecated */\n  addMultiListener3<U, V, W>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>, TwistyPropParent<W>],\n    listener: (values: [U, V, W]) => void,\n  ): void {\n    this.addMultiListener(props as any, listener as any); // TODO\n  }\n  addMultiListener<U, V>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>],\n    listener: (values: [U, V]) => void,\n  ) {\n    let disconnected = false;\n\n    // We're going to get one initial call per prop. We'll ignore all but one.\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_: any) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      // We rely on `TwistyProp` caching to give us the full set of latest\n      // values efficiently.\n      const promises = (props as TwistyPropParent<any>[]).map((prop) =>\n        prop.get(),\n      );\n      const values = await Promise.all(promises);\n      listener(values as any); // TODO: fix up types\n    };\n\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n\n    this.#disconnectionFunctions.push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n\n  disconnect(): void {\n    for (const disconnectionFunction of this.#disconnectionFunctions) {\n      disconnectionFunction();\n    }\n  }\n}\n","import { SimpleTwistyPropSource } from \"../../TwistyProp\";\n\n// TODO: turn these maps into lists?\nexport const hintFaceletStyles = {\n  floating: true, // default\n  none: true,\n};\nexport type HintFaceletStyle = keyof typeof hintFaceletStyles;\nexport type HintFaceletStyleWithAuto = HintFaceletStyle | \"auto\";\n\nexport class HintFaceletProp extends SimpleTwistyPropSource<HintFaceletStyleWithAuto> {\n  getDefaultValue(): HintFaceletStyleWithAuto {\n    return \"auto\";\n  }\n}\n","export const TAU = Math.PI * 2;\nexport const DEGREES_PER_RADIAN = 360 / TAU;\n","import { from } from \"../../vendor/p-lazy/p-lazy\";\n\n// TODO can we remove the cached proxy?\n\n// In theory we can, but we've run into situations where imports are not properly cached.\nlet cachedConstructorProxy: Promise<\n  typeof import(\"./dynamic-entries/twisty-dynamic-3d\")\n> | null = null;\n\nexport async function proxy3D(): Promise<\n  typeof import(\"./dynamic-entries/twisty-dynamic-3d\")\n> {\n  return (cachedConstructorProxy ??= import(\n    \"./dynamic-entries/twisty-dynamic-3d\"\n  ));\n}\n\nexport const THREEJS: Promise<typeof import(\"three\")> = from(\n  async () => (await proxy3D()).T3I,\n);\n","// src/cubing/vendor/p-lazy/p-lazy.ts\nvar PLazy = class extends Promise {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n    this._executor = executor;\n  }\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n    return this._promise.then(onFulfilled, onRejected);\n  }\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n    return this._promise.catch(onRejected);\n  }\n};\nfunction from(function_) {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n\nexport {\n  from\n};\n//# sourceMappingURL=chunk-YBDBUTYE.js.map\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n// TODO: Use private class fields when ESLint support it.\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n","var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => {\n  return {\n    set _(value) {\n      __privateSet(obj, member, value, setter);\n    },\n    get _() {\n      return __privateGet(obj, member, getter);\n    }\n  };\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\nexport {\n  __privateGet,\n  __privateAdd,\n  __privateSet,\n  __privateWrapper,\n  __privateMethod\n};\n//# sourceMappingURL=chunk-MGJA5U5O.js.map\n","module.exports = Promise.all([__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"bJecT\")), __parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"hb4G1\"))]).then(() => parcelRequire('6jvmx'));","import {\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet,\n  __privateWrapper\n} from \"./chunk-MGJA5U5O.js\";\n\n// src/cubing/alg/common.ts\nvar writeAlgDebugField = false;\nvar Comparable = class {\n  is(c) {\n    return this instanceof c;\n  }\n  as(c) {\n    return this instanceof c ? this : null;\n  }\n};\nvar AlgCommon = class extends Comparable {\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        }\n      });\n    }\n  }\n  get log() {\n    return console.log.bind(console, this, this.toString());\n  }\n};\n\n// src/cubing/alg/iteration.ts\nfunction toggleDirection(iterationDirection, flip = true) {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case 1 /* Forwards */:\n      return -1 /* Backwards */;\n    case -1 /* Backwards */:\n      return 1 /* Forwards */;\n  }\n}\nfunction direct(g, iterDir) {\n  return iterDir === -1 /* Backwards */ ? Array.from(g).reverse() : g;\n}\nfunction reverse(g) {\n  return Array.from(g).reverse();\n}\nfunction* directedGenerator(g, direction) {\n  direction === -1 /* Backwards */ ? yield* reverseGenerator(g) : yield* g;\n}\nfunction* reverseGenerator(g) {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n\n// src/cubing/alg/limits.ts\nvar MAX_INT = 2147483647;\nvar MAX_INT_DESCRIPTION = \"2^31 - 1\";\nvar MIN_INT = -2147483648;\n\n// src/cubing/alg/AlgBuilder.ts\nvar _units;\nvar AlgBuilder = class {\n  constructor() {\n    __privateAdd(this, _units, []);\n  }\n  push(u) {\n    __privateGet(this, _units).push(u);\n  }\n  experimentalPushAlg(alg) {\n    for (const u of alg.units()) {\n      this.push(u);\n    }\n  }\n  experimentalNumUnits() {\n    return __privateGet(this, _units).length;\n  }\n  toAlg() {\n    return new Alg(__privateGet(this, _units));\n  }\n  reset() {\n    __privateSet(this, _units, []);\n  }\n};\n_units = new WeakMap();\n\n// src/cubing/alg/debug.ts\nvar algDebugGlobals = {\n  caratNISSNotationEnabled: false\n};\nfunction setAlgDebug(options) {\n  if (\"caratNISSNotationEnabled\" in options) {\n    algDebugGlobals.caratNISSNotationEnabled = !!options.caratNISSNotationEnabled;\n  }\n}\n\n// src/cubing/alg/units/containers/Commutator.ts\nvar _A, _B;\nvar _Commutator = class extends AlgCommon {\n  constructor(aSource, bSource) {\n    super();\n    __privateAdd(this, _A, void 0);\n    __privateAdd(this, _B, void 0);\n    __privateSet(this, _A, experimentalEnsureAlg(aSource));\n    __privateSet(this, _B, experimentalEnsureAlg(bSource));\n  }\n  get A() {\n    return __privateGet(this, _A);\n  }\n  get B() {\n    return __privateGet(this, _B);\n  }\n  isIdentical(other) {\n    const otherAsCommutator = other.as(_Commutator);\n    return !!(otherAsCommutator?.A.isIdentical(this.A) && otherAsCommutator?.B.isIdentical(this.B));\n  }\n  invert() {\n    return new _Commutator(__privateGet(this, _B), __privateGet(this, _A));\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {\n    depth ?? (depth = Infinity);\n    if (depth === 0) {\n      yield iterDir === 1 /* Forwards */ ? this : this.invert();\n    } else {\n      if (iterDir === 1 /* Forwards */) {\n        yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);\n        yield* this.B.experimentalExpand(1 /* Forwards */, depth - 1);\n        yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);\n        yield* this.B.experimentalExpand(-1 /* Backwards */, depth - 1);\n      } else {\n        yield* this.B.experimentalExpand(1 /* Forwards */, depth - 1);\n        yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);\n        yield* this.B.experimentalExpand(-1 /* Backwards */, depth - 1);\n        yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);\n      }\n    }\n  }\n  toString() {\n    return `[${__privateGet(this, _A).toString()}, ${__privateGet(this, _B).toString()}]`;\n  }\n};\nvar Commutator = _Commutator;\n_A = new WeakMap();\n_B = new WeakMap();\n\n// src/cubing/alg/units/containers/Conjugate.ts\nvar _A2, _B2;\nvar _Conjugate = class extends AlgCommon {\n  constructor(aSource, bSource) {\n    super();\n    __privateAdd(this, _A2, void 0);\n    __privateAdd(this, _B2, void 0);\n    __privateSet(this, _A2, experimentalEnsureAlg(aSource));\n    __privateSet(this, _B2, experimentalEnsureAlg(bSource));\n  }\n  get A() {\n    return __privateGet(this, _A2);\n  }\n  get B() {\n    return __privateGet(this, _B2);\n  }\n  isIdentical(other) {\n    const otherAsConjugate = other.as(_Conjugate);\n    return !!(otherAsConjugate?.A.isIdentical(this.A) && otherAsConjugate?.B.isIdentical(this.B));\n  }\n  invert() {\n    return new _Conjugate(__privateGet(this, _A2), __privateGet(this, _B2).invert());\n  }\n  *experimentalExpand(iterDir, depth) {\n    depth ?? (depth = Infinity);\n    if (depth === 0) {\n      yield iterDir === 1 /* Forwards */ ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);\n    }\n  }\n  toString() {\n    return `[${this.A}: ${this.B}]`;\n  }\n};\nvar Conjugate = _Conjugate;\n_A2 = new WeakMap();\n_B2 = new WeakMap();\n\n// src/cubing/alg/units/leaves/LineComment.ts\nvar _text;\nvar _LineComment = class extends AlgCommon {\n  constructor(commentText) {\n    super();\n    __privateAdd(this, _text, void 0);\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    __privateSet(this, _text, commentText);\n  }\n  get text() {\n    return __privateGet(this, _text);\n  }\n  isIdentical(other) {\n    const otherAsLineComment = other;\n    return other.is(_LineComment) && __privateGet(this, _text) === __privateGet(otherAsLineComment, _text);\n  }\n  invert() {\n    return this;\n  }\n  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {\n    yield this;\n  }\n  toString() {\n    return `//${__privateGet(this, _text)}`;\n  }\n};\nvar LineComment = _LineComment;\n_text = new WeakMap();\n\n// src/cubing/alg/units/leaves/Newline.ts\nvar Newline = class extends AlgCommon {\n  toString() {\n    return `\n`;\n  }\n  isIdentical(other) {\n    return other.is(Newline);\n  }\n  invert() {\n    return this;\n  }\n  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {\n    yield this;\n  }\n};\n\n// src/cubing/alg/units/leaves/Pause.ts\nvar Pause = class extends AlgCommon {\n  toString() {\n    return `.`;\n  }\n  isIdentical(other) {\n    return other.is(Pause);\n  }\n  invert() {\n    return this;\n  }\n  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {\n    yield this;\n  }\n};\n\n// src/cubing/alg/parse.ts\nfunction parseIntWithEmptyFallback(n, emptyFallback) {\n  return n ? parseInt(n) : emptyFallback;\n}\nvar AMOUNT_REGEX = /^(\\d+)?('?)/;\nvar MOVE_START_REGEX = /^[_\\dA-Za-z]/;\nvar QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nvar COMMENT_TEXT_REGEX = /^[^\\n]*/;\nvar SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/;\nvar SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/;\nfunction parseAlg(s) {\n  return new AlgParser().parseAlg(s);\n}\nfunction parseMove(s) {\n  return new AlgParser().parseMove(s);\n}\nfunction parseQuantumMove(s) {\n  return new AlgParser().parseQuantumMove(s);\n}\nfunction addCharIndices(t, startCharIndex, endCharIndex) {\n  const parsedT = t;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\nfunction transferCharIndex(from, to) {\n  if (\"startCharIndex\" in from) {\n    to.startCharIndex = from.startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    to.endCharIndex = from.endCharIndex;\n  }\n  return to;\n}\nvar _input, _idx, _nissQueue;\nvar AlgParser = class {\n  constructor() {\n    __privateAdd(this, _input, \"\");\n    __privateAdd(this, _idx, 0);\n    __privateAdd(this, _nissQueue, []);\n  }\n  parseAlg(input) {\n    __privateSet(this, _input, input);\n    __privateSet(this, _idx, 0);\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const units = Array.from(alg.units());\n    if (__privateGet(this, _nissQueue).length > 0) {\n      for (const nissGrouping of __privateGet(this, _nissQueue).reverse()) {\n        units.push(nissGrouping);\n      }\n    }\n    return new Alg(units);\n  }\n  parseMove(input) {\n    __privateSet(this, _input, input);\n    __privateSet(this, _idx, 0);\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n  parseQuantumMove(input) {\n    __privateSet(this, _input, input);\n    __privateSet(this, _idx, 0);\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n  mustBeAtEndOfInput() {\n    if (__privateGet(this, _idx) !== __privateGet(this, _input).length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n  parseAlgWithStopping(stopBefore) {\n    let algStartIdx = __privateGet(this, _idx);\n    let algEndIdx = __privateGet(this, _idx);\n    const algBuilder = new AlgBuilder();\n    let crowded = false;\n    const mustNotBeCrowded = (idx) => {\n      if (crowded) {\n        throw new Error(`Unexpected character at index ${idx}. Are you missing a space?`);\n      }\n    };\n    mainLoop:\n      while (__privateGet(this, _idx) < __privateGet(this, _input).length) {\n        const savedCharIndex = __privateGet(this, _idx);\n        if (stopBefore.includes(__privateGet(this, _input)[__privateGet(this, _idx)])) {\n          return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n        }\n        if (this.tryConsumeNext(\" \")) {\n          crowded = false;\n          if (algBuilder.experimentalNumUnits() === 0) {\n            algStartIdx = __privateGet(this, _idx);\n          }\n          continue mainLoop;\n        } else if (MOVE_START_REGEX.test(__privateGet(this, _input)[__privateGet(this, _idx)])) {\n          mustNotBeCrowded(savedCharIndex);\n          const move = this.parseMoveImpl();\n          algBuilder.push(move);\n          crowded = true;\n          algEndIdx = __privateGet(this, _idx);\n          continue mainLoop;\n        } else if (this.tryConsumeNext(\"(\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n          if (sq1PairStartMatch) {\n            const topAmountString = sq1PairStartMatch[1];\n            const savedCharIndexD = __privateGet(this, _idx);\n            const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n            const uMove = addCharIndices(new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)), savedCharIndex + 1, savedCharIndex + 1 + topAmountString.length);\n            const dMove = addCharIndices(new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])), savedCharIndexD, __privateGet(this, _idx) - 1);\n            const alg = addCharIndices(new Alg([uMove, dMove]), savedCharIndex + 1, __privateGet(this, _idx) - 1);\n            algBuilder.push(addCharIndices(new Grouping(alg), savedCharIndex, __privateGet(this, _idx)));\n            crowded = true;\n            algEndIdx = __privateGet(this, _idx);\n            continue mainLoop;\n          } else {\n            const alg = this.parseAlgWithStopping([\")\"]);\n            this.mustConsumeNext(\")\");\n            const amount = this.parseAmount();\n            algBuilder.push(addCharIndices(new Grouping(alg, amount), savedCharIndex, __privateGet(this, _idx)));\n            crowded = true;\n            algEndIdx = __privateGet(this, _idx);\n            continue mainLoop;\n          }\n        } else if (this.tryConsumeNext(\"^\")) {\n          if (!algDebugGlobals.caratNISSNotationEnabled) {\n            throw new Error(\"Alg contained a carat but carat NISS notation is not enabled.\");\n          }\n          this.mustConsumeNext(\"(\");\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.popNext();\n          const grouping = new Grouping(alg, -1);\n          const placeholder = new Pause();\n          grouping.experimentalNISSPlaceholder = placeholder;\n          placeholder.experimentalNISSGrouping = grouping;\n          __privateGet(this, _nissQueue).push(grouping);\n          algBuilder.push(placeholder);\n        } else if (this.tryConsumeNext(\"[\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const A = this.parseAlgWithStopping([\",\", \":\"]);\n          const separator = this.popNext();\n          const B = this.parseAlgWithStopping([\"]\"]);\n          this.mustConsumeNext(\"]\");\n          switch (separator) {\n            case \":\":\n              algBuilder.push(addCharIndices(new Conjugate(A, B), savedCharIndex, __privateGet(this, _idx)));\n              crowded = true;\n              algEndIdx = __privateGet(this, _idx);\n              continue mainLoop;\n            case \",\":\n              algBuilder.push(addCharIndices(new Commutator(A, B), savedCharIndex, __privateGet(this, _idx)));\n              crowded = true;\n              algEndIdx = __privateGet(this, _idx);\n              continue mainLoop;\n            default:\n              throw new Error(\"unexpected parsing error\");\n          }\n        } else if (this.tryConsumeNext(\"\\n\")) {\n          algBuilder.push(addCharIndices(new Newline(), savedCharIndex, __privateGet(this, _idx)));\n          crowded = false;\n          algEndIdx = __privateGet(this, _idx);\n          continue mainLoop;\n        } else if (this.tryConsumeNext(\"/\")) {\n          if (this.tryConsumeNext(\"/\")) {\n            mustNotBeCrowded(savedCharIndex);\n            const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n            algBuilder.push(addCharIndices(new LineComment(text), savedCharIndex, __privateGet(this, _idx)));\n            crowded = false;\n            algEndIdx = __privateGet(this, _idx);\n            continue mainLoop;\n          } else {\n            algBuilder.push(addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, __privateGet(this, _idx)));\n            crowded = true;\n            algEndIdx = __privateGet(this, _idx);\n            continue mainLoop;\n          }\n        } else if (this.tryConsumeNext(\".\")) {\n          mustNotBeCrowded(savedCharIndex);\n          algBuilder.push(addCharIndices(new Pause(), savedCharIndex, __privateGet(this, _idx)));\n          crowded = true;\n          algEndIdx = __privateGet(this, _idx);\n          continue mainLoop;\n        } else {\n          throw new Error(`Unexpected character: ${this.popNext()}`);\n        }\n      }\n    if (__privateGet(this, _idx) !== __privateGet(this, _input).length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n  parseQuantumMoveImpl() {\n    const [, , , outerLayerStr, innerLayerStr, family] = this.parseRegex(QUANTUM_MOVE_REGEX);\n    return new QuantumMove(family, parseIntWithEmptyFallback(innerLayerStr, void 0), parseIntWithEmptyFallback(outerLayerStr, void 0));\n  }\n  parseMoveImpl() {\n    const savedCharIndex = __privateGet(this, _idx);\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, __privateGet(this, _idx));\n    }\n    let quantumMove = this.parseQuantumMoveImpl();\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        throw new Error(\"Pochmann ++ or -- moves cannot have an amount other than 1.\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\"Pochmann ++ or -- moves cannot have an amount written as a number.\");\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\"Clock dial moves must have an amount written as a natural number followed by + or -.\");\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"}_`\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"}_`\n        });\n        amount *= -1;\n      }\n    }\n    const move = addCharIndices(new Move(quantumMove, amount), savedCharIndex, __privateGet(this, _idx));\n    return move;\n  }\n  parseMoveSuffix() {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n  parseAmountAndTrackEmptyAbsAmount() {\n    const savedIdx = __privateGet(this, _idx);\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(`Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`);\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr\n    ];\n  }\n  parseAmount() {\n    const savedIdx = __privateGet(this, _idx);\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(`Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`);\n    }\n    return parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1);\n  }\n  parseRegex(regex) {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\");\n    }\n    __privateSet(this, _idx, __privateGet(this, _idx) + arr[0].length);\n    return arr;\n  }\n  tryRegex(regex) {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    __privateSet(this, _idx, __privateGet(this, _idx) + arr[0].length);\n    return arr;\n  }\n  remaining() {\n    return __privateGet(this, _input).slice(__privateGet(this, _idx));\n  }\n  popNext() {\n    const next = __privateGet(this, _input)[__privateGet(this, _idx)];\n    __privateWrapper(this, _idx)._++;\n    return next;\n  }\n  tryConsumeNext(expected) {\n    if (__privateGet(this, _input)[__privateGet(this, _idx)] === expected) {\n      __privateWrapper(this, _idx)._++;\n      return true;\n    }\n    return false;\n  }\n  mustConsumeNext(expected) {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(`expected \\`${expected}\\` while parsing, encountered ${next}`);\n    }\n    return next;\n  }\n};\n_input = new WeakMap();\n_idx = new WeakMap();\n_nissQueue = new WeakMap();\n\n// src/cubing/alg/warnOnce.ts\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(s) {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n\n// src/cubing/alg/units/QuantumWithAmount.ts\nvar QuantumWithAmount = class {\n  constructor(quantum, amount = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n    if (!Number.isInteger(this.amount) || this.amount < MIN_INT || this.amount > MAX_INT) {\n      throw new Error(`Unit amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`);\n    }\n  }\n  suffix() {\n    let s = \"\";\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n  isIdentical(other) {\n    return this.quantum.isIdentical(other.quantum) && this.amount === other.amount;\n  }\n  *experimentalExpand(iterDir, depth) {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n};\n\n// src/cubing/alg/units/leaves/Move.ts\nvar _family, _innerLayer, _outerLayer;\nvar _QuantumMove = class extends Comparable {\n  constructor(family, innerLayer, outerLayer) {\n    super();\n    __privateAdd(this, _family, void 0);\n    __privateAdd(this, _innerLayer, void 0);\n    __privateAdd(this, _outerLayer, void 0);\n    __privateSet(this, _family, family);\n    __privateSet(this, _innerLayer, innerLayer ?? null);\n    __privateSet(this, _outerLayer, outerLayer ?? null);\n    Object.freeze(this);\n    if (__privateGet(this, _innerLayer) !== null && (!Number.isInteger(__privateGet(this, _innerLayer)) || __privateGet(this, _innerLayer) < 1 || __privateGet(this, _innerLayer) > MAX_INT)) {\n      throw new Error(`QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`);\n    }\n    if (__privateGet(this, _outerLayer) !== null && (!Number.isInteger(__privateGet(this, _outerLayer)) || __privateGet(this, _outerLayer) < 1 || __privateGet(this, _outerLayer) > MAX_INT)) {\n      throw new Error(`QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`);\n    }\n    if (__privateGet(this, _outerLayer) !== null && __privateGet(this, _innerLayer) !== null && __privateGet(this, _innerLayer) <= __privateGet(this, _outerLayer)) {\n      throw new Error(\"QuantumMove outer layer must be smaller than inner layer.\");\n    }\n    if (__privateGet(this, _outerLayer) !== null && __privateGet(this, _innerLayer) === null) {\n      throw new Error(\"QuantumMove with an outer layer must have an inner layer\");\n    }\n  }\n  static fromString(s) {\n    return parseQuantumMove(s);\n  }\n  modified(modifications) {\n    return new _QuantumMove(modifications.family ?? __privateGet(this, _family), modifications.innerLayer ?? __privateGet(this, _innerLayer), modifications.outerLayer ?? __privateGet(this, _outerLayer));\n  }\n  isIdentical(other) {\n    const otherAsQuantumMove = other;\n    return other.is(_QuantumMove) && __privateGet(this, _family) === __privateGet(otherAsQuantumMove, _family) && __privateGet(this, _innerLayer) === __privateGet(otherAsQuantumMove, _innerLayer) && __privateGet(this, _outerLayer) === __privateGet(otherAsQuantumMove, _outerLayer);\n  }\n  get family() {\n    return __privateGet(this, _family);\n  }\n  get outerLayer() {\n    return __privateGet(this, _outerLayer);\n  }\n  get innerLayer() {\n    return __privateGet(this, _innerLayer);\n  }\n  experimentalExpand() {\n    throw new Error(\"experimentalExpand() cannot be called on a `QuantumMove` directly.\");\n  }\n  toString() {\n    let s = __privateGet(this, _family);\n    if (__privateGet(this, _innerLayer) !== null) {\n      s = String(__privateGet(this, _innerLayer)) + s;\n      if (__privateGet(this, _outerLayer) !== null) {\n        s = String(__privateGet(this, _outerLayer)) + \"-\" + s;\n      }\n    }\n    return s;\n  }\n};\nvar QuantumMove = _QuantumMove;\n_family = new WeakMap();\n_innerLayer = new WeakMap();\n_outerLayer = new WeakMap();\nvar _quantumWithAmount;\nvar _Move = class extends AlgCommon {\n  constructor(...args) {\n    super();\n    __privateAdd(this, _quantumWithAmount, void 0);\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        __privateSet(this, _quantumWithAmount, new QuantumWithAmount(QuantumMove.fromString(args[0]), args[1]));\n        return;\n      } else {\n        return _Move.fromString(args[0]);\n      }\n    }\n    __privateSet(this, _quantumWithAmount, new QuantumWithAmount(args[0], args[1]));\n  }\n  isIdentical(other) {\n    const otherAsMove = other.as(_Move);\n    return !!otherAsMove && __privateGet(this, _quantumWithAmount).isIdentical(__privateGet(otherAsMove, _quantumWithAmount));\n  }\n  invert() {\n    return transferCharIndex(this, new _Move(__privateGet(this, _quantumWithAmount).quantum, -this.amount));\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */) {\n    if (iterDir === 1 /* Forwards */) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount\n      });\n    }\n  }\n  get quantum() {\n    return __privateGet(this, _quantumWithAmount).quantum;\n  }\n  modified(modifications) {\n    return new _Move(__privateGet(this, _quantumWithAmount).quantum.modified(modifications), modifications.amount ?? this.amount);\n  }\n  static fromString(s) {\n    return parseMove(s);\n  }\n  get amount() {\n    return __privateGet(this, _quantumWithAmount).amount;\n  }\n  get type() {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n  get family() {\n    return __privateGet(this, _quantumWithAmount).quantum.family ?? void 0;\n  }\n  get outerLayer() {\n    return __privateGet(this, _quantumWithAmount).quantum.outerLayer ?? void 0;\n  }\n  get innerLayer() {\n    return __privateGet(this, _quantumWithAmount).quantum.innerLayer ?? void 0;\n  }\n  toString() {\n    if (this.family === \"_SLASH_\") {\n      return \"/\";\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return __privateGet(this, _quantumWithAmount).quantum.toString().slice(0, -6) + Math.abs(this.amount) + (this.amount < 0 ? \"-\" : \"+\");\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return __privateGet(this, _quantumWithAmount).quantum.toString().slice(0, -10) + (absAmount === 1 ? \"\" : absAmount) + (this.amount < 0 ? \"--\" : \"++\");\n    }\n    return __privateGet(this, _quantumWithAmount).quantum.toString() + __privateGet(this, _quantumWithAmount).suffix();\n  }\n};\nvar Move = _Move;\n_quantumWithAmount = new WeakMap();\n\n// src/cubing/alg/units/containers/Grouping.ts\nvar Square1TupleFormatter = class {\n  constructor() {\n    this.quantumU_SQ_ = null;\n    this.quantumD_SQ_ = null;\n  }\n  format(grouping) {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n  tuple(grouping) {\n    this.quantumU_SQ_ || (this.quantumU_SQ_ = new QuantumMove(\"U_SQ_\"));\n    this.quantumD_SQ_ || (this.quantumD_SQ_ = new QuantumMove(\"D_SQ_\"));\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumUnits() === 2) {\n      const [U, D] = quantumAlg.units();\n      if (U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) && D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)) {\n        if (grouping.amount !== 1) {\n          throw new Error(\"Square-1 tuples cannot have an amount other than 1.\");\n        }\n        return [U, D];\n      }\n    }\n    return null;\n  }\n};\nvar square1TupleFormatterInstance = new Square1TupleFormatter();\nvar _quantumWithAmount2;\nvar _Grouping = class extends AlgCommon {\n  constructor(algSource, amount) {\n    super();\n    __privateAdd(this, _quantumWithAmount2, void 0);\n    const alg = experimentalEnsureAlg(algSource);\n    __privateSet(this, _quantumWithAmount2, new QuantumWithAmount(alg, amount));\n  }\n  isIdentical(other) {\n    const otherAsGrouping = other;\n    return other.is(_Grouping) && __privateGet(this, _quantumWithAmount2).isIdentical(__privateGet(otherAsGrouping, _quantumWithAmount2));\n  }\n  get alg() {\n    return __privateGet(this, _quantumWithAmount2).quantum;\n  }\n  get amount() {\n    return __privateGet(this, _quantumWithAmount2).amount;\n  }\n  get experimentalRepetitionSuffix() {\n    return __privateGet(this, _quantumWithAmount2).suffix();\n  }\n  invert() {\n    return new _Grouping(__privateGet(this, _quantumWithAmount2).quantum, -__privateGet(this, _quantumWithAmount2).amount);\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {\n    depth ?? (depth = Infinity);\n    if (depth === 0) {\n      yield iterDir === 1 /* Forwards */ ? this : this.invert();\n    } else {\n      yield* __privateGet(this, _quantumWithAmount2).experimentalExpand(iterDir, depth - 1);\n    }\n  }\n  static fromString() {\n    throw new Error(\"unimplemented\");\n  }\n  toString() {\n    return square1TupleFormatterInstance.format(this) ?? `(${__privateGet(this, _quantumWithAmount2).quantum.toString()})${__privateGet(this, _quantumWithAmount2).suffix()}`;\n  }\n  experimentalAsSquare1Tuple() {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n};\nvar Grouping = _Grouping;\n_quantumWithAmount2 = new WeakMap();\n\n// src/cubing/alg/is.ts\nfunction experimentalIs(v, c) {\n  return v instanceof c;\n}\nfunction experimentalIsUnit(v) {\n  return experimentalIs(v, Grouping) || experimentalIs(v, LineComment) || experimentalIs(v, Commutator) || experimentalIs(v, Conjugate) || experimentalIs(v, Move) || experimentalIs(v, Newline) || experimentalIs(v, Pause);\n}\n\n// src/cubing/alg/traversal.ts\nfunction dispatch(t, unit, dataDown) {\n  if (unit.is(Grouping)) {\n    return t.traverseGrouping(unit, dataDown);\n  }\n  if (unit.is(Move)) {\n    return t.traverseMove(unit, dataDown);\n  }\n  if (unit.is(Commutator)) {\n    return t.traverseCommutator(unit, dataDown);\n  }\n  if (unit.is(Conjugate)) {\n    return t.traverseConjugate(unit, dataDown);\n  }\n  if (unit.is(Pause)) {\n    return t.traversePause(unit, dataDown);\n  }\n  if (unit.is(Newline)) {\n    return t.traverseNewline(unit, dataDown);\n  }\n  if (unit.is(LineComment)) {\n    return t.traverseLineComment(unit, dataDown);\n  }\n  throw new Error(`unknown unit`);\n}\nfunction assertIsUnit(t) {\n  if (t.is(Grouping) || t.is(Move) || t.is(Commutator) || t.is(Conjugate) || t.is(Pause) || t.is(Newline) || t.is(LineComment)) {\n    return t;\n  }\n  throw new Error(\"internal error: expected unit\");\n}\nvar TraversalDownUp = class {\n  traverseUnit(unit, dataDown) {\n    return dispatch(this, unit, dataDown);\n  }\n  traverseIntoUnit(unit, dataDown) {\n    return assertIsUnit(this.traverseUnit(unit, dataDown));\n  }\n};\nvar TraversalUp = class extends TraversalDownUp {\n  traverseUnit(unit) {\n    return dispatch(this, unit, void 0);\n  }\n  traverseIntoUnit(unit) {\n    return assertIsUnit(this.traverseUnit(unit));\n  }\n};\nvar _newPlaceholderAssociationsMap, _newPlaceholderAssociations, newPlaceholderAssociations_fn, _newAmount, newAmount_fn;\nvar _Simplify = class extends TraversalDownUp {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _newPlaceholderAssociations);\n    __privateAdd(this, _newPlaceholderAssociationsMap, void 0);\n  }\n  *traverseAlg(alg, options) {\n    if (options.depth === 0) {\n      yield* alg.units();\n      return;\n    }\n    const newUnits = [];\n    let lastUnit = null;\n    const collapseMoves = options?.collapseMoves ?? true;\n    function appendMoveWithNewAmount(move, deltaAmount) {\n      var _a;\n      const newAmount = __privateMethod(_a = _Simplify, _newAmount, newAmount_fn).call(_a, move, deltaAmount, options);\n      if (newAmount === 0) {\n        return false;\n      }\n      const newMove = new Move(move.quantum, newAmount);\n      newUnits.push(newMove);\n      lastUnit = newMove;\n      return true;\n    }\n    function appendCollapsed(newUnit) {\n      if (collapseMoves && lastUnit?.is(Move) && newUnit.is(Move) && lastUnit.quantum.isIdentical(newUnit.quantum)) {\n        newUnits.pop();\n        if (!appendMoveWithNewAmount(lastUnit, newUnit.amount)) {\n          lastUnit = newUnits.slice(-1)[0];\n        }\n      } else {\n        if (newUnit.is(Move)) {\n          appendMoveWithNewAmount(newUnit, 0);\n        } else {\n          newUnits.push(newUnit);\n          lastUnit = newUnit;\n        }\n      }\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null\n    };\n    for (const unit of alg.units()) {\n      for (const ancestorUnit of this.traverseUnit(unit, newOptions)) {\n        appendCollapsed(ancestorUnit);\n      }\n    }\n    for (const unit of newUnits) {\n      yield unit;\n    }\n  }\n  *traverseGrouping(grouping, options) {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null\n    };\n    const newGrouping = new Grouping(this.traverseAlg(grouping.alg, newOptions), grouping.amount);\n    const newPlaceholder = __privateMethod(this, _newPlaceholderAssociations, newPlaceholderAssociations_fn).call(this).get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n    yield newGrouping;\n  }\n  *traverseMove(move, _options) {\n    yield move;\n  }\n  *traverseCommutator(commutator, options) {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null\n    };\n    yield new Commutator(this.traverseAlg(commutator.A, newOptions), this.traverseAlg(commutator.B, newOptions));\n  }\n  *traverseConjugate(conjugate, options) {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null\n    };\n    yield new Conjugate(this.traverseAlg(conjugate.A, newOptions), this.traverseAlg(conjugate.B, newOptions));\n  }\n  *traversePause(pause, _options) {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      __privateMethod(this, _newPlaceholderAssociations, newPlaceholderAssociations_fn).call(this).set(pause.experimentalNISSGrouping, newPause);\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n  *traverseNewline(newline, _options) {\n    yield newline;\n  }\n  *traverseLineComment(comment, _options) {\n    yield comment;\n  }\n};\nvar Simplify = _Simplify;\n_newPlaceholderAssociationsMap = new WeakMap();\n_newPlaceholderAssociations = new WeakSet();\nnewPlaceholderAssociations_fn = function() {\n  return __privateGet(this, _newPlaceholderAssociationsMap) ?? __privateSet(this, _newPlaceholderAssociationsMap, /* @__PURE__ */ new Map());\n};\n_newAmount = new WeakSet();\nnewAmount_fn = function(move, deltaAmount, options) {\n  let newAmount = move.amount + deltaAmount;\n  if (options?.quantumMoveOrder) {\n    const order = options.quantumMoveOrder(move.quantum);\n    const min = Math.floor(order / 2) + 1 - order;\n    newAmount = (newAmount % order + order - min) % order + min;\n  }\n  return newAmount;\n};\n__privateAdd(Simplify, _newAmount);\nvar simplifyInstance = new Simplify();\nvar simplify = simplifyInstance.traverseAlg.bind(simplifyInstance);\n\n// src/cubing/alg/Alg.ts\nfunction toIterable(input) {\n  if (!input) {\n    return [];\n  }\n  if (experimentalIs(input, Alg)) {\n    return input.units();\n  }\n  if (typeof input === \"string\") {\n    return parseAlg(input).units();\n  }\n  const iter = input;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter;\n  }\n  throw new Error(\"Invalid unit\");\n}\nfunction experimentalEnsureAlg(alg) {\n  if (experimentalIs(alg, Alg)) {\n    return alg;\n  }\n  return new Alg(alg);\n}\nvar _units2;\nvar _Alg = class extends AlgCommon {\n  constructor(alg) {\n    super();\n    __privateAdd(this, _units2, void 0);\n    __privateSet(this, _units2, Array.from(toIterable(alg)));\n    for (const unit of __privateGet(this, _units2)) {\n      if (!experimentalIsUnit(unit)) {\n        throw new Error(\"An alg can only contain units.\");\n      }\n    }\n  }\n  isIdentical(other) {\n    const otherAsAlg = other;\n    if (!other.is(_Alg)) {\n      return false;\n    }\n    const l1 = Array.from(__privateGet(this, _units2));\n    const l2 = Array.from(__privateGet(otherAsAlg, _units2));\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invert() {\n    return new _Alg(reverse(Array.from(__privateGet(this, _units2)).map((u) => u.invert())));\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {\n    depth ?? (depth = Infinity);\n    for (const unit of direct(__privateGet(this, _units2), iterDir)) {\n      yield* unit.experimentalExpand(iterDir, depth);\n    }\n  }\n  expand(options) {\n    return new _Alg(this.experimentalExpand(1 /* Forwards */, options?.depth ?? Infinity));\n  }\n  *experimentalLeafMoves() {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf;\n      }\n    }\n  }\n  concat(input) {\n    return new _Alg(Array.from(__privateGet(this, _units2)).concat(Array.from(toIterable(input))));\n  }\n  experimentalIsEmpty() {\n    for (const _ of __privateGet(this, _units2)) {\n      return false;\n    }\n    return true;\n  }\n  static fromString(s) {\n    return parseAlg(s);\n  }\n  *units() {\n    for (const unit of __privateGet(this, _units2)) {\n      yield unit;\n    }\n  }\n  experimentalNumUnits() {\n    return Array.from(__privateGet(this, _units2)).length;\n  }\n  get type() {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n  toString() {\n    let output = \"\";\n    let previousVisibleUnit = null;\n    for (const unit of __privateGet(this, _units2)) {\n      if (previousVisibleUnit) {\n        output += spaceBetween(previousVisibleUnit, unit);\n      }\n      const nissGrouping = unit.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString()})`;\n      } else if (unit.as(Grouping)?.experimentalNISSPlaceholder) {\n      } else {\n        output += unit.toString();\n      }\n      previousVisibleUnit = unit;\n    }\n    return output;\n  }\n  simplify(options) {\n    return new _Alg(simplify(this, options ?? {}));\n  }\n};\nvar Alg = _Alg;\n_units2 = new WeakMap();\nfunction spaceBetween(u1, u2) {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\";\n  }\n  return \" \";\n}\n\n// src/cubing/alg/example.ts\nvar Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1)\n  ]),\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1)\n  ]),\n  SuneCommutator: new Alg([\n    new Commutator(new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]), new Alg([\n      new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)]))\n    ]))\n  ]),\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1)\n  ]),\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(new Alg([\n      new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", -1)]))\n    ]), new Alg([new Move(\"D\", 1)])),\n    new Commutator(new Alg([\n      new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)]))\n    ]), new Alg([new Move(\"D\", 1)])),\n    new Move(\"x\", 1)\n  ]),\n  FURURFCompact: new Alg([\n    new Conjugate(new Alg([new Move(\"F\", 1)]), new Alg([\n      new Commutator(new Alg([new Move(\"U\", 1)]), new Alg([new Move(\"R\", 1)]))\n    ]))\n  ]),\n  APermCompact: new Alg([\n    new Conjugate(new Alg([new Move(\"R\", 2)]), new Alg([\n      new Commutator(new Alg([new Move(\"F\", 2)]), new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]))\n    ]))\n  ]),\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1)\n  ]),\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1)\n  ]),\n  HeadlightSwaps: new Alg([\n    new Conjugate(new Alg([new Move(\"F\", 1)]), new Alg([\n      new Grouping(new Alg([\n        new Commutator(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)]))\n      ]), 3)\n    ]))\n  ]),\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()])\n};\n\n// src/cubing/alg/keyboard.ts\nvar cubeKeyMapping = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"),\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\")\n};\nfunction keyToMove(e) {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n  return cubeKeyMapping[e.keyCode] || null;\n}\n\n// src/cubing/alg/url.ts\nfunction serializeURLParam(a) {\n  let escaped = a.toString();\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\nfunction algCubingNetLink(options) {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error(\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if (![\n      \"1x1x1\",\n      \"2x2x2\",\n      \"3x3x3\",\n      \"4x4x4\",\n      \"5x5x5\",\n      \"6x6x6\",\n      \"7x7x7\",\n      \"8x8x8\",\n      \"9x9x9\",\n      \"10x10x10\",\n      \"11x11x11\",\n      \"12x12x12\",\n      \"13x13x13\",\n      \"14x14x14\",\n      \"16x16x16\",\n      \"17x17x17\"\n    ].includes(options.puzzle)) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if (![\n      \"full\",\n      \"cross\",\n      \"F2L\",\n      \"LL\",\n      \"OLL\",\n      \"PLL\",\n      \"CLS\",\n      \"ELS\",\n      \"L6E\",\n      \"CMLL\",\n      \"WV\",\n      \"ZBLL\",\n      \"void\"\n    ].includes(options.stage)) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if (![\"editor\", \"playback\", \"fullscreen\"].includes(options.view)) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if (![\n      \"moves\",\n      \"reconstruction\",\n      \"alg\",\n      \"reconstruction-end-with-setup\"\n    ].includes(options.type)) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n\n// src/cubing/alg/operation.ts\nfunction experimentalAppendMove(alg, newMove, options) {\n  const oldUnits = Array.from(alg.units());\n  const oldLastMove = oldUnits[oldUnits.length - 1];\n  if (options?.coalesce && oldLastMove && oldLastMove.quantum && oldLastMove.quantum.isIdentical(newMove.quantum)) {\n    const newUnits = oldUnits.slice(0, oldUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    const mod = options?.mod;\n    if (mod) {\n      newAmount = (newAmount % mod + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newUnits.push(oldLastMove.modified({ amount: newAmount }));\n    }\n    return new Alg(newUnits);\n  } else {\n    return new Alg([...oldUnits, newMove]);\n  }\n}\n\nexport {\n  direct,\n  directedGenerator,\n  AlgBuilder,\n  setAlgDebug,\n  Commutator,\n  Conjugate,\n  LineComment,\n  Newline,\n  Pause,\n  QuantumMove,\n  Move,\n  Grouping,\n  experimentalIs,\n  TraversalDownUp,\n  TraversalUp,\n  Alg,\n  Example,\n  keyToMove,\n  algCubingNetLink,\n  experimentalAppendMove\n};\n//# sourceMappingURL=chunk-NQORDEXF.js.map\n","import type { Alg } from \"./Alg\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { LeafUnit, Unit } from \"./units/Unit\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<LeafUnit>;\n}\n\n// Common to algs or units\nexport abstract class AlgCommon<T extends Alg | Unit>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract toString(): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(iterDir: IterationDirection): Generator<LeafUnit>;\n}\n","export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n","export const MAX_INT = 0x7fffffff; // 2^31-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MIN_INT_DESCRIPTION = \"-2^31\";\n","import { Alg } from \"./Alg\";\nimport type { Unit } from \"./units/Unit\";\n\n/** @category Alg */\nexport class AlgBuilder {\n  #units: Unit[] = [];\n\n  push(u: Unit): void {\n    this.#units.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.units()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumUnits(): number {\n    return this.#units.length;\n  }\n\n  // can be called multiple times, even if you push units inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#units);\n  }\n\n  reset(): void {\n    this.#units = [];\n  }\n}\n","type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\":\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(\n  level: ReportingLevel,\n): void {\n  currentReportingLevel = level;\n}\n\nexport const algDebugGlobals: { caratNISSNotationEnabled: boolean } = {\n  caratNISSNotationEnabled: false,\n};\n\nexport function setAlgDebug(options: {\n  caratNISSNotationEnabled?: boolean;\n}): void {\n  if (\"caratNISSNotationEnabled\" in options) {\n    algDebugGlobals.caratNISSNotationEnabled =\n      !!options.caratNISSNotationEnabled;\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n/** @category Alg Units */\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(): string {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n/** @category Alg Units */\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(): string {\n    return `[${this.A}: ${this.B}]`;\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\n/** @category Alg Units */\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n\n  toString(): string {\n    return `//${this.#text}`;\n  }\n\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n/** @category Alg Units */\nexport class Newline extends AlgCommon<Newline> {\n  toString(): string {\n    return `\\n`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n}\n","import type { Grouping } from \"..\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n/** @category Alg Units */\nexport class Pause extends AlgCommon<Pause> {\n  experimentalNISSGrouping?: Grouping; // TODO: tie this to the alg\n\n  toString(): string {\n    return `.`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n}\n","import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport { algDebugGlobals } from \"./debug\";\nimport type { Unit } from \"./units\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { Grouping } from \"./units/containers/Grouping\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport { Pause } from \"./units/leaves/Pause\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst AMOUNT_REGEX = /^(\\d+)?('?)/;\nconst MOVE_START_REGEX = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nconst COMMENT_TEXT_REGEX = /^[^\\n]*/;\nconst SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport interface ParserIndexed {\n  startCharIndex: number;\n  endCharIndex: number;\n}\n\nexport type Parsed<T extends Alg | Unit> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | Unit>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | Unit>(from: T, to: T): T {\n  if (\"startCharIndex\" in from) {\n    (to as Parsed<T>).startCharIndex = (from as Parsed<T>).startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    (to as Parsed<T>).endCharIndex = (from as Parsed<T>).endCharIndex;\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n  #nissQueue: Grouping[] = [];\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const units = Array.from(alg.units());\n    if (this.#nissQueue.length > 0) {\n      for (const nissGrouping of this.#nissQueue.reverse()) {\n        units.push(nissGrouping);\n      }\n    }\n    return new Alg(units) as Parsed<Alg>;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last unit.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    mainLoop: while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumUnits() === 0) {\n          algStartIdx = this.#idx;\n        }\n        continue mainLoop;\n      } else if (MOVE_START_REGEX.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\"^\")) {\n        if (!algDebugGlobals.caratNISSNotationEnabled) {\n          throw new Error(\n            \"Alg contained a carat but carat NISS notation is not enabled.\",\n          );\n        }\n\n        this.mustConsumeNext(\"(\");\n        const alg = this.parseAlgWithStopping([\")\"]);\n        this.popNext();\n\n        const grouping = new Grouping(alg, -1);\n        const placeholder = new Pause();\n\n        grouping.experimentalNISSPlaceholder = placeholder;\n        placeholder.experimentalNISSGrouping = grouping;\n\n        this.#nissQueue.push(grouping);\n        algBuilder.push(placeholder);\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        switch (separator) {\n          case \":\":\n            algBuilder.push(\n              addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          case \",\":\n            algBuilder.push(\n              addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          default:\n            throw new Error(\"unexpected parsing error\");\n        }\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(QUANTUM_MOVE_REGEX);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    // eslint-disable-next-line prefer-const\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n","const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n","import type { Repeatable } from \"../common\";\nimport { IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { LeafUnit } from \"./Unit\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `Unit amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<LeafUnit> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parse\";\nimport { warnOnce } from \"../../warnOnce\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { LeafUnit } from \"../Unit\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<LeafUnit> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  toString(): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = String(this.#outerLayer) + \"-\" + s;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\n/** @category Alg Units */\nexport class Move extends AlgCommon<Move> {\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        return Move.fromString(args[0]); // TODO: can we return here?\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among units.\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<LeafUnit> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  toString(): string {\n    if (this.family === \"_SLASH_\") {\n      return \"/\"; // TODO: validate no amount\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n        Math.abs(this.amount) +\n        (this.amount < 0 ? \"-\" : \"+\")\n      ); // TODO\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n        (absAmount === 1 ? \"\" : absAmount) +\n        (this.amount < 0 ? \"--\" : \"++\")\n      ); // TODO\n    }\n\n    return (\n      this.#quantumWithAmount.quantum.toString() +\n      this.#quantumWithAmount.suffix()\n    );\n  }\n\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport type { Pause } from \"../leaves/Pause\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { LeafUnit } from \"../Unit\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(grouping: Grouping): string | null {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumUnits() === 2) {\n      const [U, D] = quantumAlg.units();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\",\n          );\n        }\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\n/** @category Alg Units */\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n  experimentalNISSPlaceholder?: Pause; // TODO: tie this to the alg\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  toString(): string {\n    return (\n      square1TupleFormatterInstance.format(this) ??\n      `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n","import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./units\";\n\nexport function experimentalIs(\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function experimentalIsUnit(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n","import type { Alg } from \"./Alg\";\nimport { Grouping } from \"./units/containers/Grouping\";\nimport type { Comparable } from \"./common\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Move, QuantumMove } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport { Pause } from \"./units/leaves/Pause\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport type { Unit } from \"./units/Unit\";\n\nfunction dispatch<DataDown, DataAlgUp, DataUnitUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataUnitUp>,\n  unit: Unit,\n  dataDown: DataDown,\n): DataUnitUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (unit.is(Grouping)) {\n    return t.traverseGrouping(unit as Grouping, dataDown);\n  }\n  if (unit.is(Move)) {\n    return t.traverseMove(unit as Move, dataDown);\n  }\n  if (unit.is(Commutator)) {\n    return t.traverseCommutator(unit as Commutator, dataDown);\n  }\n  if (unit.is(Conjugate)) {\n    return t.traverseConjugate(unit as Conjugate, dataDown);\n  }\n  if (unit.is(Pause)) {\n    return t.traversePause(unit as Pause, dataDown);\n  }\n  if (unit.is(Newline)) {\n    return t.traverseNewline(unit as Newline, dataDown);\n  }\n  if (unit.is(LineComment)) {\n    return t.traverseLineComment(unit as LineComment, dataDown);\n  }\n  throw new Error(`unknown unit`);\n}\n\nfunction assertIsUnit(t: Comparable): Unit {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as Unit;\n  }\n  throw new Error(\"internal error: expected unit\"); // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataUnitUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseUnit(unit: Unit, dataDown: DataDown): DataUnitUp {\n    return dispatch(this, unit, dataDown);\n  }\n\n  public traverseIntoUnit(unit: Unit, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverseUnit(unit, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataUnitUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUnitUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataUnitUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataUnitUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataUnitUp> {\n  public traverseUnit(unit: Unit): DataUnitUp {\n    return dispatch<unknown, DataAlgUp, DataUnitUp>(this, unit, undefined);\n  }\n\n  public traverseIntoUnit(unit: Unit): Unit {\n    return assertIsUnit(this.traverseUnit(unit) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg): DataAlgUp;\n  public abstract traverseGrouping(grouping: Grouping): DataUnitUp;\n  public abstract traverseMove(move: Move): DataUnitUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUnitUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUnitUp;\n  public abstract traversePause(pause: Pause): DataUnitUp;\n  public abstract traverseNewline(newline: Newline): DataUnitUp;\n  public abstract traverseLineComment(comment: LineComment): DataUnitUp;\n}\n\nexport interface SimplifyOptions {\n  collapseMoves?: boolean;\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  depth?: number | null; // TODO: test\n}\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<Unit>> {\n  #newPlaceholderAssociationsMap?: Map<Grouping, Pause>;\n  #newPlaceholderAssociations(): Map<Grouping, Pause> {\n    return (this.#newPlaceholderAssociationsMap ??= new Map<Grouping, Pause>());\n  }\n\n  static #newAmount(\n    move: Move,\n    deltaAmount: number,\n    options: SimplifyOptions,\n  ): number {\n    let newAmount = move.amount + deltaAmount;\n    if (options?.quantumMoveOrder) {\n      const order = options.quantumMoveOrder(move.quantum);\n      // Examples:\n      //  order 4  min -1 (e.g. cube)\n      //  order 5  min -2 (e.g. Megaminx)\n      //  order 3  min -1 (e.g. Pyraminx)\n      const min = Math.floor(order / 2) + 1 - order;\n      newAmount = (((newAmount % order) + order - min) % order) + min; // TODO\n    }\n    return newAmount;\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<Unit> {\n    if (options.depth === 0) {\n      yield* alg.units();\n      return;\n    }\n\n    const newUnits: Unit[] = [];\n    let lastUnit: Unit | null = null;\n    const collapseMoves = options?.collapseMoves ?? true;\n    function appendMoveWithNewAmount(move: Move, deltaAmount: number): boolean {\n      const newAmount = Simplify.#newAmount(move, deltaAmount, options);\n      if (newAmount === 0) {\n        return false;\n      }\n      const newMove = new Move(move.quantum, newAmount);\n      newUnits.push(newMove);\n      lastUnit = newMove;\n      return true;\n    }\n    function appendCollapsed(newUnit: Unit) {\n      if (\n        collapseMoves &&\n        lastUnit?.is(Move) &&\n        newUnit.is(Move) &&\n        (lastUnit as Move).quantum.isIdentical((newUnit as Move).quantum)\n      ) {\n        newUnits.pop();\n        if (\n          !appendMoveWithNewAmount(lastUnit as Move, (newUnit as Move).amount)\n        ) {\n          lastUnit = newUnits.slice(-1)[0];\n        }\n      } else {\n        if (newUnit.is(Move)) {\n          appendMoveWithNewAmount(newUnit as Move, 0);\n        } else {\n          newUnits.push(newUnit);\n          lastUnit = newUnit;\n        }\n      }\n    }\n\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    for (const unit of alg.units()) {\n      for (const ancestorUnit of this.traverseUnit(unit, newOptions)) {\n        appendCollapsed(ancestorUnit);\n      }\n    }\n    for (const unit of newUnits) {\n      yield unit;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    const newGrouping = new Grouping(\n      this.traverseAlg(grouping.alg, newOptions),\n      grouping.amount,\n    );\n\n    const newPlaceholder = this.#newPlaceholderAssociations().get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n\n    yield newGrouping;\n  }\n\n  public *traverseMove(move: Move, _options: SimplifyOptions): Generator<Unit> {\n    yield move;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      this.#newPlaceholderAssociations().set(\n        pause.experimentalNISSGrouping,\n        newPause,\n      );\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield comment;\n  }\n}\n\nconst simplifyInstance = new Simplify();\nexport const simplify = simplifyInstance.traverseAlg.bind(simplifyInstance) as (\n  alg: Alg,\n  options: SimplifyOptions,\n) => Generator<Unit>;\n","// https://js.cubing.net/cubing/alg/\n\nimport { AlgCommon, Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsUnit } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parse\";\nimport { simplify, SimplifyOptions } from \"./traversal\";\nimport { Grouping, Pause } from \"./units\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport { Move } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport type { LeafUnit, Unit } from \"./units/Unit\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<Unit> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<Unit> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).units();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).units(); // TODO: something more direct?\n  }\n\n  // const seq = inputUnits as Sequence;\n  // if (seq.type === \"sequence\" && seq.nestedUnits) {\n  //   throw new Error(\"unimplemented\");\n  //   // return seq.nestedUnits;\n  // }\n\n  const iter = input as Iterable<Unit>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw new Error(\"Invalid unit\");\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * Alg is a class that encapsulates a structured alg. To create an alg from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when user-provided string input.\n *\n * Once you have an Alg, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().simplify().invert();\n *\n * To convert an Alg to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n * @category Alg\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #units: Iterable<Unit>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#units = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const unit of this.#units) {\n      if (!experimentalIsUnit(unit)) {\n        throw new Error(\"An alg can only contain units.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not take into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#units);\n    const l2 = Array.from(otherAsAlg.#units);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#units).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    for (const unit of direct(this.#units, iterDir)) {\n      yield* unit.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#units).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of this.#units) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  *units(): Generator<Unit> {\n    for (const unit of this.#units) {\n      yield unit;\n    }\n  }\n\n  experimentalNumUnits(): number {\n    return Array.from(this.#units).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  // toJSON(): AlgJSON {\n  //   return {\n  //     type: \"alg\",\n  //     units: Array.from(this.#units) as UnitJSON[],\n  //   };\n  // }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(): string {\n    let output = \"\";\n    let previousVisibleUnit: Unit | null = null;\n    for (const unit of this.#units) {\n      if (previousVisibleUnit) {\n        output += spaceBetween(previousVisibleUnit, unit);\n        // console.log(\"l\", previousUnit.toString(), unit.toString(), output);\n      }\n      const nissGrouping = unit.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString()})`;\n      } else if (unit.as(Grouping)?.experimentalNISSPlaceholder) {\n        // do not serialize (rely on the placeholder instead)\n      } else {\n        output += unit.toString();\n      }\n      previousVisibleUnit = unit;\n    }\n    return output;\n  }\n\n  // *experimentalExpand(options: ExperimentalExpandOptions): Generator<Unit> {\n  //   // if (options.depth === 0) {\n  //   //   yield* this.units();\n  //   //   return;\n  //   // }\n  //   // const newOptions = {\n  //   //   depth: options.depth ? options.depth - 1 : null,\n  //   // }; // TODO: avoid allocations?\n  //   // for (const unit of this.#units) {\n  //   //   yield* unit.experimentalExpandIntoAlg(newOptions);\n  //   // }\n  // }\n\n  simplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n}\n\nfunction spaceBetween(u1: Unit, u2: Unit): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n","// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./units\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { Move } from \"./units/leaves/Move\";\nimport { Pause } from \"./units/leaves/Pause\";\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n","import { Move } from \"./units/leaves/Move\";\n\nconst cubeKeyMapping: { [key: number]: Move } = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): Move | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import type { Alg } from \"./Alg\";\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nfunction serializeURLParam(a: Alg): string {\n  let escaped = a.toString();\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport interface AlgCubingNetOptions {\n  alg?: Alg;\n  setup?: Alg;\n  title?: string;\n  puzzle?:\n    | \"1x1x1\"\n    | \"2x2x2\"\n    | \"3x3x3\"\n    | \"4x4x4\"\n    | \"5x5x5\"\n    | \"6x6x6\"\n    | \"7x7x7\"\n    | \"8x8x8\"\n    | \"9x9x9\"\n    | \"10x10x10\"\n    | \"11x11x11\"\n    | \"12x12x12\"\n    | \"13x13x13\"\n    | \"14x14x14\"\n    | \"16x16x16\"\n    | \"17x17x17\";\n  stage?:\n    | \"full\"\n    | \"cross\"\n    | \"F2L\"\n    | \"LL\"\n    | \"OLL\"\n    | \"PLL\"\n    | \"CLS\"\n    | \"ELS\"\n    | \"L6E\"\n    | \"CMLL\"\n    | \"WV\"\n    | \"ZBLL\"\n    | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\";\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\";\n}\n\n// TODO: runtime validation?\nexport function algCubingNetLink(options: AlgCubingNetOptions): string {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error(\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if (\n      ![\n        \"1x1x1\",\n        \"2x2x2\",\n        \"3x3x3\",\n        \"4x4x4\",\n        \"5x5x5\",\n        \"6x6x6\",\n        \"7x7x7\",\n        \"8x8x8\",\n        \"9x9x9\",\n        \"10x10x10\",\n        \"11x11x11\",\n        \"12x12x12\",\n        \"13x13x13\",\n        \"14x14x14\",\n        \"16x16x16\",\n        \"17x17x17\",\n      ].includes(options.puzzle)\n    ) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if (\n      ![\n        \"full\",\n        \"cross\",\n        \"F2L\",\n        \"LL\",\n        \"OLL\",\n        \"PLL\",\n        \"CLS\",\n        \"ELS\",\n        \"L6E\",\n        \"CMLL\",\n        \"WV\",\n        \"ZBLL\",\n        \"void\",\n      ].includes(options.stage)\n    ) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if (![\"editor\", \"playback\", \"fullscreen\"].includes(options.view)) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if (\n      ![\n        \"moves\",\n        \"reconstruction\",\n        \"alg\",\n        \"reconstruction-end-with-setup\",\n      ].includes(options.type)\n    ) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n","import { Alg } from \"./Alg\";\nimport type { Move } from \"./units/leaves/Move\";\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  newMove: Move,\n  options?: {\n    coalesce?: boolean; // defaults to false\n    mod?: number;\n  },\n): Alg {\n  const oldUnits = Array.from(alg.units());\n  const oldLastMove = oldUnits[oldUnits.length - 1] as Move | undefined;\n  if (\n    options?.coalesce &&\n    oldLastMove &&\n    oldLastMove.quantum &&\n    oldLastMove.quantum.isIdentical(newMove.quantum)\n  ) {\n    const newUnits = oldUnits.slice(0, oldUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    const mod = options?.mod;\n    if (mod) {\n      newAmount = ((newAmount % mod) + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newUnits.push(oldLastMove.modified({ amount: newAmount }));\n    }\n    return new Alg(newUnits);\n  } else {\n    return new Alg([...oldUnits, newMove]);\n  }\n}\n","import {\n  PuzzleStickering,\n  StickeringManager,\n  experimental3x3x3KPuzzle,\n  experimentalStickerings\n} from \"./chunk-VYMKSHDI.js\";\nimport {\n  KPuzzle\n} from \"./chunk-VY7VF4MA.js\";\nimport {\n  __privateAdd,\n  __privateGet,\n  __privateSet\n} from \"./chunk-MGJA5U5O.js\";\n\n// src/cubing/puzzles/events.ts\nvar wcaEvents = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  \"clock\": { puzzleID: \"clock\", eventName: \"Clock\" },\n  \"minx\": { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  \"pyram\": { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  \"skewb\": { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  \"sq1\": { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" }\n};\nfunction wcaEventInfo(event) {\n  return wcaEvents[event] ?? null;\n}\nvar events = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\"\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\"\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\"\n  }\n};\nfunction eventInfo(event) {\n  return events[event] ?? null;\n}\n\n// src/cubing/puzzles/stickerings/cube-stickerings.ts\nasync function cubeAppearance(puzzleLoader, stickering) {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n  const LL = () => m.move(\"U\");\n  const orUD = () => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = () => m.or(m.moves([\"L\", \"R\"]));\n  const M = () => m.not(orLR());\n  const F2L = () => m.not(LL());\n  const centerLL = () => m.and([LL(), m.orbits([\"CENTERS\"])]);\n  const CENTERS = () => m.orbits([\"CENTERS\"]);\n  const EDGES = () => m.orbits([\"EDGES\"]);\n  const CORNERS = () => m.orbits([\"CORNERS\"]);\n  const L6E = () => m.or([M(), m.and([LL(), EDGES()])]);\n  const edgeFR = () => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = () => m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = () => m.or([cornerDFR(), edgeFR()]);\n  function dimF2L() {\n    puzzleStickering.set(F2L(), \"Dim\" /* Dim */);\n  }\n  function setPLL() {\n    puzzleStickering.set(LL(), \"PermuteNonPrimary\" /* PermuteNonPrimary */);\n    puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n  }\n  function setOLL() {\n    puzzleStickering.set(LL(), \"IgnoreNonPrimary\" /* IgnoreNonPrimary */);\n    puzzleStickering.set(centerLL(), \"Regular\" /* Regular */);\n  }\n  function dimOLL() {\n    puzzleStickering.set(LL(), \"Ignoriented\" /* Ignoriented */);\n    puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n  }\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\":\n      dimF2L();\n      setPLL();\n      break;\n    case \"CLS\":\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(LL(), \"Ignoriented\" /* Ignoriented */);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"IgnoreNonPrimary\" /* IgnoreNonPrimary */);\n      break;\n    case \"OLL\":\n      dimF2L();\n      setOLL();\n      break;\n    case \"COLL\":\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), \"Ignoriented\" /* Ignoriented */);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Regular\" /* Regular */);\n      break;\n    case \"OCLL\":\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"IgnoreNonPrimary\" /* IgnoreNonPrimary */);\n      break;\n    case \"CLL\":\n      dimF2L();\n      puzzleStickering.set(m.not(m.and([CORNERS(), LL()])), \"Dim\" /* Dim */);\n      break;\n    case \"ELL\":\n      dimF2L();\n      puzzleStickering.set(LL(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), EDGES()]), \"Regular\" /* Regular */);\n      break;\n    case \"ELS\":\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(edgeFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(cornerDFR(), \"Ignored\" /* Ignored */);\n      break;\n    case \"LL\":\n      dimF2L();\n      break;\n    case \"F2L\":\n      puzzleStickering.set(LL(), \"Ignored\" /* Ignored */);\n      break;\n    case \"ZBLL\":\n      dimF2L();\n      puzzleStickering.set(LL(), \"PermuteNonPrimary\" /* PermuteNonPrimary */);\n      puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Regular\" /* Regular */);\n      break;\n    case \"ZBLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Ignored\" /* Ignored */);\n      break;\n    case \"VLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      setOLL();\n      break;\n    case \"WVLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(m.and([LL(), EDGES()]), \"Ignoriented\" /* Ignoriented */);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"IgnoreNonPrimary\" /* IgnoreNonPrimary */);\n      break;\n    case \"LS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(LL(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n      break;\n    case \"EO\":\n      puzzleStickering.set(CORNERS(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(EDGES(), \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */);\n      break;\n    case \"EOline\":\n      puzzleStickering.set(CORNERS(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(EDGES(), \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */);\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), \"Regular\" /* Regular */);\n      break;\n    case \"EOcross\":\n      puzzleStickering.set(EDGES(), \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */);\n      puzzleStickering.set(m.move(\"D\"), \"Regular\" /* Regular */);\n      puzzleStickering.set(CORNERS(), \"Ignored\" /* Ignored */);\n      break;\n    case \"CMLL\":\n      puzzleStickering.set(F2L(), \"Dim\" /* Dim */);\n      puzzleStickering.set(L6E(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Regular\" /* Regular */);\n      break;\n    case \"L10P\":\n      puzzleStickering.set(m.not(L6E()), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), \"Regular\" /* Regular */);\n      break;\n    case \"L6E\":\n      puzzleStickering.set(m.not(L6E()), \"Dim\" /* Dim */);\n      break;\n    case \"L6EO\":\n      puzzleStickering.set(m.not(L6E()), \"Dim\" /* Dim */);\n      puzzleStickering.set(L6E(), \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */);\n      puzzleStickering.set(m.and([CENTERS(), orUD()]), \"OrientationStickers\" /* OrientationStickers */);\n      break;\n    case \"Daisy\":\n      puzzleStickering.set(m.all(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(CENTERS(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([m.move(\"D\"), CENTERS()]), \"Regular\" /* Regular */);\n      puzzleStickering.set(m.and([m.move(\"U\"), EDGES()]), \"IgnoreNonPrimary\" /* IgnoreNonPrimary */);\n      break;\n    case \"Cross\":\n      puzzleStickering.set(m.all(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(CENTERS(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([m.move(\"D\"), CENTERS()]), \"Regular\" /* Regular */);\n      puzzleStickering.set(m.and([m.move(\"D\"), EDGES()]), \"Regular\" /* Regular */);\n      break;\n    case \"2x2x2\":\n      puzzleStickering.set(m.or(m.moves([\"U\", \"F\", \"R\"])), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]), \"Dim\" /* Dim */);\n      break;\n    case \"2x2x3\":\n      puzzleStickering.set(m.all(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.or(m.moves([\"U\", \"F\", \"R\"])), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]), \"Regular\" /* Regular */);\n      break;\n    case \"Void Cube\":\n      puzzleStickering.set(CENTERS(), \"Invisible\" /* Invisible */);\n      break;\n    case \"picture\":\n    case \"invisible\":\n      puzzleStickering.set(m.all(), \"Invisible\" /* Invisible */);\n      break;\n    case \"centers-only\":\n      puzzleStickering.set(m.not(CENTERS()), \"Ignored\" /* Ignored */);\n      break;\n    default:\n      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);\n      puzzleStickering.set(m.and(m.moves([])), \"Dim\" /* Dim */);\n  }\n  return puzzleStickering.toAppearance();\n}\nasync function cubeStickerings() {\n  const stickerings = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups && \"3x3x3\" in info.groups) {\n      stickerings.push(name);\n    }\n  }\n  return stickerings;\n}\n\n// src/cubing/puzzles/async/lazy-cached.ts\nfunction getCached(getValue) {\n  let cachedPromise = null;\n  return () => {\n    return cachedPromise ?? (cachedPromise = getValue());\n  };\n}\n\n// src/cubing/puzzles/async/async-pg3d.ts\nasync function asyncGetPuzzleGeometry(puzzleName) {\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true\n  });\n}\nasync function asyncGetKPuzzle(pgPromise, puzzleName) {\n  const pg = await pgPromise;\n  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation\n  });\n}\nvar _cachedPG, _cachedKPuzzle, _cachedSVG;\nvar PGPuzzleLoader = class {\n  constructor(info) {\n    __privateAdd(this, _cachedPG, void 0);\n    __privateAdd(this, _cachedKPuzzle, void 0);\n    __privateAdd(this, _cachedSVG, void 0);\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n  pg() {\n    return __privateGet(this, _cachedPG) ?? __privateSet(this, _cachedPG, asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n  kpuzzle() {\n    return __privateGet(this, _cachedKPuzzle) ?? __privateSet(this, _cachedKPuzzle, asyncGetKPuzzle(this.pg(), this.id));\n  }\n  svg() {\n    return __privateGet(this, _cachedSVG) ?? __privateSet(this, _cachedSVG, (async () => (await this.pg()).generatesvg())());\n  }\n};\n_cachedPG = new WeakMap();\n_cachedKPuzzle = new WeakMap();\n_cachedSVG = new WeakMap();\nvar CubePGPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super(...arguments);\n    this.stickerings = cubeStickerings;\n  }\n  appearance(stickering) {\n    return cubeAppearance(this, stickering);\n  }\n};\n\n// src/cubing/puzzles/implementations/2x2x2/index.ts\nvar cube2x2x2 = {\n  id: \"2x2x2\",\n  fullName: \"2\\xD72\\xD72 Cube\",\n  kpuzzle: getCached(async () => new KPuzzle((await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).cube2x2x2JSON)),\n  svg: async () => {\n    return (await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).cube2x2x2SVG;\n  },\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  appearance: (stickering) => cubeAppearance(cube2x2x2, stickering),\n  stickerings: cubeStickerings\n};\n\n// src/cubing/puzzles/implementations/3x3x3/index.ts\nvar cube3x3x3 = {\n  id: \"3x3x3\",\n  fullName: \"3\\xD73\\xD73 Cube\",\n  inventedBy: [\"Ern\\u0151 Rubik\"],\n  inventionYear: 1974,\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-3x3x3-NB2PEZTV.js\")).cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-3x3x3-NB2PEZTV.js\")).cube3x3x3LLSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  appearance: (stickering) => cubeAppearance(cube3x3x3, stickering),\n  stickerings: cubeStickerings\n};\n\n// src/cubing/puzzles/implementations/clock/index.ts\nvar clock = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988,\n  kpuzzle: getCached(async () => new KPuzzle((await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).clockJSON)),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).clockSVG;\n  })\n};\n\n// src/cubing/puzzles/stickerings/fto-stickerings.ts\nasync function ftoStickering(puzzleLoader, stickering) {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n  const experimentalFTO_FC = () => m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = () => m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = () => m.or([\n    experimentalFTO_F2T(),\n    m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))])\n  ]);\n  const experimentalFTO_L2C = () => m.not(m.or([\n    m.and([m.move(\"U\"), m.move(\"F\")]),\n    m.and([m.move(\"F\"), m.move(\"BL\")]),\n    m.and([m.move(\"F\"), m.move(\"BR\")]),\n    m.and([m.move(\"BL\"), m.move(\"BR\")])\n  ]));\n  const experimentalFTO_LBT = () => m.not(m.or([\n    m.and([m.move(\"F\"), m.move(\"BL\")]),\n    m.and([m.move(\"F\"), m.move(\"BR\")]),\n    m.and([m.move(\"BL\"), m.move(\"BR\")])\n  ]));\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\":\n      puzzleStickering.set(m.not(experimentalFTO_FC()), \"Ignored\" /* Ignored */);\n      break;\n    case \"experimental-fto-f2t\":\n      puzzleStickering.set(m.not(experimentalFTO_F2T()), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(experimentalFTO_FC(), \"Dim\" /* Dim */);\n      break;\n    case \"experimental-fto-sc\":\n      puzzleStickering.set(m.not(experimentalFTO_SC()), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(experimentalFTO_F2T(), \"Dim\" /* Dim */);\n      break;\n    case \"experimental-fto-l2c\":\n      puzzleStickering.set(m.not(experimentalFTO_L2C()), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(experimentalFTO_SC(), \"Dim\" /* Dim */);\n      break;\n    case \"experimental-fto-lbt\":\n      puzzleStickering.set(m.not(experimentalFTO_LBT()), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(experimentalFTO_L2C(), \"Dim\" /* Dim */);\n      break;\n    case \"experimental-fto-l3t\":\n      puzzleStickering.set(experimentalFTO_LBT(), \"Dim\" /* Dim */);\n      break;\n    default:\n      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);\n      puzzleStickering.set(m.and(m.moves([])), \"Dim\" /* Dim */);\n  }\n  return puzzleStickering.toAppearance();\n}\nasync function ftoStickerings() {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\"\n  ];\n}\n\n// src/cubing/puzzles/implementations/fto/index.ts\nvar FTOPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"],\n      inventionYear: 1983\n    });\n    this.stickerings = ftoStickerings;\n    this.svg = getCached(async () => {\n      return (await import(\"./puzzles-dynamic-unofficial-MGVOFUDR.js\")).ftoSVG;\n    });\n  }\n  appearance(stickering) {\n    return ftoStickering(this, stickering);\n  }\n};\nvar fto = new FTOPuzzleLoader();\n\n// src/cubing/puzzles/stickerings/megaminx-stickerings.ts\nasync function megaminxAppearance(puzzleLoader, stickering) {\n  switch (stickering) {\n    case \"full\":\n    case \"F2L\":\n    case \"LL\":\n    case \"OLL\":\n    case \"PLL\":\n    case \"ELS\":\n    case \"CLS\":\n      return cubeAppearance(puzzleLoader, stickering);\n    default:\n      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);\n  }\n  return cubeAppearance(puzzleLoader, \"full\");\n}\nasync function megaminxStickerings() {\n  return [\"full\", \"F2L\", \"LL\", \"OLL\", \"PLL\", \"ELS\", \"CLS\"];\n}\n\n// src/cubing/puzzles/implementations/megaminx/index.ts\nvar MegaminxPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      inventionYear: 1981\n    });\n    this.stickerings = megaminxStickerings;\n  }\n  appearance(stickering) {\n    return megaminxAppearance(this, stickering);\n  }\n};\nvar megaminx = new MegaminxPuzzleLoader();\n\n// src/cubing/puzzles/implementations/pyraminx/index.ts\nvar PyraminxPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"]\n    });\n    this.svg = getCached(async () => {\n      return (await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).pyraminxSVG;\n    });\n  }\n};\nvar pyraminx = new PyraminxPuzzleLoader();\n\n// src/cubing/puzzles/implementations/square1/index.ts\nvar square1 = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hr\\u0161el\", \"Vojtech Kopsk\\xFD\"],\n  inventionYear: 1990,\n  kpuzzle: getCached(async () => new KPuzzle((await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).sq1HyperOrbitJSON)),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-side-events-HOXBZYWI.js\")).sq1HyperOrbitSVG;\n  })\n};\n\n// src/cubing/puzzles/implementations/kilominx/index.ts\nvar kilominx = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(JSON.stringify(pg.getKPuzzleDefinition(true)));\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete moveDefinition.CENTERS;\n      delete moveDefinition.CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move) => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        }\n      }\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-unofficial-MGVOFUDR.js\")).kilominxSVG;\n  })\n};\n\n// src/cubing/puzzles/implementations/redi-cube/index.ts\nvar rediCube = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(async () => new KPuzzle((await import(\"./puzzles-dynamic-unofficial-MGVOFUDR.js\")).rediCubeJSON)),\n  svg: async () => {\n    return (await import(\"./puzzles-dynamic-unofficial-MGVOFUDR.js\")).rediCubeSVG;\n  }\n};\n\n// src/cubing/puzzles/index.ts\nvar puzzles = {\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": new CubePGPuzzleLoader({ id: \"4x4x4\", fullName: \"4\\xD74\\xD74 Cube\" }),\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"5\\xD75\\xD75 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"6\\xD76\\xD76 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"7\\xD77\\xD77 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"40\\xD740\\xD740 Cube\"\n  }),\n  clock,\n  \"megaminx\": megaminx,\n  pyraminx,\n  \"skewb\": new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"]\n  }),\n  square1,\n  \"fto\": fto,\n  \"gigaminx\": new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006\n  }),\n  \"master_tetraminx\": new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"],\n    inventionYear: 2002\n  }),\n  kilominx,\n  \"redi_cube\": rediCube\n};\n\nexport {\n  wcaEventInfo,\n  eventInfo,\n  cube2x2x2,\n  cube3x3x3,\n  puzzles\n};\n//# sourceMappingURL=chunk-LNUPGLIU.js.map\n","import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n}\n\nconst wcaEvents: Record<string, EventInfo> = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  \"clock\": { puzzleID: \"clock\", eventName: \"Clock\" },\n  \"minx\": { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  \"pyram\": { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  \"skewb\": { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  \"sq1\": { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" },\n};\n\n/** @category Event Info */\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nconst events: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n  },\n};\n\n/** @category Event Info */\nexport function eventInfo(event: string): EventInfo | null {\n  return events[event] ?? null;\n}\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PieceSet,\n  PieceStickering,\n  PuzzleAppearance,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./appearance\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\n// TODO: cache calculations?\nexport async function cubeAppearance(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  // const E = (): PieceSet => m.not(orUD());\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n  // const orFB = (): PieceSet => m.or(m.moves([\"F\", \"B\"]));\n  // const S = (): PieceSet => m.not(orFB());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const centerLL = (): PieceSet => m.and([LL(), m.orbits([\"CENTERS\"])]);\n\n  const CENTERS = (): PieceSet => m.orbits([\"CENTERS\"]);\n  const EDGES = (): PieceSet => m.orbits([\"EDGES\"]);\n  const CORNERS = (): PieceSet => m.orbits([\"CORNERS\"]);\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\":\n      dimF2L();\n      setPLL();\n      break;\n    case \"CLS\":\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"OLL\":\n      dimF2L();\n      setOLL();\n      break;\n    case \"COLL\":\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"OCLL\":\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"CLL\":\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    case \"ELL\":\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    case \"ELS\":\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    case \"LL\":\n      dimF2L();\n      break;\n    case \"F2L\":\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    case \"ZBLL\":\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"ZBLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    case \"VLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    case \"WVLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"LS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    case \"EO\":\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    case \"EOline\":\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    case \"EOcross\":\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    case \"CMLL\":\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"L10P\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    case \"L6E\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    case \"L6EO\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // For PG\n      break;\n    case \"Daisy\":\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"Cross\":\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    case \"2x2x2\":\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    case \"2x2x3\":\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    case \"Void Cube\":\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    case \"picture\":\n    // fallthrough\n    case \"invisible\":\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    case \"centers-only\":\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toAppearance();\n}\n\nexport async function cubeStickerings(): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups && \"3x3x3\" in info.groups) {\n      stickerings.push(name);\n    }\n  }\n  return stickerings;\n}\n","export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n","import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../stickerings/cube-stickerings\";\nimport { getCached } from \"./lazy-cached\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return cubeAppearance(this, stickering);\n  }\n  stickerings = cubeStickerings;\n}\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../../stickerings/cube-stickerings\";\n\n/** @category Specific Puzzles */\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"222 Cube\",\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (\n          await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n        ).cube2x2x2JSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .cube2x2x2SVG;\n  },\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  appearance: (stickering: ExperimentalStickering): Promise<PuzzleAppearance> =>\n    cubeAppearance(cube2x2x2, stickering),\n  stickerings: cubeStickerings,\n};\n","// Include 3x3x3 in the main bundle for better performance.\nimport { experimental3x3x3KPuzzle } from \"../../cubing-private\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../../stickerings/cube-stickerings\";\n\n/** @category Specific Puzzles */\nexport const cube3x3x3: PuzzleLoader = {\n  id: \"3x3x3\",\n  fullName: \"333 Cube\",\n  inventedBy: [\"Ern Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  appearance: (stickering: ExperimentalStickering): Promise<PuzzleAppearance> =>\n    cubeAppearance(cube3x3x3, stickering),\n  stickerings: cubeStickerings,\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (\n          await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n        ).clockJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .clockSVG;\n  }),\n};\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PuzzleAppearance,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./appearance\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    case \"experimental-fto-f2t\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-sc\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-l2c\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-lbt\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-l3t\":\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toAppearance();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n  svg = getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .ftoSVG;\n  });\n}\n\nexport const fto = new FTOPuzzleLoader();\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"./appearance\";\nimport { cubeAppearance } from \"./cube-stickerings\";\n\n// TODO: cache calculations?\nexport async function megaminxAppearance(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  switch (stickering) {\n    case \"full\":\n    case \"F2L\":\n    case \"LL\":\n    case \"OLL\":\n    case \"PLL\":\n    case \"ELS\":\n    case \"CLS\":\n      return cubeAppearance(puzzleLoader, stickering);\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n  }\n  return cubeAppearance(puzzleLoader, \"full\");\n}\n\nexport async function megaminxStickerings(): Promise<ExperimentalStickering[]> {\n  return [\"full\", \"F2L\", \"LL\", \"OLL\", \"PLL\", \"ELS\", \"CLS\"];\n}\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  megaminxAppearance,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return megaminxAppearance(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n","import { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  svg = getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .pyraminxSVG;\n  });\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hrel\", \"Vojtech Kopsk\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (\n          await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n        ).sq1HyperOrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .sq1HyperOrbitSVG;\n  }),\n};\n","import type { PuzzleLoader } from \"../..\";\nimport type { Move } from \"../../../alg\";\nimport { KPuzzle, KTransformationData } from \"../../../kpuzzle\";\nimport type { ExperimentalPGNotation } from \"../../../puzzle-geometry\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(\n      JSON.stringify(pg.getKPuzzleDefinition(true)),\n    );\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete (moveDefinition as any).CENTERS;\n      delete (moveDefinition as any).CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"../../../puzzle-geometry\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n      pg,\n      pg.getOrbitsDef(true),\n    );\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move: Move): KTransformationData | null => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        },\n      } as ExperimentalPGNotation,\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .kilominxSVG;\n  }),\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (\n          await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\")\n        ).rediCubeJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .rediCubeSVG;\n  },\n};\n","export { eventInfo, wcaEventInfo } from \"./events\";\nexport type { PuzzleLoader };\nexport { cube2x2x2, cube3x3x3 };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { square1 } from \"./implementations/square1\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\nimport { rediCube } from \"./implementations/redi-cube\";\n\n/** @category All Puzzles */\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": new CubePGPuzzleLoader({ id: \"4x4x4\", fullName: \"444 Cube\" }),\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"555 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"666 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"777 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"404040 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  \"megaminx\": megaminx,\n  pyraminx,\n  \"skewb\": new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  \"fto\": fto,\n  \"gigaminx\": new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  \"master_tetraminx\": new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  \"redi_cube\": rediCube,\n};\n","import {\n  KPuzzle,\n  KState\n} from \"./chunk-VY7VF4MA.js\";\nimport {\n  Alg\n} from \"./chunk-NQORDEXF.js\";\n\n// src/cubing/puzzles/stickerings/appearance.ts\nfunction getFaceletAppearance(appearance, orbitName, pieceIdx, faceletIdx, hint) {\n  const orbitAppearance = appearance.orbits[orbitName];\n  const pieceAppearance = orbitAppearance.pieces[pieceIdx];\n  if (pieceAppearance === null) {\n    return regular;\n  }\n  const faceletAppearance = pieceAppearance.facelets[faceletIdx];\n  if (faceletAppearance === null) {\n    return regular;\n  }\n  if (typeof faceletAppearance === \"string\") {\n    return faceletAppearance;\n  }\n  if (hint) {\n    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;\n  }\n  return faceletAppearance.appearance;\n}\nvar PieceAnnotation = class {\n  constructor(kpuzzle, defaultValue) {\n    this.stickerings = /* @__PURE__ */ new Map();\n    for (const [orbitName, orbitDef] of Object.entries(kpuzzle.definition.orbits)) {\n      this.stickerings.set(orbitName, new Array(orbitDef.numPieces).fill(defaultValue));\n    }\n  }\n};\nvar regular = \"regular\";\nvar ignored = \"ignored\";\nvar oriented = \"oriented\";\nvar invisible = \"invisible\";\nvar dim = \"dim\";\nvar r = {\n  facelets: [regular, regular, regular, regular, regular]\n};\nvar i = {\n  facelets: [ignored, ignored, ignored, ignored, ignored]\n};\nvar o = {\n  facelets: [oriented, oriented, oriented, oriented, oriented]\n};\nvar invisiblePiece = {\n  facelets: [invisible, invisible, invisible, invisible]\n};\nvar riiii = {\n  facelets: [regular, ignored, ignored, ignored, ignored]\n};\nvar drrrr = {\n  facelets: [dim, regular, regular, regular, regular]\n};\nvar d = {\n  facelets: [dim, dim, dim, dim, dim]\n};\nvar diiii = {\n  facelets: [dim, ignored, ignored, ignored, ignored]\n};\nvar oiiii = {\n  facelets: [oriented, ignored, ignored, ignored, ignored]\n};\nfunction getPieceAppearance(pieceStickering) {\n  switch (pieceStickering) {\n    case \"Regular\" /* Regular */:\n      return r;\n    case \"Dim\" /* Dim */:\n      return d;\n    case \"Ignored\" /* Ignored */:\n      return i;\n    case \"OrientationStickers\" /* OrientationStickers */:\n      return o;\n    case \"Invisible\" /* Invisible */:\n      return invisiblePiece;\n    case \"IgnoreNonPrimary\" /* IgnoreNonPrimary */:\n      return riiii;\n    case \"PermuteNonPrimary\" /* PermuteNonPrimary */:\n      return drrrr;\n    case \"Ignoriented\" /* Ignoriented */:\n      return diiii;\n    case \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */:\n      return oiiii;\n  }\n}\nvar PuzzleStickering = class extends PieceAnnotation {\n  constructor(kpuzzle) {\n    super(kpuzzle, \"Regular\" /* Regular */);\n  }\n  set(pieceSet, pieceStickering) {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i2 = 0; i2 < pieces.length; i2++) {\n        if (pieceSet.stickerings.get(orbitName)[i2]) {\n          pieces[i2] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n  toAppearance() {\n    const appearance = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces = [];\n      const orbitAppearance = {\n        pieces\n      };\n      appearance.orbits[orbitName] = orbitAppearance;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceAppearance(pieceStickering));\n      }\n    }\n    return appearance;\n  }\n};\nvar StickeringManager = class {\n  constructor(kpuzzle) {\n    this.kpuzzle = kpuzzle;\n  }\n  and(pieceSets) {\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {\n      pieceLoop:\n        for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {\n          newPieceSet.stickerings.get(orbitName)[i2] = true;\n          for (const pieceSet of pieceSets) {\n            if (!pieceSet.stickerings.get(orbitName)[i2]) {\n              newPieceSet.stickerings.get(orbitName)[i2] = false;\n              continue pieceLoop;\n            }\n          }\n        }\n    }\n    return newPieceSet;\n  }\n  or(pieceSets) {\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {\n      pieceLoop:\n        for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {\n          newPieceSet.stickerings.get(orbitName)[i2] = false;\n          for (const pieceSet of pieceSets) {\n            if (pieceSet.stickerings.get(orbitName)[i2]) {\n              newPieceSet.stickerings.get(orbitName)[i2] = true;\n              continue pieceLoop;\n            }\n          }\n        }\n    }\n    return newPieceSet;\n  }\n  not(pieceSet) {\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {\n      for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {\n        newPieceSet.stickerings.get(orbitName)[i2] = !pieceSet.stickerings.get(orbitName)[i2];\n      }\n    }\n    return newPieceSet;\n  }\n  all() {\n    return this.and(this.moves([]));\n  }\n  move(moveSource) {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {\n      for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {\n        if (transformation.transformationData[orbitName].permutation[i2] !== i2 || transformation.transformationData[orbitName].orientation[i2] !== 0) {\n          newPieceSet.stickerings.get(orbitName)[i2] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n  moves(moveSources) {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n  orbits(orbitNames) {\n    const pieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName).fill(true);\n    }\n    return pieceSet;\n  }\n};\n\n// src/cubing/puzzles/stickerings/puzzle-stickerings.ts\nvar experimentalStickerings = {\n  \"full\": { groups: { \"3x3x3\": \"Stickering\" } },\n  \"OLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"PLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"LL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"COLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"OCLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"CLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"ELL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"ZBLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"LS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"ELS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"CLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"ZBLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"VLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"WVLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"F2L\": { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  \"Daisy\": { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  \"Cross\": { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  \"EO\": { groups: { \"3x3x3\": \"ZZ\" } },\n  \"EOline\": { groups: { \"3x3x3\": \"ZZ\" } },\n  \"EOcross\": { groups: { \"3x3x3\": \"ZZ\" } },\n  \"CMLL\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"L10P\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"L6E\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"L6EO\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"invisible\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"picture\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } }\n};\n\n// src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts\nvar cube3x3x3KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 }\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0]\n    }\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0]\n      }\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3]\n      }\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2]\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2]\n      }\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0]\n      }\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0]\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0]\n      }\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0]\n      }\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0]\n      }\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1]\n      }\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1]\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1]\n      }\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0]\n      }\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0]\n      }\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1]\n      }\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0]\n      }\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0]\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0]\n      }\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0]\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1]\n      }\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2]\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2]\n      }\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1]\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3]\n      }\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1]\n      }\n    }\n  }\n};\ncube3x3x3KPuzzleDefinition.moves[\"Uw\"] = cube3x3x3KPuzzleDefinition.moves[\"u\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lw\"] = cube3x3x3KPuzzleDefinition.moves[\"l\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fw\"] = cube3x3x3KPuzzleDefinition.moves[\"f\"];\ncube3x3x3KPuzzleDefinition.moves[\"Rw\"] = cube3x3x3KPuzzleDefinition.moves[\"r\"];\ncube3x3x3KPuzzleDefinition.moves[\"Bw\"] = cube3x3x3KPuzzleDefinition.moves[\"b\"];\ncube3x3x3KPuzzleDefinition.moves[\"Dw\"] = cube3x3x3KPuzzleDefinition.moves[\"d\"];\ncube3x3x3KPuzzleDefinition.moves[\"Rv\"] = cube3x3x3KPuzzleDefinition.moves[\"x\"];\ncube3x3x3KPuzzleDefinition.moves[\"Uv\"] = cube3x3x3KPuzzleDefinition.moves[\"y\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fv\"] = cube3x3x3KPuzzleDefinition.moves[\"z\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lv\"] = {\n  EDGES: {\n    permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],\n    orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n  },\n  CORNERS: {\n    permutation: [1, 7, 6, 2, 0, 3, 5, 4],\n    orientation: [2, 1, 2, 1, 1, 2, 1, 2]\n  },\n  CENTERS: {\n    permutation: [4, 1, 0, 3, 5, 2],\n    orientation: [2, 1, 0, 3, 2, 0]\n  }\n};\ncube3x3x3KPuzzleDefinition.moves[\"Dv\"] = {\n  EDGES: {\n    permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n  },\n  CORNERS: {\n    permutation: [3, 0, 1, 2, 5, 6, 7, 4],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n  },\n  CENTERS: {\n    permutation: [0, 4, 1, 2, 3, 5],\n    orientation: [3, 0, 0, 0, 0, 1]\n  }\n};\ncube3x3x3KPuzzleDefinition.moves[\"Bv\"] = {\n  EDGES: {\n    permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],\n    orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n  },\n  CORNERS: {\n    permutation: [4, 7, 1, 0, 5, 3, 2, 6],\n    orientation: [1, 2, 1, 2, 2, 1, 2, 1]\n  },\n  CENTERS: {\n    permutation: [3, 0, 2, 5, 4, 1],\n    orientation: [3, 3, 3, 3, 1, 3]\n  }\n};\n\n// src/cubing/puzzles/customPGPuzzleLoader.ts\nasync function descAsyncGetPuzzleGeometry(desc) {\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true\n  });\n}\nasync function asyncGetKPuzzle(desc) {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation\n  });\n}\nvar nextCustomID = 1;\nfunction customPGPuzzleLoader(desc, info) {\n  const customID = nextCustomID++;\n  let cachedKPuzzle = null;\n  const puzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: async () => {\n      return cachedKPuzzle ?? (cachedKPuzzle = asyncGetKPuzzle(desc));\n    },\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    }\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n\n// src/cubing/puzzles/cubing-private/index.ts\nvar experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);\ncube3x3x3KPuzzleDefinition.experimentalIsStateSolved = experimentalIs3x3x3Solved;\n\n// src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts\nfunction puzzleOrientation3x3x3Idx(state) {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\nvar puzzleOrientationCacheRaw = new Array(6).fill(0).map(() => {\n  return new Array(6);\n});\nvar puzzleOrientationCacheInitialized = false;\nfunction puzzleOrientation3x3x3Cache() {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) => Alg.fromString(s));\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i2 = 0; i2 < 4; i2++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(transformation.toKState());\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\nfunction normalize3x3x3Orientation(state) {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\nfunction experimentalIs3x3x3Solved(state, options) {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0)\n      }\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation();\n}\n\nexport {\n  getFaceletAppearance,\n  PuzzleStickering,\n  StickeringManager,\n  experimentalStickerings,\n  puzzleOrientation3x3x3Idx,\n  puzzleOrientation3x3x3Cache,\n  normalize3x3x3Orientation,\n  customPGPuzzleLoader,\n  experimental3x3x3KPuzzle\n};\n//# sourceMappingURL=chunk-VYMKSHDI.js.map\n","// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshAppearance =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletAppearance = {\n  appearance: FaceletMeshAppearance;\n  hintAppearance?: FaceletMeshAppearance;\n};\n\nexport type PieceAppearance = {\n  // TODO: foundation?\n  facelets: (FaceletMeshAppearance | FaceletAppearance | null)[];\n};\n\nexport type OrbitAppearance = {\n  pieces: (PieceAppearance | null)[];\n};\n\nexport type PuzzleAppearance = {\n  name?: string; // TODO\n  orbits: Record<string, OrbitAppearance>;\n};\n\nexport function getFaceletAppearance(\n  appearance: PuzzleAppearance,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshAppearance {\n  const orbitAppearance = appearance.orbits[orbitName];\n  const pieceAppearance: PieceAppearance | null =\n    orbitAppearance.pieces[pieceIdx];\n  if (pieceAppearance === null) {\n    return regular;\n  }\n  const faceletAppearance: FaceletMeshAppearance | FaceletAppearance | null =\n    pieceAppearance.facelets[faceletIdx];\n  if (faceletAppearance === null) {\n    return regular;\n  }\n  if (typeof faceletAppearance === \"string\") {\n    return faceletAppearance;\n  }\n  if (hint) {\n    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;\n  }\n  return faceletAppearance.appearance;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// regular\nconst r: PieceAppearance = {\n  facelets: [regular, regular, regular, regular, regular],\n};\n\n// ignored\nconst i: PieceAppearance = {\n  facelets: [ignored, ignored, ignored, ignored, ignored],\n};\n\n// oriented stickers\nconst o: PieceAppearance = {\n  facelets: [oriented, oriented, oriented, oriented, oriented],\n};\n\n// invisible\nconst invisiblePiece: PieceAppearance = {\n  facelets: [invisible, invisible, invisible, invisible], // TODO: 4th entry is for void cube. Should be handled properly for all stickerings.\n};\n\n// \"OLL\"\nconst riiii: PieceAppearance = {\n  facelets: [regular, ignored, ignored, ignored, ignored],\n};\n\n// \"PLL\"\nconst drrrr: PieceAppearance = {\n  facelets: [dim, regular, regular, regular, regular],\n};\n\n// ignored\nconst d: PieceAppearance = {\n  facelets: [dim, dim, dim, dim, dim],\n};\n\n// \"OLL\"\nconst diiii: PieceAppearance = {\n  facelets: [dim, ignored, ignored, ignored, ignored],\n};\n\n// oriented\nconst oiiii: PieceAppearance = {\n  facelets: [oriented, ignored, ignored, ignored, ignored],\n};\n\nexport function getPieceAppearance(\n  pieceStickering: PieceStickering,\n): PieceAppearance {\n  switch (pieceStickering) {\n    case PieceStickering.Regular:\n      return r;\n    case PieceStickering.Dim:\n      return d;\n    case PieceStickering.Ignored:\n      return i;\n    case PieceStickering.OrientationStickers: // TODO: Hack for centers. This shouldn't be needed.\n      return o;\n    case PieceStickering.Invisible: // TODO: Hack for centers. This shouldn't be needed.\n      return invisiblePiece;\n    case PieceStickering.IgnoreNonPrimary:\n      return riiii;\n    case PieceStickering.PermuteNonPrimary:\n      return drrrr;\n    case PieceStickering.Ignoriented:\n      return diiii;\n    case PieceStickering.OrientationWithoutPermutation:\n      return oiiii;\n  }\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toAppearance(): PuzzleAppearance {\n    const appearance: PuzzleAppearance = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceAppearance[] = [];\n      const orbitAppearance: OrbitAppearance = {\n        pieces,\n      };\n      appearance.orbits[orbitName] = orbitAppearance;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceAppearance(pieceStickering));\n      }\n    }\n    return appearance;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n","import type { PuzzleID } from \"../../twisty\";\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  \"full\": { groups: { \"3x3x3\": \"Stickering\" } }, // default\n  \"OLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"PLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"LL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"COLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"OCLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"CLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"ELL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"ZBLL\": { groups: { \"3x3x3\": \"Last Layer\" } },\n  \"LS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"ELS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"CLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"ZBLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"VLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"WVLS\": { groups: { \"3x3x3\": \"Last Slot\" } },\n  \"F2L\": { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  \"Daisy\": { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  \"Cross\": { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  \"EO\": { groups: { \"3x3x3\": \"ZZ\" } },\n  \"EOline\": { groups: { \"3x3x3\": \"ZZ\" } },\n  \"EOcross\": { groups: { \"3x3x3\": \"ZZ\" } },\n  \"CMLL\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"L10P\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"L6E\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"L6EO\": { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"invisible\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"picture\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n","import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.moves[\"Uw\"] = cube3x3x3KPuzzleDefinition.moves[\"u\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lw\"] = cube3x3x3KPuzzleDefinition.moves[\"l\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fw\"] = cube3x3x3KPuzzleDefinition.moves[\"f\"];\ncube3x3x3KPuzzleDefinition.moves[\"Rw\"] = cube3x3x3KPuzzleDefinition.moves[\"r\"];\ncube3x3x3KPuzzleDefinition.moves[\"Bw\"] = cube3x3x3KPuzzleDefinition.moves[\"b\"];\ncube3x3x3KPuzzleDefinition.moves[\"Dw\"] = cube3x3x3KPuzzleDefinition.moves[\"d\"];\n\ncube3x3x3KPuzzleDefinition.moves[\"Rv\"] = cube3x3x3KPuzzleDefinition.moves[\"x\"];\ncube3x3x3KPuzzleDefinition.moves[\"Uv\"] = cube3x3x3KPuzzleDefinition.moves[\"y\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fv\"] = cube3x3x3KPuzzleDefinition.moves[\"z\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lv\"] = {\n  EDGES: {\n    permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],\n    orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n  },\n  CORNERS: {\n    permutation: [1, 7, 6, 2, 0, 3, 5, 4],\n    orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n  },\n  CENTERS: {\n    permutation: [4, 1, 0, 3, 5, 2],\n    orientation: [2, 1, 0, 3, 2, 0],\n  },\n};\ncube3x3x3KPuzzleDefinition.moves[\"Dv\"] = {\n  EDGES: {\n    permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  },\n  CORNERS: {\n    permutation: [3, 0, 1, 2, 5, 6, 7, 4],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n  },\n  CENTERS: {\n    permutation: [0, 4, 1, 2, 3, 5],\n    orientation: [3, 0, 0, 0, 0, 1],\n  },\n};\ncube3x3x3KPuzzleDefinition.moves[\"Bv\"] = {\n  EDGES: {\n    permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],\n    orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  },\n  CORNERS: {\n    permutation: [4, 7, 1, 0, 5, 3, 2, 6],\n    orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n  },\n  CENTERS: {\n    permutation: [3, 0, 2, 5, 4, 1],\n    orientation: [3, 3, 3, 3, 1, 3],\n  },\n};\n","import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: async () => {\n      return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n    },\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n","import { KPuzzle } from \"../../kpuzzle\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsStateSolved =\n  experimentalIs3x3x3Solved;\n\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport { getFaceletAppearance as experimentalGetFaceletAppearance } from \"../stickerings/appearance\";\nexport type {\n  FaceletMeshAppearance as ExperimentalFaceletMeshAppearance,\n  PuzzleAppearance as ExperimentalPuzzleAppearance,\n} from \"../stickerings/appearance\";\n","import { Alg } from \"../../../../alg\";\nimport { KState, KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(state: KState): [number, number] {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKState(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(state: KState): KState {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n","import {\n  Alg,\n  Move,\n  TraversalDownUp\n} from \"./chunk-NQORDEXF.js\";\nimport {\n  __privateAdd,\n  __privateGet,\n  __privateSet\n} from \"./chunk-MGJA5U5O.js\";\n\n// src/cubing/kpuzzle/combine.ts\nfunction combineTransformationData(definition, transformationData1, transformationData2) {\n  const newTransformationData = {};\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {\n      newTransformationData[orbitName] = orbit1;\n    } else if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit1)) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\nfunction applyTransformationDataToStateData(definition, stateData, transformationData) {\n  const newStateData = {};\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n\n// src/cubing/kpuzzle/construct.ts\nvar FREEZE = false;\nvar identityOrbitCache = /* @__PURE__ */ new Map();\nfunction constructIdentityOrbitTransformation(numPieces) {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation);\n    Object.freeze(newOrientation);\n    Object.freeze(orbitTransformation);\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\nfunction constructIdentityTransformationDataUncached(definition) {\n  const transformation = {};\n  for (const [orbitName, orbitDefinition] of Object.entries(definition.orbits)) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(orbitDefinition.numPieces);\n  }\n  if (FREEZE) {\n    Object.freeze(transformation);\n  }\n  return transformation;\n}\nfunction moveToTransformationUncached(kpuzzle, move) {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey];\n  if (!quantumMoveDefinition) {\n    const derivedFrom = kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n    if (derivedFrom) {\n      quantumMoveDefinition = kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, quantumMoveDefinition, move.amount);\n  }\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n  const inverseMoveDefinition = kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n\n// src/cubing/kpuzzle/KState.ts\nvar KState = class {\n  constructor(kpuzzle, stateData) {\n    this.kpuzzle = kpuzzle;\n    this.stateData = stateData;\n  }\n  toJSON() {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData\n    };\n  }\n  static fromTransformation(transformation) {\n    const newStateData = applyTransformationDataToStateData(transformation.kpuzzle.definition, transformation.kpuzzle.definition.startStateData, transformation.transformationData);\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n  apply(source) {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n  applyTransformation(transformation) {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(this.kpuzzle.definition, this.stateData, transformation.transformationData);\n    return new KState(this.kpuzzle, newStateData);\n  }\n  applyMove(move) {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n  applyAlg(alg) {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n  experimentalToTransformation() {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n  experimentalIsSolved(options) {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\");\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n};\n\n// src/cubing/kpuzzle/KTransformation.ts\nvar _cachedIsIdentity;\nvar _KTransformation = class {\n  constructor(kpuzzle, transformationData) {\n    this.kpuzzle = kpuzzle;\n    this.transformationData = transformationData;\n    __privateAdd(this, _cachedIsIdentity, void 0);\n  }\n  toJSON() {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData\n    };\n  }\n  invert() {\n    return new _KTransformation(this.kpuzzle, invertTransformation(this.kpuzzle, this.transformationData));\n  }\n  isIdentityTransformation() {\n    return __privateGet(this, _cachedIsIdentity) ?? __privateSet(this, _cachedIsIdentity, this.isIdentical(this.kpuzzle.identityTransformation()));\n  }\n  static experimentalConstructIdentity(kpuzzle) {\n    const transformation = new _KTransformation(kpuzzle, constructIdentityTransformationDataUncached(kpuzzle.definition));\n    __privateSet(transformation, _cachedIsIdentity, true);\n    return transformation;\n  }\n  isIdentical(t2) {\n    return isTransformationDataIdentical(this.kpuzzle, this.transformationData, t2.transformationData);\n  }\n  apply(source) {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n  applyTransformation(t2) {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(`Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`);\n    }\n    if (__privateGet(this, _cachedIsIdentity)) {\n      return new _KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (__privateGet(t2, _cachedIsIdentity)) {\n      return new _KTransformation(this.kpuzzle, this.transformationData);\n    }\n    return new _KTransformation(this.kpuzzle, combineTransformationData(this.kpuzzle.definition, this.transformationData, t2.transformationData));\n  }\n  applyMove(move) {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n  applyAlg(alg) {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n  toKState() {\n    return KState.fromTransformation(this);\n  }\n  repetitionOrder() {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n  selfMultiply(amount) {\n    return new _KTransformation(this.kpuzzle, repeatTransformationUncached(this.kpuzzle, this.transformationData, amount));\n  }\n};\nvar KTransformation = _KTransformation;\n_cachedIsIdentity = new WeakMap();\n\n// src/cubing/kpuzzle/calculate.ts\nfunction isOrbitTransformationDataIdentityUncached(numOrientations, orbitTransformationData) {\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction isOrbitTransformationDataIdentical(orbitDefinition, orbitTransformationData1, orbitTransformationData2, options = {}) {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (!options?.ignoreOrientation && orbitTransformationData1.orientation[idx] !== orbitTransformationData2.orientation[idx]) {\n      return false;\n    }\n    if (!options?.ignorePermutation && orbitTransformationData1.permutation[idx] !== orbitTransformationData2.permutation[idx]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isTransformationDataIdentical(kpuzzle, transformationData1, transformationData2) {\n  for (const [orbitName, orbitDefinition] of Object.entries(kpuzzle.definition.orbits)) {\n    if (!isOrbitTransformationDataIdentical(orbitDefinition, transformationData1[orbitName], transformationData2[orbitName])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction invertTransformation(kpuzzle, transformationData) {\n  const newTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition = kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbitTransformationData)) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] = (orbitDefinition.numOrientations - orbitTransformationData.orientation[idx] + orbitDefinition.numOrientations) % orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri\n      };\n    }\n  }\n  return newTransformationData;\n}\nfunction repeatTransformationUncached(kpuzzle, transformationData, amount) {\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(kpuzzle, invertTransformation(kpuzzle, transformationData), -amount);\n  }\n  if (amount === 0) {\n    const { transformationData: transformationData2 } = kpuzzle.identityTransformation();\n    return transformationData2;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(kpuzzle, transformationData, Math.floor(amount / 2));\n  }\n  const twiceHalfish = combineTransformationData(kpuzzle.definition, halfish, halfish);\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(kpuzzle.definition, transformationData, twiceHalfish);\n  }\n}\nvar AlgToTransformationTraversal = class extends TraversalDownUp {\n  traverseAlg(alg, kpuzzle) {\n    let transformation = null;\n    for (const unit of alg.units()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(this.traverseUnit(unit, kpuzzle));\n      } else {\n        transformation = this.traverseUnit(unit, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping, kpuzzle) {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(kpuzzle, repeatTransformationUncached(kpuzzle, algTransformation.transformationData, grouping.amount));\n  }\n  traverseMove(move, kpuzzle) {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(commutator, kpuzzle) {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert()).applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate, kpuzzle) {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert());\n  }\n  traversePause(_, kpuzzle) {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_, kpuzzle) {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_, kpuzzle) {\n    return kpuzzle.identityTransformation();\n  }\n};\nvar algToTransformationInstance = new AlgToTransformationTraversal();\nvar algToTransformation = algToTransformationInstance.traverseAlg.bind(algToTransformationInstance);\nfunction gcd(a, b) {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\nfunction transformationRepetitionOrder(definition, transformation) {\n  let order = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (; ; ) {\n          orbitPieces[currentIdx] = true;\n          orientationSum = orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength = cycleLength * orbitDefinition.numOrientations / gcd(orbitDefinition.numOrientations, orientationSum);\n        }\n        order = order * cycleLength / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n\n// src/cubing/kpuzzle/KPuzzle.ts\nvar _moveToTransformationDataCache, _cachedCanConvertStateToUniqueTransformation;\nvar KPuzzle = class {\n  constructor(definition, options) {\n    this.definition = definition;\n    __privateAdd(this, _moveToTransformationDataCache, /* @__PURE__ */ new Map());\n    __privateAdd(this, _cachedCanConvertStateToUniqueTransformation, void 0);\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n  name() {\n    return this.definition.name;\n  }\n  identityTransformation() {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n  moveToTransformation(move) {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData = __privateGet(this, _moveToTransformationDataCache).get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n    if (this.experimentalPGNotation) {\n      const transformationData2 = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData2) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData2);\n      return new KTransformation(this, transformationData2);\n    }\n    const transformationData = moveToTransformationUncached(this, move);\n    __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n  algToTransformation(alg) {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n  toTransformation(source) {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if (source?.is?.(Alg)) {\n      return this.algToTransformation(source);\n    } else if (source?.is?.(Move)) {\n      return this.moveToTransformation(source);\n    } else {\n      return source;\n    }\n  }\n  startState() {\n    return new KState(this, this.definition.startStateData);\n  }\n  canConvertStateToUniqueTransformation() {\n    return __privateGet(this, _cachedCanConvertStateToUniqueTransformation) ?? __privateSet(this, _cachedCanConvertStateToUniqueTransformation, (() => {\n      for (const [orbitName, orbitDefinition] of Object.entries(this.definition.orbits)) {\n        const pieces = new Array(orbitDefinition.numPieces).fill(false);\n        for (const piece of this.definition.startStateData[orbitName].pieces) {\n          pieces[piece] = true;\n        }\n        for (const piece of pieces) {\n          if (!piece) {\n            return false;\n          }\n        }\n      }\n      return true;\n    })());\n  }\n  get state() {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n  reset() {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n  applyMove(_move) {\n    throw new Error(\"KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.\");\n  }\n  applyAlg(_alg) {\n    throw new Error(\"KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.\");\n  }\n};\n_moveToTransformationDataCache = new WeakMap();\n_cachedCanConvertStateToUniqueTransformation = new WeakMap();\n\nexport {\n  KState,\n  KTransformation,\n  KPuzzle\n};\n//# sourceMappingURL=chunk-VY7VF4MA.js.map\n","import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n","import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n","import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KStateData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\n        \"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n}\n","import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n","import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const unit of alg.units()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseUnit(unit, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseUnit(unit, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nconst algToTransformationInstance = new AlgToTransformationTraversal();\nexport const algToTransformation = algToTransformationInstance.traverseAlg.bind(\n  algToTransformationInstance,\n) as (alg: Alg, kpuzzle: KPuzzle) => KTransformation;\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, orientationSum);\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n","import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  get state(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  reset(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyMove(_move: Move): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.\",\n    );\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyAlg(_alg: Alg): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.\",\n    );\n  }\n}\n","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"eXwSi\"))).then(() => parcelRequire('bYa3M'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"35dX4\"))).then(() => parcelRequire('5xeEv'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"CLUvY\"))).then(() => parcelRequire('2i5EB'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"4VSor\"))).then(() => parcelRequire('cLQ7S'));"],"names":[],"version":3,"file":"index.04ff6efc.js.map"}