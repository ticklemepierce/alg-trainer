{
  "version": 3,
  "sources": ["../../node_modules/cubing/src/cubing/alg/common.ts", "../../node_modules/cubing/src/cubing/alg/iteration.ts", "../../node_modules/cubing/src/cubing/alg/limits.ts", "../../node_modules/cubing/src/cubing/alg/AlgBuilder.ts", "../../node_modules/cubing/src/cubing/alg/debug.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/containers/Commutator.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/containers/Conjugate.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/LineComment.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Newline.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Pause.ts", "../../node_modules/cubing/src/cubing/alg/parseAlg.ts", "../../node_modules/cubing/src/cubing/alg/warnOnce.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/QuantumWithAmount.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Move.ts", "../../node_modules/cubing/src/cubing/alg/alg-nodes/containers/Grouping.ts", "../../node_modules/cubing/src/cubing/alg/is.ts", "../../node_modules/cubing/src/cubing/alg/traversal.ts", "../../node_modules/cubing/src/cubing/alg/simplify/options.ts", "../../node_modules/cubing/src/cubing/alg/simplify/append.ts", "../../node_modules/cubing/src/cubing/alg/simplify/simplify.ts", "../../node_modules/cubing/src/cubing/alg/Alg.ts", "../../node_modules/cubing/src/cubing/alg/example.ts", "../../node_modules/cubing/src/cubing/alg/keyboard.ts", "../../node_modules/cubing/src/cubing/alg/url.ts"],
  "sourcesContent": ["import type { Alg } from \"./Alg\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { AlgLeaf, AlgNode } from \"./alg-nodes/AlgNode\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeaf>;\n}\n\n// Common to `Alg` or `AlgNode` classes.\nexport abstract class AlgCommon<T extends Alg | AlgNode>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract override toString(): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(iterDir: IterationDirection): Generator<AlgLeaf>;\n}\n", "export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n", "export const MAX_INT = 0x7fffffff; // 2^31-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MIN_INT_DESCRIPTION = \"-2^31\";\n", "import { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\n\n/** @category Alg */\nexport class AlgBuilder {\n  #algNode: AlgNode[] = [];\n\n  push(u: AlgNode): void {\n    this.#algNode.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.childAlgNodes()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumAlgNodes(): number {\n    return this.#algNode.length;\n  }\n\n  // can be called multiple times, even if you push alg nodes inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#algNode);\n  }\n\n  reset(): void {\n    this.#algNode = [];\n  }\n}\n", "type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\": {\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n    }\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(\n  level: ReportingLevel,\n): void {\n  currentReportingLevel = level;\n}\n\nexport const algDebugGlobals: { caretNISSNotationEnabled: boolean } = {\n  caretNISSNotationEnabled: true,\n};\n\nexport function setAlgDebug(options: {\n  caretNISSNotationEnabled?: boolean;\n}): void {\n  if (\"caretNISSNotationEnabled\" in options) {\n    algDebugGlobals.caretNISSNotationEnabled =\n      !!options.caretNISSNotationEnabled;\n  }\n}\n", "import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(): string {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n}\n", "import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(): string {\n    return `[${this.A}: ${this.B}]`;\n  }\n}\n", "import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\n/** @category Alg Nodes */\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n\n  toString(): string {\n    return `//${this.#text}`;\n  }\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n", "import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Newline extends AlgCommon<Newline> {\n  toString(): string {\n    return \"\\n\";\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n}\n", "import type { Grouping } from \"..\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Pause extends AlgCommon<Pause> {\n  experimentalNISSGrouping?: Grouping; // TODO: tie this to the alg\n\n  toString(): string {\n    return \".\";\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n}\n", "import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport { algDebugGlobals } from \"./debug\";\nimport type { AlgNode } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst AMOUNT_REGEX = /^(\\d+)?('?)/;\nconst MOVE_START_REGEX = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nconst COMMENT_TEXT_REGEX = /^[^\\n]*/;\nconst SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport interface ParserIndexed {\n  startCharIndex: number;\n  endCharIndex: number;\n}\n\nexport type Parsed<T extends Alg | AlgNode> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | AlgNode>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | AlgNode>(from: T, to: T): T {\n  if (\"startCharIndex\" in from) {\n    (to as Parsed<T>).startCharIndex = (from as Parsed<T>).startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    (to as Parsed<T>).endCharIndex = (from as Parsed<T>).endCharIndex;\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n  #nissQueue: Grouping[] = [];\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const algNodes = Array.from(alg.childAlgNodes());\n    if (this.#nissQueue.length > 0) {\n      for (const nissGrouping of this.#nissQueue.reverse()) {\n        algNodes.push(nissGrouping);\n      }\n    }\n    const newAlg = new Alg(algNodes) as Parsed<Alg>;\n    const { startCharIndex, endCharIndex } = alg;\n    addCharIndices(newAlg, startCharIndex, endCharIndex);\n    return newAlg;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last alg node.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    mainLoop: while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumAlgNodes() === 0) {\n          algStartIdx = this.#idx;\n        }\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else if (MOVE_START_REGEX.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\"^\")) {\n        if (!algDebugGlobals.caretNISSNotationEnabled) {\n          throw new Error(\n            \"Alg contained a caret but caret NISS notation is not enabled.\",\n          );\n        }\n\n        this.mustConsumeNext(\"(\");\n        const alg = this.parseAlgWithStopping([\")\"]);\n        this.popNext();\n\n        const grouping = new Grouping(alg, -1);\n        const placeholder = new Pause();\n\n        grouping.experimentalNISSPlaceholder = placeholder;\n        placeholder.experimentalNISSGrouping = grouping;\n\n        this.#nissQueue.push(grouping);\n        algBuilder.push(placeholder);\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        switch (separator) {\n          case \":\": {\n            algBuilder.push(\n              addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n\n            // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n            continue mainLoop;\n          }\n          case \",\": {\n            algBuilder.push(\n              addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n\n            // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n            continue mainLoop;\n          }\n          default:\n            throw new Error(\"unexpected parsing error\");\n        }\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(QUANTUM_MOVE_REGEX);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n", "const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n", "import type { Repeatable } from \"../common\";\nimport { IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { AlgLeaf } from \"./AlgNode\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `AlgNode amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<AlgLeaf> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n", "import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parseAlg\";\nimport { warnOnce } from \"../../warnOnce\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<AlgLeaf> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  override toString(): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = `${String(this.#outerLayer)}-${s}`;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\n/** @category Alg Nodes */\nexport class Move extends AlgCommon<Move> {\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        // rome-ignore lint/nursery/noConstructorReturn: https://github.com/rome/tools/issues/4005\n        return Move.fromString(args[0]);\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among alg nodes.\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<AlgLeaf> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  toString(): string {\n    if (this.family === \"_SLASH_\") {\n      return \"/\"; // TODO: validate no amount\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n        Math.abs(this.amount) +\n        (this.amount < 0 ? \"-\" : \"+\")\n      ); // TODO\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n        (absAmount === 1 ? \"\" : absAmount) +\n        (this.amount < 0 ? \"--\" : \"++\")\n      ); // TODO\n    }\n\n    return (\n      this.#quantumWithAmount.quantum.toString() +\n      this.#quantumWithAmount.suffix()\n    );\n  }\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n", "import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport type { Pause } from \"../leaves/Pause\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(grouping: Grouping): string | null {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumChildAlgNodes() === 2) {\n      const [U, D] = quantumAlg.childAlgNodes();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\",\n          );\n        }\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\n/** @category Alg Nodes */\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n  experimentalNISSPlaceholder?: Pause; // TODO: tie this to the alg\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  toString(): string {\n    return (\n      square1TupleFormatterInstance.format(this) ??\n      `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n", "import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./alg-nodes\";\n\nexport function experimentalIs(\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\nexport function experimentalIsAlgNode(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n", "import type { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\nimport type { Comparable } from \"./common\";\n\nfunction dispatch<DataDown, DataAlgUp, DataAlgNodeUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataAlgNodeUp>,\n  algNode: AlgNode,\n  dataDown: DataDown,\n): DataAlgNodeUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (algNode.is(Grouping)) {\n    return t.traverseGrouping(algNode as Grouping, dataDown);\n  }\n  if (algNode.is(Move)) {\n    return t.traverseMove(algNode as Move, dataDown);\n  }\n  if (algNode.is(Commutator)) {\n    return t.traverseCommutator(algNode as Commutator, dataDown);\n  }\n  if (algNode.is(Conjugate)) {\n    return t.traverseConjugate(algNode as Conjugate, dataDown);\n  }\n  if (algNode.is(Pause)) {\n    return t.traversePause(algNode as Pause, dataDown);\n  }\n  if (algNode.is(Newline)) {\n    return t.traverseNewline(algNode as Newline, dataDown);\n  }\n  if (algNode.is(LineComment)) {\n    return t.traverseLineComment(algNode as LineComment, dataDown);\n  }\n  throw new Error(\"unknown AlgNode\");\n}\n\nfunction mustBeAlgNode(t: Comparable): AlgNode {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as AlgNode;\n  }\n  throw new Error(\"internal error: expected AlgNode\"); // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseAlgNode(algNode: AlgNode, dataDown: DataDown): DataAlgNodeUp {\n    return dispatch(this, algNode, dataDown);\n  }\n\n  public traverseIntoAlgNode(algNode: AlgNode, dataDown: DataDown): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataAlgNodeUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traversePause(\n    pause: Pause,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataAlgNodeUp> {\n  public override traverseAlgNode(algNode: AlgNode): DataAlgNodeUp {\n    return dispatch<unknown, DataAlgUp, DataAlgNodeUp>(\n      this,\n      algNode,\n      undefined,\n    );\n  }\n\n  public override traverseIntoAlgNode(algNode: AlgNode): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode) as any);\n  }\n\n  public abstract override traverseAlg(alg: Alg): DataAlgUp;\n  public abstract override traverseGrouping(grouping: Grouping): DataAlgNodeUp;\n  public abstract override traverseMove(move: Move): DataAlgNodeUp;\n  public abstract override traverseCommutator(\n    commutator: Commutator,\n  ): DataAlgNodeUp;\n  public abstract override traverseConjugate(\n    conjugate: Conjugate,\n  ): DataAlgNodeUp;\n  public abstract override traversePause(pause: Pause): DataAlgNodeUp;\n  public abstract override traverseNewline(newline: Newline): DataAlgNodeUp;\n  public abstract override traverseLineComment(\n    comment: LineComment,\n  ): DataAlgNodeUp;\n}\n\nexport function functionFromTraversal<\n  DataDown,\n  DataAlgUp,\n  ConstructorArgs extends unknown[],\n>(\n  traversalConstructor: {\n    new (...args: ConstructorArgs): TraversalDownUp<DataDown, DataAlgUp, any>;\n  },\n  constructorArgs?: ConstructorArgs,\n): undefined extends DataDown\n  ? (alg: Alg) => DataAlgUp\n  : (alg: Alg, v: DataDown) => DataAlgUp {\n  const instance = new traversalConstructor(\n    ...(constructorArgs ?? ([] as any)),\n  );\n  return instance.traverseAlg.bind(instance);\n}\n", "import type { Move, QuantumMove } from \"../alg-nodes\";\n\n// TODO: enums?\nconst DEFAULT_DIRECTIONAL = \"any-direction\";\nDEFAULT_DIRECTIONAL;\nexport type QuantumDirectionalCancellation =\n  | typeof DEFAULT_DIRECTIONAL // Cancel any moves with the same quantum.\n  | \"same-direction\" // Cancel two quantums when have non-zero amounts of the same sign (positive/negative). An amount of 0 always counts as the same direction as any other amount.\n  | \"none\";\n\n// Example input: `R7' . R6' . R5' . R6` on a cube.\nexport type ModWrap =\n  | \"none\" // R7' . R6' . R5' . R6\n  | \"gravity\" // R . R2' . R' . R2\n  | \"canonical-centered\" // R . R2 . R' . R2\n  | \"canonical-positive\" // R . R2 . R3 . R2\n  | \"preserve-sign\"; // R3' . R2' . R' . R2\n\nexport interface AppendCancelOptions {\n  directional?: QuantumDirectionalCancellation;\n  puzzleSpecificModWrap?: ModWrap; // Default depends on `directional`\n}\n\n// TODO: preserve single moves even when amount is 0?\nexport interface AppendOptions {\n  cancel?: boolean | AppendCancelOptions; // Set to `true` to use future-proof defaults.\n  // Takes precedence over the direct `puzzleSpecificSimplifyOptions` field.\n  puzzleLoader?: {\n    puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  };\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n}\n\nexport class AppendOptionsHelper {\n  constructor(private config: AppendOptions = {}) {}\n\n  cancelQuantum(): QuantumDirectionalCancellation {\n    const { cancel } = this.config;\n    if (cancel === true) {\n      return DEFAULT_DIRECTIONAL;\n    }\n    if (cancel === false) {\n      return \"none\";\n    }\n    return cancel?.directional ?? \"none\";\n  }\n\n  cancelAny() {\n    return this.config.cancel && this.cancelQuantum() !== \"none\";\n  }\n\n  cancelPuzzleSpecificModWrap(): ModWrap {\n    const { cancel } = this.config;\n    if (cancel === true || cancel === false) {\n      return \"canonical-centered\";\n    }\n    if (cancel?.puzzleSpecificModWrap) {\n      return cancel?.puzzleSpecificModWrap;\n    }\n    return cancel?.directional === \"same-direction\"\n      ? \"preserve-sign\"\n      : \"canonical-centered\";\n  }\n\n  puzzleSpecificSimplifyOptions(): PuzzleSpecificSimplifyOptions | undefined {\n    return (\n      this.config.puzzleLoader?.puzzleSpecificSimplifyOptions ??\n      this.config.puzzleSpecificSimplifyOptions\n    );\n  }\n}\n\nexport interface SimplifyOptions extends AppendOptions {\n  depth?: number | null; // TODO: test\n}\n\nexport interface PuzzleSpecificAxisSimplifyInfo {\n  // All moves on the same axis *must* commute.\n  areQuantumMovesSameAxis: (\n    quantumMove1: QuantumMove,\n    quantumMove2: QuantumMove,\n  ) => boolean;\n  simplifySameAxisMoves: (moves: Move[], quantumMod: boolean) => Move[];\n}\n\n// TOOD: allow \"normal\" \"twisty\" puzzles to hardcode axis concepts without hardcoding too much in `Alg` that's not relevant to all puzzles.\nexport interface PuzzleSpecificSimplifyOptions {\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  // TODO: implement cancellation for non-axis commuting moves (e.g. Megaminx: `BL R BL'` \u2192 `R`)\n  // // Commutation is not transitive. For example, on Megaminx: BR and BL both commute with F, but not with each other.\n  // doQuantumMovesCommute?: (\n  //   quantumMove1: QuantumMove,\n  //   quantumMove2: QuantumMove,\n  // ) => boolean;\n  axis?: PuzzleSpecificAxisSimplifyInfo;\n}\n", "import { Alg } from \"../Alg\";\nimport type { AlgNode } from \"../alg-nodes\";\nimport type { AlgLeaf } from \"../alg-nodes/AlgNode\";\nimport { Move } from \"../alg-nodes/leaves/Move\";\nimport { AppendOptions, AppendOptionsHelper } from \"./options\";\n\nfunction areSameDirection(direction: -1 | 1, move2: Move): boolean {\n  // This multiplication has two properties:\n  // - If either amount is 0, returns true.\n  // - Otherwise, the signs have to match.\n  return direction * Math.sign(move2.amount) >= 0;\n}\n\nfunction offsetMod(x: number, positiveMod: number, offset: number): number {\n  return ((((x - offset) % positiveMod) + positiveMod) % positiveMod) + offset;\n}\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  addedMove: Move,\n  options?: AppendOptions,\n): Alg {\n  const optionsHelper = new AppendOptionsHelper(options);\n\n  const outputPrefix: AlgNode[] = Array.from(alg.childAlgNodes());\n  let outputSuffix: Move[] = [addedMove];\n  function output() {\n    return new Alg([...outputPrefix, ...outputSuffix]); // TODO: What's the most efficient way to do this?\n  }\n\n  function modMove(move: Move): Move {\n    if (optionsHelper.cancelPuzzleSpecificModWrap() === \"none\") {\n      return move;\n    }\n    const quantumMoveOrder =\n      optionsHelper.puzzleSpecificSimplifyOptions()?.quantumMoveOrder;\n    if (!quantumMoveOrder) {\n      return move;\n    }\n    const mod = quantumMoveOrder(addedMove.quantum)!; // TODO: throw if `undefined`?\n    let offset: number;\n    switch (optionsHelper.cancelPuzzleSpecificModWrap()) {\n      case \"gravity\": {\n        offset = -Math.floor((mod - (move.amount < 0 ? 0 : 1)) / 2); // TODO: dedup this calculation for the most common path?\n        break;\n      }\n      case \"canonical-centered\": {\n        offset = -Math.floor((mod - 1) / 2); // TODO: dedup this calculation for the most common path?\n        break;\n      }\n      case \"canonical-positive\": {\n        offset = 0;\n        break;\n      }\n      case \"preserve-sign\": {\n        offset = move.amount < 0 ? 1 - mod : 0;\n        break;\n      }\n      default: {\n        throw new Error(\"Unknown mod wrap\");\n      }\n    }\n    const offsetAmount = offsetMod(move.amount, mod, offset);\n    return move.modified({ amount: offsetAmount });\n  }\n\n  if (optionsHelper.cancelAny()) {\n    let canCancelMoveBasedOnQuantum: (move: Move) => boolean;\n    const axis = optionsHelper.puzzleSpecificSimplifyOptions()?.axis;\n    if (axis) {\n      canCancelMoveBasedOnQuantum = (move: Move): boolean =>\n        axis.areQuantumMovesSameAxis(addedMove.quantum, move.quantum);\n    } else {\n      const newMoveQuantumString = addedMove.quantum.toString();\n      canCancelMoveBasedOnQuantum = (move: Move): boolean =>\n        move.quantum.toString() === newMoveQuantumString;\n    }\n\n    const sameDirectionOnly =\n      optionsHelper.cancelQuantum() === \"same-direction\";\n\n    const quantumDirections = new Map<string, 1 | 0 | -1>();\n    quantumDirections.set(\n      addedMove.quantum.toString(),\n      Math.sign(addedMove.amount) as -1 | 0 | 1,\n    );\n    let i: number;\n    for (i = outputPrefix.length - 1; i >= 0; i--) {\n      const move = outputPrefix[i].as(Move);\n      if (!move) {\n        break;\n      }\n      if (!canCancelMoveBasedOnQuantum(move)) {\n        break;\n      }\n      const quantumKey = move.quantum.toString();\n      if (sameDirectionOnly) {\n        const existingQuantumDirectionOnAxis =\n          quantumDirections.get(quantumKey);\n        if (\n          existingQuantumDirectionOnAxis && // Short-circuits, but that's actually okay here.\n          !areSameDirection(existingQuantumDirectionOnAxis, move)\n        ) {\n          break;\n        }\n        quantumDirections.set(quantumKey, Math.sign(move.amount) as -1 | 0 | 1);\n      }\n    }\n    const suffix = [...(outputPrefix.splice(i + 1) as Move[]), addedMove];\n\n    if (axis) {\n      // TODO: pass down quantum mod\n      outputSuffix = axis.simplifySameAxisMoves(\n        suffix,\n        optionsHelper.cancelPuzzleSpecificModWrap() !== \"none\",\n      );\n    } else {\n      const amount = suffix.reduce(\n        (sum: number, move: Move) => sum + move.amount,\n        0,\n      );\n      if (quantumDirections.size !== 1) {\n        throw new Error(\n          \"Internal error: multiple quantums when one was expected\",\n        );\n      }\n      outputSuffix = [new Move(addedMove.quantum, amount)];\n    }\n  }\n  outputSuffix = outputSuffix\n    .map((m) => modMove(m))\n    .filter((move: Move) => move.amount !== 0);\n  return output();\n}\n\nexport function experimentalAppendNode(\n  alg: Alg,\n  leaf: AlgLeaf,\n  options: AppendOptions,\n): Alg {\n  const maybeMove = leaf.as(Move);\n  if (maybeMove) {\n    return experimentalAppendMove(alg, maybeMove, options);\n  } else {\n    return new Alg([...alg.childAlgNodes(), leaf]);\n  }\n}\n", "import { Alg } from \"../Alg\";\nimport type { AlgNode } from \"../alg-nodes/AlgNode\";\nimport { Commutator } from \"../alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"../alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"../alg-nodes/containers/Grouping\";\nimport type { LineComment } from \"../alg-nodes/leaves/LineComment\";\nimport { Move } from \"../alg-nodes/leaves/Move\";\nimport type { Newline } from \"../alg-nodes/leaves/Newline\";\nimport { Pause } from \"../alg-nodes/leaves/Pause\";\nimport { functionFromTraversal, TraversalDownUp } from \"../traversal\";\nimport { experimentalAppendNode } from \"./append\";\nimport { AppendOptionsHelper, SimplifyOptions } from \"./options\";\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<AlgNode>> {\n  #newPlaceholderAssociationsMap?: Map<Grouping, Pause>;\n  #newPlaceholderAssociations(): Map<Grouping, Pause> {\n    return (this.#newPlaceholderAssociationsMap ??= new Map<Grouping, Pause>());\n  }\n\n  // TODO: avoid allocations?\n  #descendOptions(options: SimplifyOptions): SimplifyOptions {\n    return {\n      ...options,\n      depth: options.depth ? options.depth - 1 : null,\n    };\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield* alg.childAlgNodes();\n      return;\n    }\n\n    let output: AlgNode[] = [];\n\n    const newOptions: SimplifyOptions = this.#descendOptions(options); // TODO: avoid allocations?\n    for (const algNode of alg.childAlgNodes()) {\n      for (const traversedNode of this.traverseAlgNode(algNode, newOptions)) {\n        output = Array.from(\n          experimentalAppendNode(\n            new Alg(output),\n            traversedNode,\n            newOptions,\n          ).childAlgNodes(),\n        );\n      }\n    }\n\n    // TODO: try to use `yield* output[Symbol.iterator]();`?\n    for (const newAlgNode of output) {\n      yield newAlgNode;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    if (grouping.amount === 0) {\n      // TODO: Are we okay with throwing away nested comments?\n      return;\n    }\n    const newGrouping = new Grouping(\n      this.traverseAlg(grouping.alg, this.#descendOptions(options)),\n      grouping.amount,\n    );\n    if (newGrouping.alg.experimentalIsEmpty()) {\n      return;\n    }\n\n    const newPlaceholder = this.#newPlaceholderAssociations().get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n\n    yield newGrouping;\n  }\n\n  public *traverseMove(\n    move: Move,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield move;\n  }\n\n  #doChildrenCommute(A: Alg, B: Alg, options: SimplifyOptions): boolean {\n    if (\n      A.experimentalNumChildAlgNodes() === 1 &&\n      B.experimentalNumChildAlgNodes() === 1\n    ) {\n      // Handle the special case where each side has been reduced to a single move.\n      const aMove = Array.from(A.childAlgNodes())[0]?.as(Move);\n      const bMove = Array.from(B.childAlgNodes())[0]?.as(Move);\n      if (!(aMove && bMove)) {\n        return false;\n      }\n      if (bMove.quantum.isIdentical(aMove.quantum)) {\n        return true;\n      }\n      const appendOptionsHelper = new AppendOptionsHelper(options); // TODO: avoid re-allocating every time.\n      if (\n        appendOptionsHelper\n          .puzzleSpecificSimplifyOptions()\n          ?.axis?.areQuantumMovesSameAxis(aMove.quantum, bMove.quantum)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newCommutator = new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n    if (\n      newCommutator.A.experimentalIsEmpty() ||\n      newCommutator.B.experimentalIsEmpty() ||\n      newCommutator.A.isIdentical(newCommutator.B) ||\n      newCommutator.A.isIdentical(newCommutator.B.invert()) ||\n      this.#doChildrenCommute(newCommutator.A, newCommutator.B, options)\n    ) {\n      return;\n    }\n    yield newCommutator;\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newConjugate = new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n    if (newConjugate.B.experimentalIsEmpty()) {\n      return;\n    }\n    if (\n      newConjugate.A.experimentalIsEmpty() ||\n      newConjugate.A.isIdentical(newConjugate.B) ||\n      newConjugate.A.isIdentical(newConjugate.B.invert()) ||\n      this.#doChildrenCommute(newConjugate.A, newConjugate.B, options)\n    ) {\n      yield* conjugate.B.childAlgNodes();\n      return;\n    }\n    yield newConjugate;\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      this.#newPlaceholderAssociations().set(\n        pause.experimentalNISSGrouping,\n        newPause,\n      );\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield comment;\n  }\n}\n\nexport const simplify = functionFromTraversal(Simplify);\n", "// https://js.cubing.net/cubing/alg/\n\nimport { AlgCommon, Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsAlgNode } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parseAlg\";\nimport { simplify, SimplifyOptions } from \"./simplify\";\nimport { Grouping, Pause } from \"./alg-nodes\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport type { AlgLeaf, AlgNode } from \"./alg-nodes/AlgNode\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<AlgNode> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<AlgNode> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).childAlgNodes();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).childAlgNodes(); // TODO: something more direct?\n  }\n\n  const iter = input as Iterable<AlgNode>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw new Error(\"Invalid AlgNode\");\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * `Alg` is a class that encapsulates a structured alg. To create an `Alg` from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when the string input is user-provided.\n *\n * Once you have an `Alg`, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().experimentalSimplify({cancel: true}).invert().log()\n *\n * To convert an `Alg` to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n * @category Alg\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #algNodes: Iterable<AlgNode>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#algNodes = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const algNode of this.#algNodes) {\n      if (!experimentalIsAlgNode(algNode)) {\n        throw new Error(\"An alg can only contain alg nodes.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not taken into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#algNodes);\n    const l2 = Array.from(otherAsAlg.#algNodes);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#algNodes).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    for (const algNode of direct(this.#algNodes, iterDir)) {\n      yield* algNode.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#algNodes).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    for (const _ of this.#algNodes) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  /** @deprecated */\n  units(): Generator<AlgNode> {\n    return this.childAlgNodes();\n  }\n\n  *childAlgNodes(): Generator<AlgNode> {\n    for (const algNode of this.#algNodes) {\n      yield algNode;\n    }\n  }\n\n  /** @deprecated */\n  experimentalNumUnits(): number {\n    return this.experimentalNumChildAlgNodes();\n  }\n\n  experimentalNumChildAlgNodes(): number {\n    return Array.from(this.#algNodes).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(): string {\n    let output = \"\";\n    let previousVisibleAlgNode: AlgNode | null = null;\n    for (const algNode of this.#algNodes) {\n      if (previousVisibleAlgNode) {\n        output += spaceBetween(previousVisibleAlgNode, algNode);\n      }\n      const nissGrouping = algNode.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString()})`;\n      } else if (algNode.as(Grouping)?.experimentalNISSPlaceholder) {\n        // do not serialize (rely on the placeholder instead)\n      } else {\n        output += algNode.toString();\n      }\n      previousVisibleAlgNode = algNode;\n    }\n    return output;\n  }\n\n  /**\n   * `experimentalSimplify` can perform several mostly-syntactic simplifications on an alg:\n   *\n   *     // Logs: R' U3\n   *     import { Alg } from \"cubing/alg\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({ cancel: true }).log()\n   *\n   * You can pass in a `PuzzleLoader` (currently only for 3x3x3) for puzzle-specific simplifications:\n   *\n   *     // Logs: R' U'\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({ cancel: true, puzzleLoader: cube3x3x3 }).log()\n   *\n   * You can also cancel only moves that are in the same direction:\n   *\n   *     // Logs: R R2' U'\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({\n   *       cancel: { directional: \"same-direction\" },\n   *       puzzleLoader: cube3x3x3\n   *     }).log()\n   *\n   * Additionally, you can specify how moves are \"wrapped\":\n   *\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *\n   *     function example(puzzleSpecificModWrap) {\n   *       alg.experimentalSimplify({\n   *         cancel: { puzzleSpecificModWrap },\n   *         puzzleLoader: cube3x3x3\n   *       }).log()\n   *     }\n   *\n   *     const alg = new Alg(\"R7' . R6' . R5' . R6\")\n   *     example(\"none\")               // R7' . R6' . R5' . R6\n   *     example(\"gravity\")            // R . R2' . R' . R2\n   *     example(\"canonical-centered\") // R . R2 . R' . R2\n   *     example(\"canonical-positive\") // R . R2 . R3 . R2\n   *     example(\"preserve-sign\")      // R3' . R2' . R' . R2\n   *\n   * Same-axis and simultaneous move canonicalization is not implemented yet:\n   *\n   *     // Logs: R L R\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R L R\").experimentalSimplify({ cancel: true, puzzleLoader: cube3x3x3 }).log()\n   */\n  experimentalSimplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n\n  /** @deprecated See {@link experimentalSimplify} */\n  simplify(options?: SimplifyOptions): Alg {\n    return this.experimentalSimplify(options);\n  }\n}\n\nfunction spaceBetween(u1: AlgNode, u2: AlgNode): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n", "// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n", "import { Pause } from \"./alg-nodes\";\nimport type { AlgLeaf } from \"./alg-nodes/AlgNode\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\n\nconst cubeKeyMapping: { [key: number]: AlgLeaf } = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n\n  192: new Pause(),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): AlgLeaf | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n", "import type { Alg } from \"./Alg\";\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nfunction serializeURLParam(a: Alg): string {\n  let escaped = a.toString();\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport interface AlgCubingNetOptions {\n  alg?: Alg;\n  setup?: Alg;\n  title?: string;\n  puzzle?:\n    | \"1x1x1\"\n    | \"2x2x2\"\n    | \"3x3x3\"\n    | \"4x4x4\"\n    | \"5x5x5\"\n    | \"6x6x6\"\n    | \"7x7x7\"\n    | \"8x8x8\"\n    | \"9x9x9\"\n    | \"10x10x10\"\n    | \"11x11x11\"\n    | \"12x12x12\"\n    | \"13x13x13\"\n    | \"14x14x14\"\n    | \"16x16x16\"\n    | \"17x17x17\";\n  stage?:\n    | \"full\"\n    | \"cross\"\n    | \"F2L\"\n    | \"LL\"\n    | \"OLL\"\n    | \"PLL\"\n    | \"CLS\"\n    | \"ELS\"\n    | \"L6E\"\n    | \"CMLL\"\n    | \"WV\"\n    | \"ZBLL\"\n    | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\";\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\";\n}\n\n// TODO: runtime validation?\n/** @deprecated */\nexport function experimentalAlgCubingNetLink(\n  options: AlgCubingNetOptions,\n): string {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error(\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if (\n      ![\n        \"1x1x1\",\n        \"2x2x2\",\n        \"3x3x3\",\n        \"4x4x4\",\n        \"5x5x5\",\n        \"6x6x6\",\n        \"7x7x7\",\n        \"8x8x8\",\n        \"9x9x9\",\n        \"10x10x10\",\n        \"11x11x11\",\n        \"12x12x12\",\n        \"13x13x13\",\n        \"14x14x14\",\n        \"16x16x16\",\n        \"17x17x17\",\n      ].includes(options.puzzle)\n    ) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if (\n      ![\n        \"full\",\n        \"cross\",\n        \"F2L\",\n        \"LL\",\n        \"OLL\",\n        \"PLL\",\n        \"CLS\",\n        \"ELS\",\n        \"L6E\",\n        \"CMLL\",\n        \"WV\",\n        \"ZBLL\",\n        \"void\",\n      ].includes(options.stage)\n    ) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if (![\"editor\", \"playback\", \"fullscreen\"].includes(options.view)) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if (\n      ![\n        \"moves\",\n        \"reconstruction\",\n        \"alg\",\n        \"reconstruction-end-with-setup\",\n      ].includes(options.type)\n    ) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n"],
  "mappings": "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",
  "names": ["writeAlgDebugField", "Comparable", "c", "AlgCommon", "toggleDirection", "iterationDirection", "flip", "direct", "g", "iterDir", "reverse", "directedGenerator", "direction", "reverseGenerator", "t", "MAX_INT", "MAX_INT_DESCRIPTION", "MIN_INT", "AlgBuilder", "_a", "__privateAdd", "_algNode", "u", "__privateGet", "alg", "Alg", "__privateSet", "algDebugGlobals", "Commutator", "_a", "AlgCommon", "aSource", "bSource", "__privateAdd", "_A", "_B", "__privateSet", "experimentalEnsureAlg", "__privateGet", "other", "otherAsCommutator", "iterDir", "depth", "Conjugate", "otherAsConjugate", "LineComment", "commentText", "_text", "otherAsLineComment", "_iterDir", "_depth", "Newline", "Pause", "parseIntWithEmptyFallback", "n", "emptyFallback", "AMOUNT_REGEX", "MOVE_START_REGEX", "QUANTUM_MOVE_REGEX", "COMMENT_TEXT_REGEX", "SQUARE1_PAIR_START_REGEX", "SQUARE1_PAIR_END_REGEX", "parseAlg", "s", "AlgParser", "parseMove", "parseQuantumMove", "addCharIndices", "startCharIndex", "endCharIndex", "parsedT", "transferCharIndex", "from", "to", "_input", "_idx", "_nissQueue", "input", "alg", "algNodes", "nissGrouping", "newAlg", "Alg", "move", "quantumMove", "stopBefore", "algStartIdx", "algEndIdx", "algBuilder", "AlgBuilder", "crowded", "mustNotBeCrowded", "idx", "mainLoop", "savedCharIndex", "sq1PairStartMatch", "topAmountString", "savedCharIndexD", "sq1PairEndMatch", "uMove", "Move", "QuantumMove", "dMove", "Grouping", "amount", "algDebugGlobals", "grouping", "placeholder", "A", "separator", "B", "text", "outerLayerStr", "innerLayerStr", "family", "hadEmptyAbsAmount", "suffix", "savedIdx", "absAmountStr", "primeStr", "regex", "arr", "next", "__privateWrapper", "expected", "warned", "warnOnce", "QuantumWithAmount", "quantum", "MIN_INT", "MAX_INT", "MAX_INT_DESCRIPTION", "absAmount", "newIterDir", "toggleDirection", "i", "Comparable", "innerLayer", "outerLayer", "_family", "_innerLayer", "_outerLayer", "modifications", "otherAsQuantumMove", "args", "_quantumWithAmount", "otherAsMove", "Square1TupleFormatter", "amounts", "quantumAlg", "U", "D", "square1TupleFormatterInstance", "algSource", "otherAsGrouping", "experimentalIs", "v", "c", "experimentalIsAlgNode", "dispatch", "algNode", "dataDown", "mustBeAlgNode", "TraversalDownUp", "TraversalUp", "functionFromTraversal", "traversalConstructor", "constructorArgs", "instance", "DEFAULT_DIRECTIONAL", "AppendOptionsHelper", "config", "cancel", "areSameDirection", "direction", "move2", "offsetMod", "x", "positiveMod", "offset", "experimentalAppendMove", "addedMove", "options", "optionsHelper", "outputPrefix", "outputSuffix", "output", "modMove", "quantumMoveOrder", "mod", "offsetAmount", "canCancelMoveBasedOnQuantum", "axis", "newMoveQuantumString", "sameDirectionOnly", "quantumDirections", "quantumKey", "existingQuantumDirectionOnAxis", "sum", "m", "experimentalAppendNode", "leaf", "maybeMove", "Simplify", "_newPlaceholderAssociations", "_descendOptions", "_doChildrenCommute", "_newPlaceholderAssociationsMap", "newOptions", "__privateMethod", "descendOptions_fn", "traversedNode", "newAlgNode", "newGrouping", "newPlaceholder", "newPlaceholderAssociations_fn", "_options", "commutator", "newCommutator", "doChildrenCommute_fn", "conjugate", "newConjugate", "pause", "newPause", "newline", "comment", "aMove", "bMove", "simplify", "toIterable", "iter", "_algNodes", "otherAsAlg", "l1", "l2", "reverse", "u", "direct", "_", "previousVisibleAlgNode", "spaceBetween", "u1", "u2", "Example", "cubeKeyMapping"]
}
