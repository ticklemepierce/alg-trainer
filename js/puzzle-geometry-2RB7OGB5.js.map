{
  "version": 3,
  "sources": ["../../node_modules/cubing/src/cubing/puzzle-geometry/FaceNameSwizzler.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/Options.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/Perm.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/PermOriSet.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/PGPuzzles.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/Quat.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/PlatonicGenerator.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/SchreierSims.ts", "../../node_modules/cubing/src/cubing/puzzle-geometry/PuzzleGeometry.ts"],
  "sourcesContent": ["// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(`Could not split ${s} into face names.`);\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /* same as above, but permit both to have v's on the end. */\n  public spinmatchv(userinput: string, longname: string): boolean {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1),\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n", "import type { Move } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move | null {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move | null {\n    return move;\n  }\n}\n", "import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper, private sw: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n", "// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n", "// Sits on top of a (possibly null) notation mapper, and\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n\n        // TODO: Figure out if `cubing/alg` should parse `R++` to a family of `R++`.\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n      if (move.family === \"x\" && Math.abs(move.amount) === 2) {\n        return new Move(\"ERv\", move.amount / 2);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"ERv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        move.amount * 2,\n      );\n    }\n    if (move.family === \"ILv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        -move.amount * 2,\n      );\n    }\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n", "import { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n}\n", "import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst pyraminxFamilyMap: Record<string, string> = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n};\nconst tetraminxFamilyMap: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\",\n};\n\nconst pyraminxFamilyMapWCA: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n};\n\nconst pyraminxExternalQuantumY = new QuantumMove(\"y\");\nconst pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  protected wcaHack: boolean = false;\n  map: Record<string, string> = pyraminxFamilyMap;\n\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount,\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class TetraminxNotationMapper extends PyraminxNotationMapper {\n  protected override wcaHack = true;\n\n  constructor(child: FaceNameSwizzler) {\n    super(child);\n    this.map = tetraminxFamilyMap;\n  }\n}\n", "import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst skewbFamilyMap: Record<string, string> = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\",\n};\n\n// TODO: combine using a similar table.\nconst skewbExternalQuantumX = new QuantumMove(\"x\");\nconst skewbInternalQuantumX = new QuantumMove(\"Rv\");\nconst skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nconst skewbExternalQuantumY = new QuantumMove(\"y\");\nconst skewbInternalQuantumY = new QuantumMove(\"Uv\");\nconst skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nconst skewbExternalQuantumZ = new QuantumMove(\"z\");\nconst skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nconst skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount,\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n    /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n    /*\n       *   See (1) above.\n       *\n    if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    // } else {\n    //   return null;\n    // }\n  }\n}\n", "import { parsePuzzleDescription, PuzzleDescription } from \"./PuzzleGeometry\";\n\nexport function parseOptions(argv: string[]): {\n  puzzleDescription: PuzzleDescription | null;\n  options: PuzzleGeometryOptions;\n} {\n  let argp = 0;\n  const options: PuzzleGeometryOptions = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]); // TODO: Validate input.\n      argp++;\n    } else {\n      throw new Error(`Bad option: ${option}`);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\n\ntype FaceName = string;\ntype OrientationDirection = [number, number, number];\nexport type FaceBasedOrientationDescription = [\n  [FaceName, OrientationDirection],\n  [FaceName, OrientationDirection],\n];\nexport type BaseFaceCount = 4 | 6 | 8 | 12 | 20;\nexport type FaceBasedOrientationDescriptionLookup = Record<\n  BaseFaceCount,\n  FaceBasedOrientationDescription\n>;\n\nfunction asstructured(v: any): any {\n  if (typeof v === \"string\") {\n    return JSON.parse(v);\n  }\n  return v;\n}\nfunction asboolean(v: any): boolean {\n  if (typeof v === \"string\") {\n    if (v === \"false\") {\n      return false;\n    }\n    return true;\n  } else {\n    return v ? true : false;\n  }\n}\n\nexport class PuzzleGeometryFullOptions {\n  verbosity: number = 0; // verbosity (console.log)\n\n  allMoves: boolean = false; // generate all slice moves in ksolve\n  outerBlockMoves: boolean; // generate outer block moves\n  vertexMoves: boolean = false; // generate vertex moves\n  addRotations: boolean = false; // add symmetry information to ksolve output\n  moveList: string[] | null = null; // move list to generate\n\n  fixedOrientation: boolean = false; // eliminate any orientations\n  fixedPieceType: null | \"e\" | \"v\" | \"f\" = null; // fix a piece?\n  orientCenters: boolean = false; // orient centers?\n\n  // TODO: Group these into a single object?\n  includeCornerOrbits: boolean = true; // include corner orbits\n  includeCenterOrbits: boolean = true; // include center orbits\n  includeEdgeOrbits: boolean = true; // include edge orbits\n  // Overrides the previous options.\n  excludeOrbits: string[] = []; // exclude these orbits\n  optimizeOrbits: boolean = false; // optimize PermOri\n\n  grayCorners: boolean = false; // make corner sets gray\n  grayCenters: boolean = false; // make center sets gray\n  grayEdges: boolean = false; // make edge sets gray\n\n  puzzleOrientation: FaceBasedOrientationDescription | null = null; // single puzzle orientation from options\n  puzzleOrientations: FaceBasedOrientationDescriptionLookup | null = null; // puzzle orientation override object from options // TODO: is this needed?\n\n  scrambleAmount: number = 0; // scramble?\n\n  constructor(options: PuzzleGeometryOptions = {}) {\n    Object.assign(this, options);\n  }\n}\n\nexport type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;\n\nexport function parsePGOptionList(optionlist?: any[]): PuzzleGeometryOptions {\n  const options: PuzzleGeometryOptions = {};\n  if (optionlist !== undefined) {\n    if (optionlist.length % 2 !== 0) {\n      throw new Error(\"Odd length in option list?\");\n    }\n    for (let i = 0; i < optionlist.length; i += 2) {\n      if (optionlist[i] === \"verbose\") {\n        options.verbosity = (options.verbosity ?? 0) + 1;\n      } else if (optionlist[i] === \"quiet\") {\n        options.verbosity = 0;\n      } else if (optionlist[i] === \"allmoves\") {\n        options.allMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"outerblockmoves\") {\n        options.outerBlockMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"vertexmoves\") {\n        options.vertexMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"rotations\") {\n        options.addRotations = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"cornersets\") {\n        options.includeCornerOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"centersets\") {\n        options.includeCenterOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"edgesets\") {\n        options.includeEdgeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"omit\") {\n        options.excludeOrbits = optionlist[i + 1];\n      } else if (optionlist[i] === \"graycorners\") {\n        options.grayCorners = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"graycenters\") {\n        options.grayCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"grayedges\") {\n        options.grayEdges = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"movelist\") {\n        options.moveList = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"killorientation\") {\n        options.fixedOrientation = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"optimize\") {\n        options.optimizeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"scramble\") {\n        options.scrambleAmount = optionlist[i + 1];\n      } else if (optionlist[i] === \"fix\") {\n        options.fixedPieceType = optionlist[i + 1];\n      } else if (optionlist[i] === \"orientcenters\") {\n        options.orientCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientation\") {\n        options.puzzleOrientation = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientations\") {\n        options.puzzleOrientations = asstructured(optionlist[i + 1]);\n      } else {\n        throw new Error(\n          `Bad option while processing option list ${optionlist[i]}`,\n        );\n      }\n    }\n  }\n  return options;\n}\n", "const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): bigint {\n  let r = BigInt(1);\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return `Perm[${this.p.join(\" \")}]`;\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(`(${incyc.join(\",\")})`);\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n", "import { Move } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\"; // TODO\nimport { NullMapper } from \"./notation-mapping\";\nimport type { NotationMapper } from \"./notation-mapping/NotationMapper\";\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class PGOrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): bigint {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n}\n\nlet lastGlobalDefinitionCounter = 0;\n\nexport function externalName(\n  mapper: NotationMapper,\n  moveString: string,\n): string {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\n\nexport class PGOrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    private orbitdefs: PGOrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: PGTransform[],\n    public isRotation: boolean[],\n    public forcenames: boolean[],\n  ) {}\n\n  public transformToKTransformationData(t: PGTransform): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public static transformToKTransformationData(\n    orbitnames: string[],\n    t: PGTransform,\n  ): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  private describeSet(s: number, r: string[], mapper: NotationMapper): void {\n    const n = this.orbitdefs[s].size;\n    const m = new Array(n);\n    for (let i = 0; i < n; i++) {\n      m[i] = [];\n    }\n    for (let i = 0; i < this.movenames.length; i++) {\n      if (this.isRotation[i]) {\n        continue;\n      }\n      let mvname = this.movenames[i];\n      if (!this.forcenames[i]) {\n        mvname = externalName(mapper, mvname);\n        if (mvname[mvname.length - 1] === \"'\") {\n          mvname = mvname.substring(0, mvname.length - 1);\n        }\n      }\n      const pd = this.moveops[i].orbits[s];\n      for (let j = 0; j < n; j++) {\n        if (pd.perm[j] !== j || pd.ori[j] !== 0) {\n          m[j].push(mvname);\n        }\n      }\n    }\n    for (let j = 0; j < n; j++) {\n      r.push(`# ${j + 1} ${m[j].join(\" \")}`);\n    }\n  }\n\n  public toKsolve(\n    name: string,\n    mapper: NotationMapper = new NullMapper(),\n  ): string[] {\n    const result = [];\n    result.push(`Name ${name}`);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`,\n      );\n      this.describeSet(i, result, mapper);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false,\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name = this.movenames[i];\n      if (!this.forcenames[i]) {\n        name = externalName(mapper, this.movenames[i]);\n      }\n      let doinv = false;\n      if (name[name.length - 1] === \"'\") {\n        doinv = true;\n        name = name.substring(0, name.length - 1);\n      }\n      result.push(`Move ${name}`);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j]\n            .inv()\n            .appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true,\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition {\n    const orbits: KPuzzleDefinition[\"orbits\"] = {};\n    const start: KPuzzleDefinition[\"startStateData\"] = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod,\n      };\n      const startTransformation = this.solved.orbits[i].toKPuzzle();\n      start[this.orbitnames[i]] = {\n        pieces: startTransformation.permutation,\n        orientation: startTransformation.orientation,\n      };\n    }\n    const moves: { [moveName: string]: any } = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.transformToKTransformationData(\n          this.moveops[i],\n        );\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      startStateData: start,\n      moves,\n    };\n  }\n\n  public optimize(): PGOrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: PGOrbitDef[] = [];\n    const newsolved: PGOrbit[] = [];\n    const newmoveops: PGOrbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      // don't consider rotations when optimizing, for what to keep\n      // but *do* consider rotations for unions.\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            if (!this.isRotation[j]) {\n              changed[k] = true;\n            }\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n      this.isRotation,\n      this.forcenames,\n    );\n  }\n\n  // replace the solved state with a new scrambled state.\n  public scramble(n: number): void {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  public getScrambleTransformation(n: number): PGTransform {\n    // don't let n be too tiny\n    if (n < 100) {\n      n = 100;\n    }\n    const pool: PGTransform[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n\n  public reassemblySize(): bigint {\n    let n = BigInt(1);\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class PGOrbit {\n  private static kcache: Record<string, number[]>[] = [];\n\n  public static e(n: number, mod: number): PGOrbit {\n    return new PGOrbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: PGOrbit): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: PGOrbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private zeroOris(): boolean {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public appendDefinition(\n    result: string[],\n    name: string,\n    useVS: boolean,\n    concise: boolean = true,\n  ): void {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_: number) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array<number>(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n\n  // TODO: return type\n  public toKPuzzle(): Record<string, number[]> {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!PGOrbit.kcache[n]) {\n        PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return PGOrbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n}\nexport class PGTransformBase {\n  constructor(public orbits: PGOrbit[]) {}\n  public internalMul(b: PGTransformBase): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  protected internalInv(): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: PGTransformBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected killOri(): this {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n}\nexport class PGTransform extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): PGTransform {\n    return new PGTransform(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): PGTransform {\n    if (n === 0) {\n      return this.e();\n    }\n    let t: PGTransform = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): PGTransform {\n    return new PGTransform(this.internalInv());\n  }\n\n  public e(): PGTransform {\n    return new PGTransform(\n      this.orbits.map((_: PGOrbit) => PGOrbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  private heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"0: canonseq 1\");\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(`${d}\": canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n", "export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  skewb: \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  helicopter: \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  dino: \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  pyramorphix: \"t e 0\",\n  mastermorphix: \"t e 0.346184634065199\",\n  pyraminx: \"t v 0.333333333333333 v 1.66666666666667\",\n  tetraminx: \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  megaminx: \"d f 0.7\",\n  gigaminx: \"d f 0.64 f 0.82\",\n  teraminx: \"d f 0.64 f 0.76 f 0.88\",\n  petaminx: \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  examinx: \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  zetaminx: \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  yottaminx: \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  pentultimate: \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  starminx: \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  chopasaurus: \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  FTO: \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  octastar: \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  icosamate: \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n", "/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n", "/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face: Quat[] = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n", "import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): bigint {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): bigint {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = BigInt(1);\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = BigInt(1);\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n", "import { Move, QuantumMove } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n  TetraminxNotationMapper,\n} from \"./notation-mapping\";\nimport {\n  BaseFaceCount,\n  FaceBasedOrientationDescription,\n  FaceBasedOrientationDescriptionLookup,\n  PuzzleGeometryFullOptions,\n  PuzzleGeometryOptions,\n} from \"./Options\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  externalName,\n  PGOrbit,\n  PGOrbitDef,\n  PGOrbitsDef,\n  PGTransform,\n  showcanon,\n  VisibleState,\n} from \"./PermOriSet\";\nimport { PGPuzzles, PuzzleDescriptionString, PuzzleName } from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, Quat } from \"./Quat\";\nimport { schreierSims } from \"./SchreierSims\";\n\nexport interface TextureMapper {\n  getuv(fn: number, threed: number[]): number[];\n}\n\nexport interface StickerDatSticker {\n  coords: number[];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n  face: number;\n  isDup?: boolean;\n}\n\nexport interface StickerDatFace {\n  coords: number[];\n  name: string;\n}\n\nexport type StickerDatAxis = {\n  coordinates: number[];\n  quantumMove: Move;\n  order: number;\n};\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): Move | null;\n  notationMapper: NotationMapper;\n  textureMapper: TextureMapper;\n}\n\n// you can fill these in to help with timing if you want\nfunction tstart(s: string): string {\n  return s;\n}\n\nfunction tend(_: string): void {}\n\nclass Face {\n  private coords: number[];\n  public length: number;\n  constructor(q: Quat[]) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n\n  get(off: number): Quat {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2],\n    );\n  }\n\n  centermass(): Quat {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n\n  rotate(q: Quat): Face {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n\n  rotateforward(): Face {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n}\n\nexport class FaceTree {\n  constructor(\n    private face: Quat[],\n    private left?: FaceTree,\n    private right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Face[], leftfirst: boolean): Face[] {\n    if (this.left === undefined) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport function expandfaces(rots: Quat[], faces: Face[]): Face[] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// Orientation conventions are specified here.  For each of the five platonic\n// solids, by face count, we have three lists of \"cubie names\" consisting of\n// a concatenation of face names.  For vertex (corner) and edge cubies, the\n// first face in the concatenated name is the one that will be marked.\n// For center orientations, the first face specifies which center we are\n// referring to, and the second face specifies the direction of the mark for\n// that face.\n\nconst orientationDefaults = {\n  4: {\n    v: [\"DFR\", \"DLF\", \"DRL\", \"FLR\"],\n    e: [\"FR\", \"LF\", \"DF\", \"DL\", \"RD\", \"RL\"],\n    c: [\"DF\", \"FD\", \"RL\", \"LR\"],\n  },\n  6: {\n    v: [\"URF\", \"UBR\", \"ULB\", \"UFL\", \"DFR\", \"DRB\", \"DBL\", \"DLF\"],\n    e: [\"UF\", \"UR\", \"UB\", \"UL\", \"DF\", \"DR\", \"DB\", \"DL\", \"FR\", \"FL\", \"BR\", \"BL\"],\n    c: [\"UB\", \"LU\", \"FU\", \"RU\", \"BU\", \"DF\"],\n  },\n  8: {\n    v: [\"UBBBRR\", \"URFL\", \"ULBLBB\", \"DBRBBBL\", \"DBLLF\", \"DFRBR\"],\n    e: [\n      \"UL\",\n      \"UBB\",\n      \"UR\",\n      \"BRD\",\n      \"BLD\",\n      \"FD\",\n      \"BRR\",\n      \"FR\",\n      \"FL\",\n      \"BLL\",\n      \"BLBB\",\n      \"BRBB\",\n    ],\n    c: [\"BBU\", \"LU\", \"RU\", \"BRD\", \"FD\", \"BLD\", \"DF\", \"UBB\"],\n  },\n  12: {\n    v: [\n      \"URF\",\n      \"UFL\",\n      \"ULBL\",\n      \"UBLBR\",\n      \"UBRR\",\n      \"DEBF\",\n      \"DBFI\",\n      \"DIA\",\n      \"DAC\",\n      \"DCE\",\n      \"LAI\",\n      \"ALF\",\n      \"FCA\",\n      \"CFR\",\n      \"REC\",\n      \"ERBR\",\n      \"BRBFE\",\n      \"BFBRBL\",\n      \"BLIBF\",\n      \"IBLL\",\n    ],\n    e: [\n      \"UF\",\n      \"UR\",\n      \"UBR\",\n      \"UBL\",\n      \"UL\",\n      \"ER\",\n      \"EBR\",\n      \"EBF\",\n      \"ED\",\n      \"EC\",\n      \"IBF\",\n      \"IBL\",\n      \"IL\",\n      \"IA\",\n      \"ID\",\n      \"AC\",\n      \"CF\",\n      \"FA\",\n      \"BFBR\",\n      \"BRBL\",\n      \"BLBF\",\n      \"CD\",\n      \"AD\",\n      \"AL\",\n      \"FL\",\n      \"FR\",\n      \"CR\",\n      \"BFD\",\n      \"BRR\",\n      \"BLL\",\n    ],\n    c: [\n      \"UF\",\n      \"FU\",\n      \"DBF\",\n      \"BFD\",\n      \"AD\",\n      \"CD\",\n      \"BRU\",\n      \"BLU\",\n      \"LA\",\n      \"RA\",\n      \"EBR\",\n      \"IBL\",\n    ],\n  },\n  20: {\n    v: [\n      \"FLPQU\",\n      \"FUGER\",\n      \"FRCAL\",\n      \"HCREI\",\n      \"ISBDH\",\n      \"JSIEG\",\n      \"BSJMK\",\n      \"MQPOK\",\n      \"ONDBK\",\n      \"NOPLA\",\n      \"UQMJG\",\n      \"DNACH\",\n    ],\n    e: [\n      \"FU\",\n      \"FL\",\n      \"FR\",\n      \"EG\",\n      \"ER\",\n      \"EI\",\n      \"SJ\",\n      \"SI\",\n      \"SB\",\n      \"KM\",\n      \"KB\",\n      \"KO\",\n      \"PQ\",\n      \"PO\",\n      \"PL\",\n      \"UG\",\n      \"JG\",\n      \"MQ\",\n      \"UQ\",\n      \"HC\",\n      \"HD\",\n      \"ND\",\n      \"NA\",\n      \"JM\",\n      \"CA\",\n      \"AL\",\n      \"CR\",\n      \"HI\",\n      \"DB\",\n      \"NO\",\n    ],\n    c: [\n      \"FU\",\n      \"UF\",\n      \"GE\",\n      \"EG\",\n      \"JS\",\n      \"SJ\",\n      \"MK\",\n      \"KM\",\n      \"QP\",\n      \"PQ\",\n      \"LA\",\n      \"AL\",\n      \"RC\",\n      \"CR\",\n      \"IH\",\n      \"HI\",\n      \"BD\",\n      \"DB\",\n      \"ON\",\n      \"NO\",\n    ],\n  },\n};\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): FaceBasedOrientationDescriptionLookup {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n  };\n}\n\nfunction findelement(a: Quat[][], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getPG3DNamedPuzzles(): {\n  [s: string]: PuzzleDescriptionString;\n} {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getPuzzleDescriptionString(\n  puzzleName: PuzzleName,\n): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport const PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"] as const;\nexport type PuzzleBaseShape = typeof PUZZLE_BASE_SHAPES[number];\n\nexport const PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"] as const;\nexport type PuzzleCutType = typeof PUZZLE_CUT_TYPES[number];\n\nexport type PuzzleCutDescription = { cutType: PuzzleCutType; distance: number };\nexport type PuzzleDescription = {\n  shape: PuzzleBaseShape;\n  cuts: PuzzleCutDescription[];\n};\n\nexport function parsePuzzleDescription(\n  s: PuzzleDescriptionString,\n): PuzzleDescription | null {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (\n    shape !== \"o\" &&\n    shape !== \"c\" &&\n    shape !== \"i\" &&\n    shape !== \"d\" &&\n    shape !== \"t\"\n  ) {\n    return null;\n  }\n  const cuts: PuzzleCutDescription[] = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i] as PuzzleCutType,\n      distance: parseFloat(a[i + 1]),\n    });\n  }\n  return { shape, cuts };\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: PuzzleGeometryOptions = {},\n): PuzzleGeometry {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true } as PuzzleGeometryOptions, options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options?: PuzzleGeometryOptions,\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(\n  geo: any,\n  bits: number[],\n  slices: number,\n): [string, boolean] {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0] as string;\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = `${movenameFamily}v`;\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw new Error(\n      `We only support slice and outer block moves right now. ${bits}`,\n    );\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: [Quat[], string][]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (\n        s.substr(at).startsWith(facename[1]) &&\n        facename[1].length > currentMatch.length\n      ) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(`Could not split ${s} into face names.`);\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Face, maxdist: number): number[] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\n\n/** @category PuzzleGeometry */\nexport class PuzzleGeometry {\n  private rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  private baseplanes: Quat[]; // planes, corresponding to faces\n  private facenames: [Quat[], string][]; // face names\n  private faceplanes: [Quat, string][]; // face planes\n  private edgenames: [Quat, string][]; // edge names\n  private vertexnames: [Quat, string][]; // vertexnames\n  private geonormals: [Quat, string, string][]; // all geometric directions, with names and types\n  private moveplanes: Quat[]; // the planes that split moves\n  private moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: Quat[][]; // the move planes, in parallel sets\n  private moveplanenormals: Quat[]; // one move plane\n  public movesetorders: number[]; // the order of rotations for each move set\n  public movesetgeos: [string, string, string, string, number][]; // geometric feature information for move sets\n  private basefaces: Face[]; // polytope faces before cuts\n  private faces: Face[]; // all the stickers\n  private facecentermass: Quat[]; // center of mass of all faces\n  private baseFaceCount: BaseFaceCount; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public shortedge: number; // number of stickers per face\n  private markedface: number[]; // given a bitmap of faces, identify the marked one\n  public cubies: number[][]; // the cubies\n  private vertexdistance: number; // vertex distance\n  private edgedistance: number; // edge distance\n  private facetocubie: number[]; // map a face to a cubie index\n  private facetoord: number[]; // map a face to a cubie ord\n  private moverotations: Quat[][]; // move rotations\n  private facelisthash: Map<string, number[]>; // face list by key\n  private cubiesetnames: string[]; // cubie set names\n  private cubieords: number[]; // the size of each orbit\n  private cubiesetnums: number[];\n  private cubieordnums: number[];\n  private orbitoris: number[]; // the orientation size of each orbit\n  private cubievaluemap: number[]; // the map for identical cubies\n  private cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  public parsedmovelist: [\n    string | undefined,\n    number,\n    number,\n    number,\n    boolean,\n    number,\n  ][]; // parsed move list\n\n  private duplicatedFaces: number[] = []; // which faces are duplicated\n  private duplicatedCubies: number[] = []; // which cubies are duplicated\n  private fixedCubie: number = -1; // fixed cubie, if any\n  private net: string[][] = [];\n  private colors: any = [];\n  private swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  private addNotationMapper: string = \"\";\n  private setReidOrder: boolean = false;\n\n  private options: PuzzleGeometryFullOptions;\n\n  constructor(\n    public puzzleDescription: PuzzleDescription,\n    options: PuzzleGeometryOptions,\n  ) {\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n\n  public create(puzzleDescription: PuzzleDescription): void {\n    const { shape, cuts } = puzzleDescription;\n\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": {\n        g = cube();\n        break;\n      }\n      case \"o\": {\n        g = octahedron();\n        break;\n      }\n      case \"i\": {\n        g = icosahedron();\n        break;\n      }\n      case \"t\": {\n        g = tetrahedron();\n        break;\n      }\n      case \"d\": {\n        g = dodecahedron();\n        break;\n      }\n      default:\n        throw new Error(`Bad shape argument: ${shape}`);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(`# Rotations: ${this.rotations.length}`);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length as BaseFaceCount;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(`# Base planes: ${baseplanes.length}`);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(`# Face vertices: ${baseface.length}`);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(`# Boundary is ${boundary}`);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0]\n      .sum(firstface[1])\n      .smul(0.5)\n      .dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\": {\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        }\n        case \"v\": {\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        }\n        case \"e\": {\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        }\n        default:\n          throw new Error(`Bad cut argument: ${cut.cutType}`);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n! where\n    //   n planes meet at a vertex.  We set names by choosing the marked face\n    //   first, and going counterclockwise around.\n    //\n    const facenames: [Quat[], string][] = [];\n    const faceplanes: [Quat, string][] = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (const el of a) {\n        if (el[0].dist(p) < eps) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: string[] = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    const oridata = orientationDefaults[this.baseFaceCount];\n    const markedface = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      markedface[1 << i] = i;\n    }\n    // FIXME  eliminate the duplications below\n    {\n      const oriprefs = oridata[\"v\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"e\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"c\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        const bits = (1 << fn[0]) | (1 << this.baseFaceCount);\n        markedface[bits] = fn[1];\n      }\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(`Bad length in edge names ${edgenames[i]}`);\n      }\n      const f1 = edgenames[i][1];\n      const f2 = edgenames[i][2];\n      let c1 = faceindextoname[f1];\n      const c2 = faceindextoname[f2];\n      const bits = (1 << f1) | (1 << f2);\n      if (markedface[bits] === f1) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; proper orientation.\n    for (let i = 0; i < vertexnames.length; i++) {\n      let bits = 0;\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        bits |= 1 << facenametoindex[vertexnames[i][j][0]];\n      }\n      const fi = markedface[bits];\n      let st = -1;\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (fi === facenametoindex[vertexnames[i][j][0]]) {\n          st = j;\n        }\n      }\n      if (st < 0) {\n        throw new Error(\n          \"Internal error; couldn't find face name when fixing corners\",\n        );\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    this.markedface = markedface;\n    if (this.options.verbosity > 1) {\n      console.log(`# Face names: ${facenames.map((_) => _[1]).join(\" \")}`);\n      // TODO\n      console.log(`# Edge names: ${edgenames.map((_) => _[1]).join(\" \")}`);\n      // TODO\n      console.log(`# Vertex names: ${vertexnames.map((_) => _[1]).join(\" \")}`);\n    }\n    const geonormals: [Quat, string, string][] = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        `# Distances: face ${1} edge ${this.edgedistance} vertex ${\n          this.vertexdistance\n        }`,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(`# Faces is now ${faces.length}`);\n    }\n    this.stickersperface = faces.length;\n    // the faces when rotated don't preserve the vertex order at this\n    // point.  to improve 3d rendering speed, we would like to preserve\n    // vertex order on rotation.  First, let's see what rotations preserve\n    // the base face; these are the ones we want to work with.\n    const simplerot: Quat[] = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array<boolean>(faces.length);\n    const sortme: [number, Quat, number][] = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm.dist(sortme[kk][1]) < eps) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(`# Short edge is ${this.shortedge}`);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!(sawedge || sawvertex)) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  private keyface(face: Face): string {\n    return this.keyface2(face.centermass());\n  }\n\n  private keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + (t % 47));\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s =\n            s +\n            sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) +\n            sfcc(33 + 47 + (Math.floor((t - 47) / 47) % 47)) +\n            sfcc(33 + (t % 47));\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  private keyface3(face: Face): number[] {\n    const cm = face.centermass();\n    // take a face and figure out the sides of each move plane\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n\n  private findface(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key)!;\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)![i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  private project2d(\n    facen: number,\n    edgen: number,\n    targvec: Quat[],\n  ): [Quat, Quat, Quat] {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    const t1 = tstart(\"allstickers\");\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(`# Total stickers is now ${this.faces.length}`);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(`# Move plane sets: ${sizes}`);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos: [string, string, string, string, number][] = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (\n          moveplanesets[0].length === 2 &&\n          moveplanesets[0][0].a === 0.333333333333333 &&\n          moveplanesets[0][1].a === 1.66666666666667\n        ) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const facelisthash = new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s)!;\n        arr.push(i);\n        //  If we find a core cubie, split it up into multiple cubies,\n        //  because ksolve doesn't handle orientations that are not\n        //  cyclic, and the rotation group of the core is not cyclic.\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = `${s} ${suff}`;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubies: ${facelisthash.size}`);\n    }\n    const cubies: number[][] = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        // this is the original \"cubie\" of a split core; we ignore it.\n        continue;\n      }\n      //  Sort the faces around each corner so they are counterclockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      if (facelist.length > 1) {\n        const cm = facelist.map((_: number) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1000) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        // set the orientations by finding the marked face and putting it first.\n        let bits = 0;\n        for (const f of facelist) {\n          bits |= 1 << Math.floor(f / this.stickersperface);\n        }\n        const markedface = this.markedface[bits]!;\n        let mini = -1;\n        for (let i = 0; i < facelist.length; i++) {\n          if (Math.floor(facelist[i] / this.stickersperface) === markedface) {\n            mini = i;\n          }\n        }\n        if (mini < 0) {\n          throw new Error(\"Could not find marked face in list\");\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      if (seen[i]) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq =\n              this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (\n      this.setReidOrder &&\n      4 <= this.stickersperface &&\n      this.stickersperface <= 9\n    ) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << (cubie[j].charCodeAt(k) - 65);\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |=\n              1 <<\n              (this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65);\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.options.fixedPieceType === \"v\" && cubies[i].length > 2) ||\n          (this.options.fixedPieceType === \"e\" && cubies[i].length === 2) ||\n          (this.options.fixedPieceType === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          `Could not find a cubie of type ${this.options.fixedPieceType} to fix.`,\n        );\n      }\n    }\n    // show the orbits\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubie orbit sizes ${cubieords}`);\n    }\n    tend(t1);\n  }\n\n  public unswizzle(mv: Move): Move | null {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  private stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(`Bad move passed ${mv}`);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = `-${amountstr.substring(1)}`;\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(\n    move: Move,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw new Error(`Bad move ${move.family}`);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(`Bad grip in move ${move.family}`);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        // big assumption here!  if outerlayer not specified, but inner\n        // layer is (like 2U), we use the case of the family (upper vs\n        // lower) to decide if it should be a slice turn or a wide turn.\n        if (grip <= \"Z\") {\n          // uppercase; slice move\n          loslice = hislice;\n        } else {\n          // lowercase; wide move\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\n        `Bad slice spec ${loslice} ${hislice} vs ${this.moveplanesets[msi].length}`,\n      );\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    return [undefined, msi, loslice, hislice, firstgrip, move.amount];\n  }\n\n  private parsemove(\n    mv: string,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    const t1 = tstart(\"genperms\");\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    //\n    //  We also rotate the vertices of the face to enforce the orientation\n    //  preferences for the oriented center stickers.\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          const center = this.basefaces[i].centermass();\n          if (center.dist(this.facecentermass[kk]) < eps) {\n            const bits = (1 << i) | (1 << this.baseFaceCount);\n            const towards = this.markedface[bits];\n            const normal = this.baseplanes[towards].makenormal();\n            let hiv = -1;\n            let hii = -1;\n            for (let ii = 0; ii < this.faces[kk].length; ii++) {\n              const pt = this.faces[kk].get(ii);\n              const t = normal.dot(pt.sub(center));\n              if (t > hiv) {\n                hiv = t;\n                hii = ii;\n              }\n            }\n            // if two pts have the same distance, prefer the second\n            const hii2 = (hii + 1) % this.faces[kk].length;\n            if (\n              Math.abs(normal.dot(this.faces[kk].get(hii2).sub(center)) - hiv) <\n              eps\n            ) {\n              hii = hii2;\n            }\n            // remake the face to preserve orientations\n            if (hii !== 0) {\n              const qs = [];\n              for (let ii = 0; ii < this.faces[kk].length; ii++) {\n                qs.push(this.faces[kk].get((ii + hii) % this.faces[kk].length));\n              }\n              this.faces[kk] = new Face(qs);\n            }\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.options.orientCenters &&\n          (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            this.facecentermass[i].dist(\n              this.basefaces[this.getfaceindex(i)].centermass(),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        // b.length === 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.options.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k],\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist: [\n        string | undefined,\n        number,\n        number,\n        number,\n        boolean,\n        number,\n      ][] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n\n  private getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  private getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    let r: any[] = [];\n    if (this.parsedmovelist !== undefined) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    // TODO\n    return r;\n  }\n\n  private graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 &&\n        (this.options.grayCenters || !this.options.includeCenterOrbits)) ||\n      (ori === 2 &&\n        (this.options.grayEdges || !this.options.includeEdgeOrbits)) ||\n      (ori > 2 &&\n        (this.options.grayCorners || !this.options.includeCornerOrbits))\n    );\n  }\n\n  private skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.options.includeCenterOrbits) ||\n      (ori === 2 && !this.options.includeEdgeOrbits) ||\n      (ori > 2 && !this.options.includeCornerOrbits)\n    );\n  }\n\n  private skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  private header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = `M_${externalName(this.notationMapper, os.movenames[i])}`;\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      if (doinv) {\n        r.push(`${movename}:=${os.moveops[i].toPerm().inv().toGap()};`);\n      } else {\n        r.push(`${movename}:=${os.moveops[i].toPerm().toGap()};`);\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      `ip:=[${ip\n        .map((_) => `[${_.map((__) => __ + 1).join(\",\")}]`)\n        .join(\",\")}];`,\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\"): string {\n    const od = this.getOrbitsDef(false);\n    return (\n      this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\")\n    );\n  }\n\n  public getKPuzzleDefinition(\n    fortwisty: boolean = true,\n    includemoves: boolean = true,\n  ): KPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    (internalDefinition as any).experimentalPuzzleDescription =\n      this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): PGTransform {\n    const moveorbits: PGOrbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  private omitSet(name: string): boolean {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private diffmvsets(a: any[], b: any[], slices: number, neg: boolean) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (\n            a[i][0] + b[j][1] === slices &&\n            a[i][1] + b[j][0] === slices &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        } else {\n          if (\n            a[i][0] === b[j][0] &&\n            a[i][1] === b[j][1] &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: This is only public for testing; can we make it private again?\n  public getOrbitsDef(\n    fortwisty: boolean,\n    includemoves: boolean = true,\n  ): PGOrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames: string[] = [];\n    const setdefs: PGOrbitDef[] = [];\n    // if both a movelist and rotations are needed, don't add rotations\n    // that do not preserve the movelist.\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    const hasrotation = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const slices = this.moveplanesets[k].length;\n      // if the move set includes a rotation around this axis, don't add any more\n      let sawone = false;\n      const moveset = mps[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        if (moveset[i][0] === 0 && moveset[i][1] === slices) {\n          sawone = true;\n        }\n      }\n      hasrotation[k] = sawone;\n    }\n    if (\n      this.options.addRotations &&\n      (this.options.moveList || this.options.fixedPieceType !== null)\n    ) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        // if the move set includes a rotation around this axis, don't add any more\n        if (hasrotation[k]) {\n          addrot[k] = 3;\n          continue;\n        }\n        // does a rotation around k preserve the move set?\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (\n              cmp.length !== mps[k].length ||\n              this.moveplanesets[k].length !==\n                this.moveplanesets[found].length ||\n              this.diffmvsets(\n                cmp,\n                mps[k],\n                this.moveplanesets[found].length,\n                neg,\n              )\n            ) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0 && !hasrotation[k]) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (\n            moveset[i][0] === moveset[j][0] &&\n            moveset[i][1] === moveset[j][1]\n          ) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieords[i],\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: PGOrbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const movenames: string[] = [];\n    const forcenames: boolean[] = [];\n    const moves: PGTransform[] = [];\n    const isrots: boolean[] = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          // did these movebits come from a specified move?\n          // if they did, we need to use that name.\n          let nameoverride: string | undefined;\n          let inverted = false;\n          if (this.parsedmovelist !== undefined) {\n            for (const parsedmove of this.parsedmovelist) {\n              if (parsedmove[1] !== k) {\n                continue;\n              }\n              let r = [];\n              if (parsedmove[4]) {\n                r = [parsedmove[2], parsedmove[3]];\n              } else {\n                r = [slices - parsedmove[3], slices - parsedmove[2]];\n              }\n              if (r[0] === movebits[0] && r[1] === movebits[1]) {\n                nameoverride = parsedmove[0];\n                inverted = !parsedmove[4];\n              }\n            }\n          }\n          if (nameoverride) {\n            movenames.push(nameoverride);\n            forcenames.push(true);\n          } else {\n            const mna = getmovename(movesetgeo, movebits, slices);\n            inverted = mna[1];\n            const movename = mna[0];\n            if (moveset[i + 1] === 1) {\n              movenames.push(movename);\n            } else {\n              movenames.push(movename + moveset[i + 1]);\n            }\n            forcenames.push(false);\n          }\n          isrots.push(movebits[0] === 0 && movebits[1] === slices);\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesbyslice[k],\n            setmoves,\n            this.movesetorders[k],\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n      isrots,\n      forcenames,\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n\n  public getScramble(n: number = 0): KTransformationData {\n    const od = this.getOrbitsDef(false);\n    return od.transformToKTransformationData(od.getScrambleTransformation(n));\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  private getOrientationRotation(desiredRotation: any[]): Quat {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(`Could not find feature ${feature1name}`);\n    }\n    if (!feature2) {\n      throw new Error(`Could not find feature ${feature2name}`);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  private getInitial3DRotation(): Quat {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription: FaceBasedOrientationDescription | null = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n\n  private generate2dmapping(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n    twodshrink: number = 0.92,\n  ): (fn: number, q: Quat) => number[] {\n    // generate a mapping to use for 2D for textures, svg\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: Record<string, Quat[]> = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(`Could not find first face name ${f0}`);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c,\n        ];\n      }\n    };\n    return mappt2d;\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return `<polygon id=\"${id}\" class=\"sticker\" style=\"fill: ${color}\" points=\"${pts\n        .map((p) => `${p[0]} ${p[1]}`)\n        .join(\" \")}\"/>\\n`;\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(`<title>${this.facenames[j][1]}</title>\\n`);\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = `${this.cubiesetnames[cubiesetnum]}-l${cubieord}-o${cubieori}`;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = `${this.cubiesetnames[cubiesetnum]}-l${cubieord}-o${jj}`;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html = `<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n<style type=\"text/css\"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\\n${svg.join(\n      \"\",\n    )}</svg>`;\n    return html;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(options?: { stickerColors?: string[] }): StickerDat {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist: number = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum,\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order,\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order,\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1.0);\n    const g = (function () {\n      const irot = rot.invrot();\n      return function (facenum: number, coords: number[]): number[] {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist,\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g },\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n\n  public textForTwizzleExplorer(): string {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n\n  writeSchreierSims(tw: (s: string) => void) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n}\n\nexport class PGNotation {\n  private orbitNames: string[];\n  constructor(private pg: PuzzleGeometry, od: PGOrbitsDef) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformationData | null {\n    const mv = this.pg.parseMove(move);\n    // if a move list subset is defined, don't return moves outside the subset.\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (\n          parsedmove[1] === mv[1] &&\n          parsedmove[2] === mv[2] &&\n          parsedmove[3] === mv[3] &&\n          parsedmove[4] === mv[4]\n        ) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n}\n"],
  "mappings": "2EAIO,IAAMA,GAAN,KAAuB,CAG5B,YAAmBC,EAAqBC,EAA0B,CAA/C,KAAA,UAAAD,EAFnB,KAAO,WAAsB,GAC7B,KAAO,UAAsB,CAAC,EAExBC,IACF,KAAK,UAAYA,GAEnB,QAASC,EAAI,EAAG,KAAK,YAAcA,EAAIF,EAAU,OAAQE,IACvD,QAASC,EAAI,EAAG,KAAK,YAAcA,EAAIH,EAAU,OAAQG,IACnDD,IAAMC,GAAKH,EAAUE,CAAA,EAAG,WAAWF,EAAUG,CAAA,CAAE,IACjD,KAAK,WAAa,GAI1B,CAEO,aAAaC,EAAuB,CACzC,KAAK,UAAYA,CACnB,CAIO,iBAAiBC,EAAqB,CAC3C,IAAMC,EAAI,CAAC,EACPC,EAAK,EACT,KAAOA,EAAKF,EAAE,QAAQ,CAChBE,EAAK,GAAKA,EAAKF,EAAE,QAAUA,EAAEE,CAAA,IAAQ,KACvCA,IAEF,IAAIC,EAAe,GACnB,QAASN,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAEvCG,EAAE,OAAOE,CAAE,EAAE,WAAW,KAAK,UAAUL,CAAA,CAAE,IACxCM,EAAe,GACd,KAAK,UAAUN,CAAA,EAAG,OAAS,KAAK,UAAUM,CAAA,EAAc,UAE1DA,EAAeN,GAGnB,GAAIM,GAAgB,EAClBF,EAAE,KAAKE,CAAY,EACnBD,GAAM,KAAK,UAAUC,CAAA,EAAc,WAEnC,OAAM,IAAI,MAAM,mBAAmBH,oBAAoB,CAE3D,CACA,OAAOC,CACT,CAGO,kBAAkBG,EAAwB,CAC/C,IAAIC,EAAM,GACJJ,EAAI,CAAC,EACX,QAAS,EAAI,EAAG,EAAIG,EAAK,OAAQ,IAC/BH,EAAE,KAAKI,CAAG,EACVJ,EAAE,KAAK,KAAK,UAAUG,EAAK,CAAA,CAAA,CAAG,EACzB,KAAK,aACRC,EAAM,KAGV,OAAOJ,EAAE,KAAK,EAAE,CAClB,CA8BO,UAAUK,EAAmBC,EAA2B,CAE7D,GAAID,IAAcC,EAChB,MAAO,GAET,GAAI,CACF,IAAMC,EAAK,KAAK,iBAAiBF,CAAS,EACpCG,EAAK,KAAK,iBAAiBF,CAAQ,EAMzC,GAAIC,EAAG,SAAWC,EAAG,QAAUD,EAAG,OAAS,EACzC,MAAO,GAET,QAASX,EAAI,EAAGA,EAAIW,EAAG,OAAQX,IAAK,CAClC,QAASC,EAAI,EAAGA,EAAID,EAAGC,IACrB,GAAIU,EAAGX,CAAA,IAAOW,EAAGV,CAAA,EACf,MAAO,GAGX,IAAIY,EAAQ,GACZ,QAASZ,EAAI,EAAGA,EAAIW,EAAG,OAAQX,IAC7B,GAAIU,EAAGX,CAAA,IAAOY,EAAGX,CAAA,EAAI,CACnBY,EAAQ,GACR,KACF,CAEF,GAAI,CAACA,EACH,MAAO,EAEX,CACA,MAAO,EACT,MAAA,CACE,MAAO,EACT,CACF,CAGO,WAAWJ,EAAmBC,EAA2B,CAC9D,OAAID,EAAU,SAAS,GAAG,GAAKC,EAAS,SAAS,GAAG,EAC3C,KAAK,UACVD,EAAU,MAAM,EAAGA,EAAU,OAAS,CAAC,EACvCC,EAAS,MAAM,EAAGA,EAAS,OAAS,CAAC,CACvC,EAEO,KAAK,UAAUD,EAAWC,CAAQ,CAE7C,CAEO,UAAUP,EAAmB,EAC7BA,EAAE,SAAS,GAAG,GAAKA,EAAE,SAAS,GAAG,IAAMA,EAAE,CAAA,GAAM,MAClDA,EAAIA,EAAE,MAAM,EAAGA,EAAE,OAAS,CAAC,GAE7B,IAAMW,EAAgBX,EAAE,YAAY,EACpC,QAASH,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAAK,CAC9C,IAAMe,EAAI,KAAK,UAAUf,CAAA,EACzB,GAAI,KAAK,UAAUc,EAAeC,CAAC,EACjC,OAAOA,CAEX,CACA,OAAOZ,CACT,CACF,EC5Jaa,GAAN,KAA2C,CACzC,mBAAmBC,EAAyB,CACjD,OAAOA,CACT,CAEO,mBAAmBA,EAAyB,CACjD,OAAOA,CACT,CACF,ECPaC,GAAN,KAAkD,CACvD,YAAoBC,EAA+BC,EAAsB,CAArD,KAAA,MAAAD,EAA+B,KAAA,GAAAC,CAAuB,CAEnE,mBAAmBH,EAAyB,CACjD,OACEA,EAAK,SAAW,KAChBA,EAAK,aAAe,QACpBA,EAAK,aAAe,OAEb,IAAII,EACT,IAAIC,EAAY,OAAQL,EAAK,WAAYA,EAAK,UAAU,EACxDA,EAAK,MACP,EAEU,KAAK,MAAM,mBAAmBA,CAAI,CAGhD,CAGO,mBAAmBA,EAAyB,CACjD,IAAIM,EAAMN,EAAK,OAIf,OAHIM,EAAI,OAAS,GAAKA,EAAIA,EAAI,OAAS,CAAA,IAAO,MAC5CA,EAAMA,EAAI,UAAU,EAAGA,EAAI,OAAS,CAAC,GAEnC,KAAK,GAAG,UAAUA,EAAK,MAAM,EACxB,IAAIF,EACT,IAAIC,EAAY,IAAKL,EAAK,WAAYA,EAAK,UAAU,EACrDA,EAAK,MACP,EAEK,KAAK,MAAM,mBAAmBA,CAAI,CAC3C,CACF,EC9BaO,GAAN,KAAmD,CACxD,YACSC,EACAC,EACP,CAFO,KAAA,cAAAD,EACA,KAAA,cAAAC,CACN,CAGI,cACLC,EACAC,EACAC,EACQ,CACR,IAAIC,EAAS,IACRH,EAAK,SAAS,GAAG,GAAKA,EAAK,SAAS,GAAG,IAAMA,GAAQ,MACxDG,EAASH,EAAK,MAAMA,EAAK,OAAS,CAAC,EACnCA,EAAOA,EAAK,MAAM,EAAGA,EAAK,OAAS,CAAC,GAEtC,IAAMI,EAAQJ,EAAK,YAAY,EAC3BK,EAAc,GAClB,OAAIL,IAASI,IACXC,EAAc,GACdL,EAAOI,GAETJ,EAAOE,EAAE,kBAAkBD,EAAE,iBAAiBD,CAAI,CAAC,EAC/CK,IACFL,EAAOA,EAAK,YAAY,GAEnBA,EAAOG,CAChB,CAEO,QAAQb,EAAYW,EAAqBC,EAA2B,CACzE,IAAMF,EAAOV,EAAK,OACZgB,EAAQ,KAAK,cAAcN,EAAMC,EAAGC,CAAC,EAC3C,OAAIF,IAASM,EACJhB,EAEA,IAAII,EACT,IAAIC,EAAYW,EAAOhB,EAAK,WAAYA,EAAK,UAAU,EACvDA,EAAK,MACP,CAEJ,CAEO,mBAAmBA,EAAkB,CAE1C,OADU,KAAK,QAAQA,EAAM,KAAK,cAAe,KAAK,aAAa,CAErE,CAEO,mBAAmBA,EAAkB,CAC1C,OAAO,KAAK,QAAQA,EAAM,KAAK,cAAe,KAAK,aAAa,CAClE,CACF,ECpDaiB,GAAN,KAAiE,CACtE,YAAoBf,EAAuB,CAAvB,KAAA,MAAAA,CAAwB,CAErC,mBAAmBF,EAAyB,CACjD,GAAIA,EAAK,aAAe,QAAaA,EAAK,aAAe,OAAW,CAClE,GAAI,KAAK,IAAIA,EAAK,MAAM,IAAM,EAAG,CAC/B,GAAIA,EAAK,SAAW,MAClB,OAAO,IAAII,EAAK,IAAIC,EAAY,IAAK,EAAG,CAAC,EAAG,GAAKL,EAAK,MAAM,EAC9D,GAAWA,EAAK,SAAW,MACzB,OAAO,IAAII,EAAK,IAAIC,EAAY,IAAK,EAAG,CAAC,EAAG,EAAIL,EAAK,MAAM,EAC7D,GAAWA,EAAK,SAAW,MACzB,OAAO,IAAII,EAAK,IAAIC,EAAY,IAAK,EAAG,CAAC,EAAG,GAAKL,EAAK,MAAM,EAC9D,GAAWA,EAAK,SAAW,MACzB,OAAO,IAAII,EAAK,IAAIC,EAAY,IAAK,EAAG,CAAC,EAAG,EAAIL,EAAK,MAAM,EAI7D,GAAIA,EAAK,SAAW,cAClB,OAAO,IAAII,EAAK,IAAIC,EAAY,IAAK,EAAG,CAAC,EAAG,GAAKL,EAAK,MAAM,EAC9D,GAAWA,EAAK,SAAW,cACzB,OAAO,IAAII,EAAK,IAAIC,EAAY,IAAK,EAAG,CAAC,EAAG,GAAKL,EAAK,MAAM,CAEhE,CACA,GAAIA,EAAK,SAAW,IAClB,OAAO,IAAII,EAAK,KAAMJ,EAAK,MAAM,EAEnC,GAAIA,EAAK,SAAW,KAAO,KAAK,IAAIA,EAAK,MAAM,IAAM,EACnD,OAAO,IAAII,EAAK,MAAOJ,EAAK,OAAS,CAAC,CAE1C,CACA,OAAO,KAAK,MAAM,mBAAmBA,CAAI,CAC3C,CAGO,mBAAmBA,EAAyB,CACjD,OAAIA,EAAK,SAAW,OAAS,KAAK,IAAIA,EAAK,MAAM,IAAM,EAC9C,IAAII,EACT,IAAIC,EAAY,IAAKL,EAAK,WAAYA,EAAK,UAAU,EACrDA,EAAK,OAAS,CAChB,EAEEA,EAAK,SAAW,OAAS,KAAK,IAAIA,EAAK,MAAM,IAAM,EAC9C,IAAII,EACT,IAAIC,EAAY,IAAKL,EAAK,WAAYA,EAAK,UAAU,EACrD,CAACA,EAAK,OAAS,CACjB,EAEEA,EAAK,SAAW,KACX,IAAII,EACT,IAAIC,EAAY,IAAKL,EAAK,WAAYA,EAAK,UAAU,EACrDA,EAAK,MACP,EAEEA,EAAK,SAAW,KACX,IAAII,EAAK,IAAK,CAACJ,EAAK,MAAM,EAE5B,KAAK,MAAM,mBAAmBA,CAAI,CAC3C,CACF,EC7DakB,GAAN,KAAgD,CACrD,YAAmBC,EAAgB,CAAhB,KAAA,OAAAA,CAAiB,CAE7B,mBAAmBnB,EAAkB,CAC1C,IAAMU,EAAOV,EAAK,OAClB,OAAMA,EAAK,YAAcA,EAAK,aACxBU,IAAS,IACXV,EAAO,IAAII,EAAK,KAAMJ,EAAK,MAAM,EACxBU,IAAS,IAClBV,EAAO,IAAII,EAAK,KAAMJ,EAAK,MAAM,EACxBU,IAAS,MAClBV,EAAO,IAAII,EAAK,KAAMJ,EAAK,MAAM,IAE9B,KAAK,OAAS,KAAO,IACpBU,IAAS,IACXV,EAAO,IAAII,EACT,IAAIC,EAAY,KAAM,KAAK,OAAS,GAAK,CAAC,EAC1CL,EAAK,MACP,EACSU,IAAS,IAClBV,EAAO,IAAII,EACT,IAAIC,EAAY,KAAM,KAAK,OAAS,GAAK,CAAC,EAC1CL,EAAK,MACP,EACSU,IAAS,MAClBV,EAAO,IAAII,EACT,IAAIC,EAAY,KAAM,KAAK,OAAS,GAAK,CAAC,EAC1CL,EAAK,MACP,IAGA,KAAK,OAAS,IACZU,IAAS,IACXV,EAAO,IAAII,EACT,IAAIC,EAAY,IAAK,KAAK,OAAS,EAAG,CAAC,EACvCL,EAAK,MACP,EACSU,IAAS,IAClBV,EAAO,IAAII,EACT,IAAIC,EAAY,IAAK,KAAK,OAAS,EAAG,CAAC,EACvCL,EAAK,MACP,EACSU,IAAS,MAClBV,EAAO,IAAII,EACT,IAAIC,EAAY,IAAK,KAAK,OAAS,EAAG,CAAC,EACvCL,EAAK,MACP,KAICA,CACT,CAGO,mBAAmBA,EAAkB,CAC1C,IAAMU,EAAOV,EAAK,OAClB,GAAI,EAAEA,EAAK,YAAcA,EAAK,YAAa,CACzC,GAAIU,IAAS,KACX,OAAO,IAAIN,EAAK,IAAKJ,EAAK,MAAM,EAClC,GAAWU,IAAS,KAClB,OAAO,IAAIN,EAAK,IAAKJ,EAAK,MAAM,EAClC,GAAWU,IAAS,KAClB,OAAO,IAAIN,EAAK,IAAKJ,EAAK,MAAM,EAClC,GAAWU,IAAS,KAClB,OAAO,IAAIN,EAAK,IAAK,CAACJ,EAAK,MAAM,EACnC,GAAWU,IAAS,KAClB,OAAO,IAAIN,EAAK,IAAK,CAACJ,EAAK,MAAM,EACnC,GAAWU,IAAS,KAClB,OAAO,IAAIN,EAAK,IAAK,CAACJ,EAAK,MAAM,CAErC,CACA,OAAOA,CACT,CACF,ECxEMoB,GAA4C,CAChD,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,GAAI,OACJ,GAAI,OACJ,GAAI,OACJ,GAAI,OACJ,EAAG,IACH,EAAG,IACH,GAAI,IACJ,GAAI,GACN,EACMC,GAA6C,CACjD,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,GAAI,OACJ,GAAI,OACJ,GAAI,OACJ,GAAI,OACJ,EAAG,IACH,EAAG,IACH,GAAI,IACJ,GAAI,IACJ,EAAG,IACH,EAAG,IACH,GAAI,IACJ,GAAI,GACN,EAEMC,GAA+C,CACnD,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,KACL,EAEMC,GAA2B,IAAIlB,EAAY,GAAG,EAC9CmB,GAA2B,IAAInB,EAAY,IAAI,EAExCoB,GAAN,KAAuD,CAI5D,YAAoBvB,EAAyB,CAAzB,KAAA,MAAAA,EAHpB,KAAU,QAAmB,GAC7B,KAAA,IAA8BkB,EAEgB,CAEvC,mBAAmBpB,EAAyB,CACjD,GAAI,KAAK,SAAWA,EAAK,aAAe,GAAKA,EAAK,aAAe,KAAM,CACrE,IAAM0B,EAAeJ,GAAqBtB,EAAK,MAAA,EAC/C,GAAI0B,EACF,OAAO,IAAItB,EACT,IAAIC,EAAYqB,EAAc1B,EAAK,WAAYA,EAAK,UAAU,EAC9DA,EAAK,MACP,CAEJ,CACA,IAAM2B,EAAY,KAAK,IAAI3B,EAAK,MAAA,EAEhC,OAAI2B,EACK,IAAIvB,EACT,IAAIC,EAAYsB,EAAW3B,EAAK,WAAYA,EAAK,UAAU,EAC3DA,EAAK,MACP,EACSuB,GAAyB,YAAYvB,EAAK,OAAO,EACnD,IAAII,EAAKoB,GAA0B,CAACxB,EAAK,MAAM,EAE/C,IAEX,CAGO,mBAAmBA,EAAyB,CACjD,GAAI,KAAK,SAAWA,EAAK,aAAe,GAAKA,EAAK,aAAe,MAC/D,OAAW,CAAC4B,EAAUC,CAAQ,IAAK,OAAO,QAAQP,EAAoB,EACpE,GAAI,KAAK,MAAM,UAAUtB,EAAK,OAAQ6B,CAAQ,EAC5C,OAAO,IAAIzB,EACT,IAAIC,EAAYuB,EAAU5B,EAAK,WAAYA,EAAK,UAAU,EAC1DA,EAAK,MACP,EAIN,OAAW,CAAC4B,EAAUC,CAAQ,IAAK,OAAO,QAAQ,KAAK,GAAG,EACxD,GAAI,KAAK,MAAM,UAAU7B,EAAK,OAAQ6B,CAAQ,EAC5C,OAAO,IAAIzB,EACT,IAAIC,EAAYuB,EAAU5B,EAAK,WAAYA,EAAK,UAAU,EAC1DA,EAAK,MACP,EAGJ,OAAIwB,GAAyB,YAAYxB,EAAK,OAAO,EAC5C,IAAII,EAAKmB,GAA0B,CAACvB,EAAK,MAAM,EAE/C,IAEX,CACF,EAEa8B,GAAN,cAAsCL,EAAuB,CAGlE,YAAYvB,EAAyB,CACnC,MAAMA,CAAK,EAHb,KAAmB,QAAU,GAI3B,KAAK,IAAMmB,EACb,CACF,ECpHMU,GAAyC,CAC7C,EAAG,MACH,GAAI,MACJ,EAAG,MACH,GAAI,MACJ,EAAG,MACH,EAAG,MACH,EAAG,MACH,EAAG,MACH,GAAI,OACJ,IAAK,OACL,GAAI,OACJ,IAAK,OACL,GAAI,OACJ,GAAI,OACJ,GAAI,OACJ,GAAI,MACN,EAGMC,GAAwB,IAAI3B,EAAY,GAAG,EAC3C4B,GAAwB,IAAI5B,EAAY,IAAI,EAC5C6B,GAA6B,IAAI7B,EAAY,IAAI,EACjD8B,GAAwB,IAAI9B,EAAY,GAAG,EAC3C+B,GAAwB,IAAI/B,EAAY,IAAI,EAC5CgC,GAA6B,IAAIhC,EAAY,IAAI,EACjDiC,GAAwB,IAAIjC,EAAY,GAAG,EAC3CkC,GAAwB,IAAIlC,EAAY,IAAI,EAC5CmC,GAA6B,IAAInC,EAAY,IAAI,EAE1CoC,GAAN,KAAoD,CACzD,YAAoBvC,EAAyB,CAAzB,KAAA,MAAAA,CAA0B,CAEvC,mBAAmBF,EAAyB,CACjD,GAAIA,EAAK,YAAcA,EAAK,WAC1B,OAAO,KAET,IAAM2B,EAAYI,GAAe/B,EAAK,MAAA,EACtC,OAAI2B,EACK,IAAIvB,EACT,IAAIC,EAAYsB,EAAW3B,EAAK,WAAYA,EAAK,UAAU,EAC3DA,EAAK,MACP,EAEEgC,GAAsB,YAAYhC,EAAK,OAAO,EACzC,IAAII,EAAK6B,GAAuBjC,EAAK,MAAM,EAEhDmC,GAAsB,YAAYnC,EAAK,OAAO,EACzC,IAAII,EAAKgC,GAAuBpC,EAAK,MAAM,EAEhDsC,GAAsB,YAAYtC,EAAK,OAAO,EACzC,IAAII,EAAKmC,GAAuBvC,EAAK,MAAM,EAE7C,IAYT,CAGO,mBAAmBA,EAAyB,CACjD,OAAW,CAAC4B,EAAUC,CAAQ,IAAK,OAAO,QAAQE,EAAc,EAC9D,GAAI,KAAK,MAAM,WAAW/B,EAAK,OAAQ6B,CAAQ,EAC7C,OAAO,IAAIzB,EACT,IAAIC,EAAYuB,EAAU5B,EAAK,WAAYA,EAAK,UAAU,EAC1DA,EAAK,MACP,EAGJ,OAAIiC,GAAsB,YAAYjC,EAAK,OAAO,EACzC,IAAII,EAAK4B,GAAuBhC,EAAK,MAAM,EAEhDkC,GAA2B,YAAYlC,EAAK,OAAO,EAC9C,IAAII,EAAK4B,GAAuB,CAAChC,EAAK,MAAM,EAEjDoC,GAAsB,YAAYpC,EAAK,OAAO,EACzC,IAAII,EAAK+B,GAAuBnC,EAAK,MAAM,EAEhDqC,GAA2B,YAAYrC,EAAK,OAAO,EAC9C,IAAII,EAAK+B,GAAuB,CAACnC,EAAK,MAAM,EAEjDuC,GAAsB,YAAYvC,EAAK,OAAO,EACzC,IAAII,EAAKkC,GAAuBtC,EAAK,MAAM,EAEhDwC,GAA2B,YAAYxC,EAAK,OAAO,EAC9C,IAAII,EAAKkC,GAAuB,CAACtC,EAAK,MAAM,EAE9C,IAcT,CACF,EChHO,SAAS0C,GAAaC,EAG3B,CACA,IAAIC,EAAO,EACLC,EAAiC,CAAC,EACxC,KAAOD,EAAOD,EAAK,QAAUA,EAAKC,CAAA,EAAM,CAAA,IAAO,KAAK,CAClD,IAAME,EAASH,EAAKC,GAAA,EACpB,GAAIE,IAAW,cACbD,EAAQ,aAAe,WACdC,IAAW,aACpBD,EAAQ,SAAW,WACVC,IAAW,oBACpBD,EAAQ,gBAAkB,WACjBC,IAAW,gBACpBD,EAAQ,YAAc,WACbC,IAAW,cACpBD,EAAQ,oBAAsB,WACrBC,IAAW,YACpBD,EAAQ,kBAAoB,WACnBC,IAAW,kBACpBD,EAAQ,iBAAmB,WAClBC,IAAW,cACpBD,EAAQ,oBAAsB,WACrBC,IAAW,SACpBD,EAAQ,cAAgBF,EAAKC,CAAA,EAAM,MAAM,GAAG,EAC5CA,YACSE,IAAW,UACpBD,EAAQ,SAAWF,EAAKC,CAAA,EAAM,MAAM,GAAG,EACvCA,YACSE,IAAW,aACpBD,EAAQ,eAAiB,WAChBC,IAAW,aACpBD,EAAQ,eAAiB,YAChBC,IAAW,cACpBD,EAAQ,eAAiB,YAChBC,IAAW,YACpBD,EAAQ,eAAiB,YAChBC,IAAW,cACpBD,EAAQ,eAAiB,YAChBC,IAAW,kBACpBD,EAAQ,cAAgB,WACfC,IAAW,sBACpBD,EAAQ,kBAAoB,KAAK,MAAMF,EAAKC,CAAA,CAAK,EACjDA,QAEA,OAAM,IAAI,MAAM,eAAeE,GAAQ,CAE3C,CAEA,MAAO,CAAE,kBADiBC,GAAuBJ,EAAK,MAAMC,CAAI,EAAE,KAAK,GAAG,CAAC,EAC/C,QAAAC,CAAQ,CACtC,CA+BO,IAAMG,GAAN,KAAgC,CA8BrC,YAAYH,EAAiC,CAAC,EAAG,CA7BjD,KAAA,UAAoB,EAEpB,KAAA,SAAoB,GAEpB,KAAA,YAAuB,GACvB,KAAA,aAAwB,GACxB,KAAA,SAA4B,KAE5B,KAAA,iBAA4B,GAC5B,KAAA,eAAyC,KACzC,KAAA,cAAyB,GAGzB,KAAA,oBAA+B,GAC/B,KAAA,oBAA+B,GAC/B,KAAA,kBAA6B,GAE7B,KAAA,cAA0B,CAAC,EAC3B,KAAA,eAA0B,GAE1B,KAAA,YAAuB,GACvB,KAAA,YAAuB,GACvB,KAAA,UAAqB,GAErB,KAAA,kBAA4D,KAC5D,KAAA,mBAAmE,KAEnE,KAAA,eAAyB,EAGvB,OAAO,OAAO,KAAMA,CAAO,CAC7B,CACF,ECrHMI,GAAwB,CAAC,EACzBC,GAAwB,CAAC,EAExB,SAASC,GAAMC,EAAqB,CACzC,GAAI,CAACH,GAAUG,CAAA,EAAI,CACjB,IAAMC,EAAI,MAAMD,CAAC,EACjB,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrBsE,EAAEtE,CAAA,EAAK,EAETkE,GAAUG,CAAA,EAAKC,CACjB,CACA,OAAOJ,GAAUG,CAAA,CACnB,CAEO,SAASE,EAAKF,EAAqB,CACxC,GAAI,CAACF,GAAUE,CAAA,EAAI,CACjB,IAAMC,EAAI,MAAMD,CAAC,EACjB,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrBsE,EAAEtE,CAAA,EAAKA,EAETmE,GAAUE,CAAA,EAAKC,CACjB,CACA,OAAOH,GAAUE,CAAA,CACnB,CAEO,SAASG,GAASH,EAAiB,CACxC,OAAO,IAAII,GAAKF,EAAKF,CAAC,CAAC,CACzB,CAiBO,SAASK,GAAU9C,EAAmB,CAC3C,IAAIxB,EAAI,OAAO,CAAC,EAChB,KAAOwB,EAAI,GACTxB,GAAK,OAAOwB,CAAC,EACbA,IAEF,OAAOxB,CACT,CAEA,SAASuE,GAAI/C,EAAWC,EAAmB,CACzC,GAAID,EAAIC,EAAG,CACT,IAAM+C,EAAIhD,EACVA,EAAIC,EACJA,EAAI+C,CACN,CACA,KAAOhD,EAAI,GAAG,CACZ,IAAMiD,EAAIhD,EAAID,EACdC,EAAID,EACJA,EAAIiD,CACN,CACA,OAAOhD,CACT,CAEO,SAASiD,GAAIlD,EAAWC,EAAmB,CAChD,OAAQD,EAAI+C,GAAI/C,EAAGC,CAAC,EAAKA,CAC3B,CAEO,IAAM4C,GAAN,KAAW,CAGhB,YAAY7C,EAAa,CACvB,KAAK,EAAIA,EAAE,OACX,KAAK,EAAIA,CACX,CAEO,UAAmB,CAExB,MAAO,QAAQ,KAAK,EAAE,KAAK,GAAG,IAChC,CAEO,IAAImD,EAAgB,CAEzB,IAAMT,EAAc,MAAM,KAAK,CAAC,EAChC,QAAStE,EAAI,EAAGA,EAAI,KAAK,EAAGA,IAC1BsE,EAAEtE,CAAA,EAAK+E,EAAG,EAAE,KAAK,EAAE/E,CAAA,CAAA,EAErB,OAAO,IAAIyE,GAAKH,CAAC,CACnB,CAEO,KAAKS,EAAgB,CAE1B,IAAMT,EAAI,MAAM,KAAK,CAAC,EACtB,QAAStE,EAAI,EAAGA,EAAI,KAAK,EAAGA,IAC1BsE,EAAEtE,CAAA,EAAK,KAAK,EAAE+E,EAAG,EAAE/E,CAAA,CAAA,EAErB,OAAO,IAAIyE,GAAKH,CAAC,CACnB,CAEO,KAAY,CACjB,IAAMA,EAAI,MAAM,KAAK,CAAC,EACtB,QAAStE,EAAI,EAAGA,EAAI,KAAK,EAAGA,IAC1BsE,EAAE,KAAK,EAAEtE,CAAA,CAAA,EAAMA,EAEjB,OAAO,IAAIyE,GAAKH,CAAC,CACnB,CAEO,UAAUS,EAAkB,CAEjC,QAAS/E,EAAI,EAAGA,EAAI,KAAK,EAAGA,IAC1B,GAAI,KAAK,EAAEA,CAAA,IAAO+E,EAAG,EAAE/E,CAAA,EACrB,OAAO,KAAK,EAAEA,CAAA,EAAK+E,EAAG,EAAE/E,CAAA,EAG5B,MAAO,EACT,CAEO,OAAgB,CACrB,IAAMgF,EAAM,IAAI,MACVC,EAAO,IAAI,MAAe,KAAK,CAAC,EACtC,QAASjF,EAAI,EAAGA,EAAI,KAAK,EAAE,OAAQA,IAAK,CACtC,GAAIiF,EAAKjF,CAAA,GAAM,KAAK,EAAEA,CAAA,IAAOA,EAC3B,SAEF,IAAMkF,EAAQ,IAAI,MAClB,QAASjF,EAAID,EAAG,CAACiF,EAAKhF,CAAA,EAAIA,EAAI,KAAK,EAAEA,CAAA,EACnCiF,EAAM,KAAK,EAAIjF,CAAC,EAChBgF,EAAKhF,CAAA,EAAK,GAEZ+E,EAAI,KAAK,IAAIE,EAAM,KAAK,GAAG,IAAI,CACjC,CACA,OAAOF,EAAI,KAAK,EAAE,CACpB,CAEO,OAAgB,CACrB,IAAI5E,EAAI,EACF6E,EAAO,IAAI,MAAe,KAAK,CAAC,EACtC,QAASjF,EAAI,EAAGA,EAAI,KAAK,EAAE,OAAQA,IAAK,CACtC,GAAIiF,EAAKjF,CAAA,GAAM,KAAK,EAAEA,CAAA,IAAOA,EAC3B,SAEF,IAAImF,EAAK,EACT,QAASlF,EAAID,EAAG,CAACiF,EAAKhF,CAAA,EAAIA,EAAI,KAAK,EAAEA,CAAA,EACnCkF,IACAF,EAAKhF,CAAA,EAAK,GAEZG,EAAI0E,GAAI1E,EAAG+E,CAAE,CACf,CACA,OAAO/E,CACT,CACF,EC7IagF,GAAN,KAAiB,CACtB,YAAmBC,EAAqBC,EAAa,CAAlC,KAAA,KAAAD,EAAqB,KAAA,IAAAC,CAAc,CAC/C,gBAAyB,CAC9B,OAAOZ,GAAU,KAAK,IAAI,EAAI,OAAO,KAAK,GAAG,GAAK,OAAO,KAAK,IAAI,CACpE,CACF,EAEIa,GAA8B,EAE3B,SAASC,GACdC,EACAC,EACQ,CACR,IAAMC,EAAKtE,EAAK,WAAWqE,CAAU,EAC/BE,EAAMH,EAAO,mBAAmBE,CAAE,EACxC,OAAIC,IAAQ,MAAQD,IAAOC,EAClBF,EAEFE,EAAI,SAAS,CACtB,CAEO,IAAMC,GAAN,KAAkB,CACvB,YACSC,EACCC,EACDC,EACAC,EACAC,EACAC,EACAC,EACP,CAPO,KAAA,WAAAN,EACC,KAAA,UAAAC,EACD,KAAA,OAAAC,EACA,KAAA,UAAAC,EACA,KAAA,QAAAC,EACA,KAAA,WAAAC,EACA,KAAA,WAAAC,CACN,CAEI,+BAA+B,EAAqC,CACzE,IAAMC,EAAmC,CAAC,EAC1C,QAASpG,EAAI,EAAGA,EAAI,KAAK,WAAW,OAAQA,IAC1CoG,EAAG,KAAK,WAAWpG,CAAA,CAAA,EAAM,EAAE,OAAOA,CAAA,EAAG,UAAU,EAEjD,OAAOoG,CACT,CAEA,OAAc,+BACZP,EACAlB,EACqB,CACrB,IAAMyB,EAAmC,CAAC,EAC1C,QAASpG,EAAI,EAAGA,EAAI6F,EAAW,OAAQ7F,IACrCoG,EAAGP,EAAW7F,CAAA,CAAA,EAAM2E,EAAE,OAAO3E,CAAA,EAAG,UAAU,EAE5C,OAAOoG,CACT,CAEQ,YAAYlG,EAAWC,EAAaqF,EAA8B,CACxE,IAAMpB,EAAI,KAAK,UAAUlE,CAAA,EAAG,KACtB0E,EAAI,IAAI,MAAMR,CAAC,EACrB,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB6E,EAAE7E,CAAA,EAAK,CAAC,EAEV,QAASA,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAAK,CAC9C,GAAI,KAAK,WAAWA,CAAA,EAClB,SAEF,IAAIsG,EAAS,KAAK,UAAUtG,CAAA,EACvB,KAAK,WAAWA,CAAA,IACnBsG,EAASd,GAAaC,EAAQa,CAAM,EAChCA,EAAOA,EAAO,OAAS,CAAA,IAAO,MAChCA,EAASA,EAAO,UAAU,EAAGA,EAAO,OAAS,CAAC,IAGlD,IAAMC,EAAK,KAAK,QAAQvG,CAAA,EAAG,OAAOG,CAAA,EAClC,QAASF,EAAI,EAAGA,EAAIoE,EAAGpE,KACjBsG,EAAG,KAAKtG,CAAA,IAAOA,GAAKsG,EAAG,IAAItG,CAAA,IAAO,IACpC4E,EAAE5E,CAAA,EAAG,KAAKqG,CAAM,CAGtB,CACA,QAASrG,EAAI,EAAGA,EAAIoE,EAAGpE,IACrBG,EAAE,KAAK,KAAKH,EAAI,KAAK4E,EAAE5E,CAAA,EAAG,KAAK,GAAG,GAAG,CAEzC,CAEO,SACLuG,EACAf,EAAyB,IAAIzE,GACnB,CACV,IAAMyF,EAAS,CAAC,EAChBA,EAAO,KAAK,QAAQD,GAAM,EAC1BC,EAAO,KAAK,EAAE,EACd,QAAS,EAAI,EAAG,EAAI,KAAK,WAAW,OAAQ,IAC1CA,EAAO,KACL,OAAO,KAAK,WAAW,CAAA,KAAM,KAAK,UAAU,CAAA,EAAG,QAAQ,KAAK,UAAU,CAAA,EAAG,KAC3E,EACA,KAAK,YAAY,EAAGA,EAAQhB,CAAM,EAEpCgB,EAAO,KAAK,EAAE,EACdA,EAAO,KAAK,QAAQ,EACpB,QAAS,EAAI,EAAG,EAAI,KAAK,WAAW,OAAQ,IAC1C,KAAK,OAAO,OAAO,CAAA,EAAG,iBACpBA,EACA,KAAK,WAAW,CAAA,EAChB,GACA,EACF,EAEFA,EAAO,KAAK,KAAK,EACjB,QAAS,EAAI,EAAG,EAAI,KAAK,UAAU,OAAQ,IAAK,CAC9CA,EAAO,KAAK,EAAE,EACd,IAAID,EAAO,KAAK,UAAU,CAAA,EACrB,KAAK,WAAW,CAAA,IACnBA,EAAOhB,GAAaC,EAAQ,KAAK,UAAU,CAAA,CAAE,GAE/C,IAAIiB,EAAQ,GACRF,EAAKA,EAAK,OAAS,CAAA,IAAO,MAC5BE,EAAQ,GACRF,EAAOA,EAAK,UAAU,EAAGA,EAAK,OAAS,CAAC,GAE1CC,EAAO,KAAK,QAAQD,GAAM,EAC1B,QAASvG,EAAI,EAAGA,EAAI,KAAK,WAAW,OAAQA,IACtCyG,EACF,KAAK,QAAQ,CAAA,EAAG,OAAOzG,CAAA,EACpB,IAAI,EACJ,iBAAiBwG,EAAQ,KAAK,WAAWxG,CAAA,EAAI,EAAI,EAEpD,KAAK,QAAQ,CAAA,EAAG,OAAOA,CAAA,EAAG,iBACxBwG,EACA,KAAK,WAAWxG,CAAA,EAChB,EACF,EAGJwG,EAAO,KAAK,KAAK,CACnB,CAEA,OAAOA,CACT,CAGO,oBAAoBE,EAA0C,CACnE,IAAMC,EAAsC,CAAC,EACvCC,EAA6C,CAAC,EACpD,QAAS7G,EAAI,EAAGA,EAAI,KAAK,WAAW,OAAQA,IAAK,CAC/C4G,EAAO,KAAK,WAAW5G,CAAA,CAAA,EAAM,CAC3B,UAAW,KAAK,UAAUA,CAAA,EAAG,KAC7B,gBAAiB,KAAK,UAAUA,CAAA,EAAG,GACrC,EACA,IAAM8G,EAAsB,KAAK,OAAO,OAAO9G,CAAA,EAAG,UAAU,EAC5D6G,EAAM,KAAK,WAAW7G,CAAA,CAAA,EAAM,CAC1B,OAAQ8G,EAAoB,YAC5B,YAAaA,EAAoB,WACnC,CACF,CACA,IAAMC,EAAqC,CAAC,EAC5C,GAAIJ,EACF,QAAS3G,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IACzC+G,EAAM,KAAK,UAAU/G,CAAA,CAAA,EAAM,KAAK,+BAC9B,KAAK,QAAQA,CAAA,CACf,EAGJ,MAAO,CACL,KAAM,SAAS,EAAEuF,KACjB,OAAAqB,EACA,eAAgBC,EAChB,MAAAE,CACF,CACF,CAEO,UAAwB,CAC7B,IAAMC,EAA0B,CAAC,EAC3BC,EAA6B,CAAC,EAC9BC,EAAuB,CAAC,EACxBC,EAA0B,CAAC,EACjC,QAASlH,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCkH,EAAW,KAAK,CAAC,CAAC,EAEpB,QAASnH,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAAK,CAC9C,IAAMoH,EAAK,KAAK,UAAUpH,CAAA,EAAG,IACvBqE,EAAI,KAAK,UAAUrE,CAAA,EAAG,KACtBqH,EAAK,IAAIC,GAAcjD,CAAC,EACxBkD,EAAU,IAAI,MAAe,KAAK,UAAUvH,CAAA,EAAG,IAAI,EACzD,QAASwH,EAAI,EAAGA,EAAInD,EAAGmD,IACrBD,EAAQC,CAAA,EAAK,GAIf,QAASvH,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvC,QAASuH,EAAI,EAAGA,EAAInD,EAAGmD,KAEnB,KAAK,QAAQvH,CAAA,EAAG,OAAOD,CAAA,EAAG,KAAKwH,CAAA,IAAOA,GACtC,KAAK,QAAQvH,CAAA,EAAG,OAAOD,CAAA,EAAG,IAAIwH,CAAA,IAAO,KAEhC,KAAK,WAAWvH,CAAA,IACnBsH,EAAQC,CAAA,EAAK,IAEfH,EAAG,MAAMG,EAAG,KAAK,QAAQvH,CAAA,EAAG,OAAOD,CAAA,EAAG,KAAKwH,CAAA,CAAE,GAInD,IAAIC,EAAU,GAId,GAAIL,EAAK,EAAG,CACVK,EAAU,GACV,IAAMC,EAAM,IAAIJ,GAAc,KAAK,UAAUtH,CAAA,EAAG,KAAOoH,CAAE,EACzD,QAASnH,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvC,QAASuH,EAAI,EAAGA,EAAInD,EAAGmD,IACrB,GACE,KAAK,QAAQvH,CAAA,EAAG,OAAOD,CAAA,EAAG,KAAKwH,CAAA,IAAOA,GACtC,KAAK,QAAQvH,CAAA,EAAG,OAAOD,CAAA,EAAG,IAAIwH,CAAA,IAAO,EAErC,QAASG,EAAI,EAAGA,EAAIP,EAAIO,IACtBD,EAAI,MACFF,EAAIJ,EAAKO,EACT,KAAK,QAAQ1H,CAAA,EAAG,OAAOD,CAAA,EAAG,KAAKwH,CAAA,EAAKJ,GAChCO,EAAI,KAAK,QAAQ1H,CAAA,EAAG,OAAOD,CAAA,EAAG,IAAIwH,CAAA,GAAMJ,CAC9C,EAKR,QAASnH,EAAI,EAAG,CAACwH,GAAWxH,EAAIoE,EAAGpE,IACjC,QAAS0H,EAAI,EAAGA,EAAIP,EAAIO,IAClBD,EAAI,KAAKzH,EAAImH,CAAE,IAAMM,EAAI,KAAKzH,EAAImH,EAAKO,CAAC,IAC1CF,EAAU,IAIhB,QAASxH,EAAI,EAAG,CAACwH,GAAWxH,EAAIoE,EAAGpE,IACjC,QAASuH,EAAI,EAAGA,EAAIvH,EAAGuH,IAEnB,KAAK,OAAO,OAAOxH,CAAA,EAAG,KAAKC,CAAA,IAAO,KAAK,OAAO,OAAOD,CAAA,EAAG,KAAKwH,CAAA,IAE7DC,EAAU,GAIlB,CAEA,IAAIG,EAAU,GACVC,EAAW,GACf,QAAS5H,EAAI,EAAGA,EAAI,KAAK,UAAUD,CAAA,EAAG,KAAMC,IAC1C,GAAIsH,EAAQtH,CAAA,EAAI,CACd,IAAM,EAAIoH,EAAG,KAAKpH,CAAC,EACf2H,EAAU,EACZA,EAAU,EACDA,IAAY,IACrBC,EAAW,GAEf,CAEF,QAAS5H,EAAI,EAAGA,EAAI,KAAK,UAAUD,CAAA,EAAG,KAAMC,IAAK,CAK/C,GAJI,CAACsH,EAAQtH,CAAA,GAGHoH,EAAG,KAAKpH,CAAC,IACTA,EACR,SAEF,IAAM6H,EAAe,CAAC,EAChBC,EAAe,CAAC,EAClBC,EAAK,EACT,QAASR,EAAI,EAAGA,EAAI,KAAK,UAAUxH,CAAA,EAAG,KAAMwH,IACtCH,EAAG,KAAKG,CAAC,IAAMvH,IACjB6H,EAAGE,CAAA,EAAMR,EACTO,EAAGP,CAAA,EAAKQ,EACRA,KAQJ,GALIH,EACFb,EAAc,KAAK,GAAG,KAAK,WAAWhH,CAAA,MAAOC,GAAG,EAEhD+G,EAAc,KAAK,KAAK,WAAWhH,CAAA,CAAE,EAEnCyH,EAAS,CACXR,EAAa,KAAK,IAAI7B,GAAW4C,EAAI,KAAK,UAAUhI,CAAA,EAAG,GAAG,CAAC,EAC3DkH,EAAU,KAAK,KAAK,OAAO,OAAOlH,CAAA,EAAG,QAAQ8H,EAAIE,CAAE,CAAC,EACpD,QAASR,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCL,EAAWK,CAAA,EAAG,KAAK,KAAK,QAAQA,CAAA,EAAG,OAAOxH,CAAA,EAAG,MAAM8H,EAAIC,EAAIC,CAAE,CAAC,CAElE,KAAO,CACLf,EAAa,KAAK,IAAI7B,GAAW4C,EAAI,CAAC,CAAC,EACvCd,EAAU,KAAK,KAAK,OAAO,OAAOlH,CAAA,EAAG,QAAQ8H,EAAIE,CAAE,EAAE,QAAQ,CAAC,EAC9D,QAASR,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCL,EAAWK,CAAA,EAAG,KACZ,KAAK,QAAQA,CAAA,EAAG,OAAOxH,CAAA,EAAG,MAAM8H,EAAIC,EAAIC,CAAE,EAAE,QAAQ,CACtD,CAEJ,CACF,CACF,CACA,OAAO,IAAInC,GACTmB,EACAC,EACA,IAAIgB,GAAaf,CAAS,EAC1B,KAAK,UACLC,EAAW,IAAKe,GAAM,IAAIC,GAAYD,CAAC,CAAC,EACxC,KAAK,WACL,KAAK,UACP,CACF,CAGO,SAAS7D,EAAiB,CAC/B,KAAK,OAAS,KAAK,OAAO,IAAI,KAAK,0BAA0BA,CAAC,CAAC,CACjE,CAKO,0BAA0BA,EAAwB,CAEnDA,EAAI,MACNA,EAAI,KAEN,IAAM+D,EAAsB,CAAC,EAC7B,QAAS,EAAI,EAAG,EAAI,KAAK,QAAQ,OAAQ,IACvCA,EAAK,CAAA,EAAK,KAAK,QAAQ,CAAA,EAEzB,QAAS,EAAI,EAAG,EAAIA,EAAK,OAAQ,IAAK,CACpC,IAAMnI,EAAI,KAAK,MAAM,KAAK,OAAO,EAAImI,EAAK,MAAM,EAC1CxD,EAAIwD,EAAK,CAAA,EACfA,EAAK,CAAA,EAAKA,EAAKnI,CAAA,EACfmI,EAAKnI,CAAA,EAAK2E,CACZ,CACIP,EAAI+D,EAAK,SACX/D,EAAI+D,EAAK,QAEX,QAAS,EAAI,EAAG,EAAI/D,EAAG,IAAK,CAC1B,IAAMgE,EAAK,KAAK,MAAM,KAAK,OAAO,EAAID,EAAK,MAAM,EAC3CE,EAAK,KAAK,MAAM,KAAK,OAAO,EAAIF,EAAK,MAAM,EAC3CG,EAAK,KAAK,MAAM,KAAK,OAAO,EAAI,KAAK,QAAQ,MAAM,EACzDH,EAAKC,CAAA,EAAMD,EAAKC,CAAA,EAAI,IAAID,EAAKE,CAAA,CAAG,EAAE,IAAI,KAAK,QAAQC,CAAA,CAAG,EAClD,KAAK,OAAO,EAAI,KAElBH,EAAKC,CAAA,EAAMD,EAAKC,CAAA,EAAI,IAAI,KAAK,QAAQE,CAAA,CAAG,EAE5C,CACA,IAAI,EAAIH,EAAK,CAAA,EACb,QAAS,EAAI,EAAG,EAAIA,EAAK,OAAQ,IAC/B,EAAI,EAAE,IAAIA,EAAK,CAAA,CAAE,EAEnB,OAAO,CACT,CAEO,gBAAyB,CAC9B,IAAI/D,EAAI,OAAO,CAAC,EAChB,QAASrE,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IACzCqE,GAAK,KAAK,UAAUrE,CAAA,EAAG,eAAe,EAExC,OAAOqE,CACT,CACF,EAEamE,EAAN,KAAc,CAOnB,YACSC,EACAC,EACAC,EACP,CAHO,KAAA,KAAAF,EACA,KAAA,IAAAC,EACA,KAAA,OAAAC,CACN,CARH,OAAc,EAAEtE,EAAWiB,EAAsB,CAC/C,OAAO,IAAIkD,EAAQjE,EAAKF,CAAC,EAAGD,GAAMC,CAAC,EAAGiB,CAAG,CAC3C,CAQO,IAAIzD,EAAqB,CAC9B,IAAMwC,EAAI,KAAK,KAAK,OACduE,EAAU,IAAI,MAAcvE,CAAC,EACnC,GAAI,KAAK,SAAW,EAAG,CACrB,QAAS,EAAI,EAAG,EAAIA,EAAG,IACrBuE,EAAQ,CAAA,EAAK,KAAK,KAAK/G,EAAE,KAAK,CAAA,CAAA,EAEhC,OAAO,IAAI2G,EAAQI,EAAS,KAAK,IAAK,KAAK,MAAM,CACnD,KAAO,CACL,IAAMC,EAAS,IAAI,MAAcxE,CAAC,EAClC,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB4I,EAAQ5I,CAAA,EAAK,KAAK,KAAK6B,EAAE,KAAK7B,CAAA,CAAA,EAC9B6I,EAAO7I,CAAA,GAAM,KAAK,IAAI6B,EAAE,KAAK7B,CAAA,CAAA,EAAM6B,EAAE,IAAI7B,CAAA,GAAM,KAAK,OAEtD,OAAO,IAAIwI,EAAQI,EAASC,EAAQ,KAAK,MAAM,CACjD,CACF,CAEO,KAAe,CACpB,IAAMxE,EAAI,KAAK,KAAK,OACduE,EAAU,IAAI,MAAcvE,CAAC,EAC7BwE,EAAS,IAAI,MAAcxE,CAAC,EAClC,QAAS,EAAI,EAAG,EAAIA,EAAG,IACrBuE,EAAQ,KAAK,KAAK,CAAA,CAAA,EAAM,EACxBC,EAAO,KAAK,KAAK,CAAA,CAAA,GAAO,KAAK,OAAS,KAAK,IAAI,CAAA,GAAM,KAAK,OAE5D,OAAO,IAAIL,EAAQI,EAASC,EAAQ,KAAK,MAAM,CACjD,CAEO,MAAMhH,EAAqB,CAChC,IAAMwC,EAAI,KAAK,KAAK,OACpB,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB,GAAI,KAAK,KAAKA,CAAA,IAAO6B,EAAE,KAAK7B,CAAA,GAAM,KAAK,IAAIA,CAAA,IAAO6B,EAAE,IAAI7B,CAAA,EACtD,MAAO,GAGX,MAAO,EACT,CAGO,SAAgB,CACrB,IAAMqE,EAAI,KAAK,KAAK,OACpB,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB,KAAK,IAAIA,CAAA,EAAK,EAEhB,YAAK,OAAS,EACP,IACT,CAEO,QAAe,CACpB,IAAM2H,EAAI,KAAK,OACf,GAAIA,IAAM,EACR,OAAO,IAAIlD,GAAK,KAAK,IAAI,EAE3B,IAAMJ,EAAI,KAAK,KAAK,OACduE,EAAU,IAAI,MAAcvE,EAAIsD,CAAC,EACvC,QAAS,EAAI,EAAG,EAAItD,EAAG,IACrB,QAASpE,EAAI,EAAGA,EAAI0H,EAAG1H,IACrB2I,EAAQ,EAAIjB,EAAI1H,CAAA,EAAK0H,EAAI,KAAK,KAAK,CAAA,GAAO,KAAK,IAAI,CAAA,EAAK1H,GAAK0H,EAGjE,OAAO,IAAIlD,GAAKmE,CAAO,CACzB,CAGO,iBAA8B,CACnC,IAAME,EAAkB,CAAC,EACnBzE,EAAI,KAAK,KAAK,OACdjE,EAAgB,CAAC,EACvB,QAAS,EAAI,EAAG,EAAIiE,EAAG,IAAK,CAC1B,IAAM0E,EAAI,KAAK,KAAK,CAAA,EACpB,GAAID,EAAKC,CAAA,IAAO,OAAW,CACzB,IAAM5I,EAAc,CAAC,CAAC,EACtB2I,EAAKC,CAAA,EAAK,GACV,QAAS9I,EAAI,EAAI,EAAGA,EAAIoE,EAAGpE,IACrB,KAAK,KAAKA,CAAA,IAAO8I,GACnB5I,EAAE,KAAKF,CAAC,EAGZG,EAAE,KAAKD,CAAC,CACV,CACF,CACA,OAAOC,CACT,CAEO,OAAgB,CAErB,OAAO,KAAK,OAAO,EAAE,MAAM,CAC7B,CAEO,YAAsB,CAC3B,IAAMiE,EAAI,KAAK,KAAK,OACpB,GAAI,KAAK,OAASE,EAAKF,CAAC,GAAK,KAAK,MAAQD,GAAMC,CAAC,EAC/C,MAAO,GAET,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB,GAAI,KAAK,KAAKA,CAAA,IAAOA,GAAK,KAAK,IAAIA,CAAA,IAAO,EACxC,MAAO,GAGX,MAAO,EACT,CAEQ,UAAoB,CAC1B,IAAMqE,EAAI,KAAK,KAAK,OACpB,GAAI,KAAK,MAAQD,GAAMC,CAAC,EACtB,MAAO,GAET,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB,GAAI,KAAK,IAAIA,CAAA,IAAO,EAClB,MAAO,GAGX,MAAO,EACT,CAEO,MAAM8H,EAAcC,EAAcC,EAAqB,CAC5D,IAAMY,EAAU,IAAI,MAAcZ,CAAE,EAC9Ba,EAAS,IAAI,MAAcb,CAAE,EACnC,QAAShI,EAAI,EAAGA,EAAIgI,EAAIhI,IACtB4I,EAAQ5I,CAAA,EAAK+H,EAAG,KAAK,KAAKD,EAAG9H,CAAA,CAAA,CAAA,EAC7B6I,EAAO7I,CAAA,EAAK,KAAK,IAAI8H,EAAG9H,CAAA,CAAA,EAE1B,OAAO,IAAIwI,EAAQI,EAASC,EAAQ,KAAK,MAAM,CACjD,CAEO,QAAQf,EAAcE,EAAqB,CAChD,IAAMY,EAAU,IAAI,MAAcZ,CAAE,EAC9Ba,EAAS,IAAI,MAAcb,CAAE,EAC/BgB,EAAU,EACRC,EAAW,CAAC,EAClB,QAASjJ,EAAI,EAAGA,EAAIgI,EAAIhI,IAAK,CAC3B,IAAMkJ,EAAK,KAAK,KAAKpB,EAAG9H,CAAA,CAAA,EACpBiJ,EAASC,CAAA,IAAQ,SACnBD,EAASC,CAAA,EAAMF,KAEjBJ,EAAQ5I,CAAA,EAAKiJ,EAASC,CAAA,EACtBL,EAAO7I,CAAA,EAAK,KAAK,IAAI8H,EAAG9H,CAAA,CAAA,CAC1B,CACA,OAAO,IAAIwI,EAAQI,EAASC,EAAQ,KAAK,MAAM,CACjD,CAEO,iBACLpC,EACAD,EACA2C,EACAC,EAAmB,GACb,CACN,GAAI,EAAAA,GAAW,KAAK,WAAW,KAG/B3C,EAAO,KAAKD,CAAI,EAChBC,EAAO,KAAK,KAAK,KAAK,IAAKyB,GAAcA,EAAI,CAAC,EAAE,KAAK,GAAG,CAAC,EACrD,CAAC,KAAK,SAAS,GACjB,GAAIiB,EAAO,CACT,IAAME,EAAS,IAAI,MAAc,KAAK,IAAI,MAAM,EAChD,QAASrJ,EAAI,EAAGA,EAAIqJ,EAAO,OAAQrJ,IACjCqJ,EAAO,KAAK,KAAKrJ,CAAA,CAAA,EAAM,KAAK,IAAIA,CAAA,EAElCyG,EAAO,KAAK4C,EAAO,KAAK,GAAG,CAAC,CAC9B,MACE5C,EAAO,KAAK,KAAK,IAAI,KAAK,GAAG,CAAC,CAGpC,CAGO,WAAsC,CAC3C,IAAMpC,EAAI,KAAK,KAAK,OACpB,OAAI,KAAK,WAAW,GACbmE,EAAQ,OAAOnE,CAAA,IAClBmE,EAAQ,OAAOnE,CAAA,EAAK,CAAE,YAAaE,EAAKF,CAAC,EAAG,YAAaD,GAAMC,CAAC,CAAE,GAE7DmE,EAAQ,OAAOnE,CAAA,GAEf,CAAE,YAAa,KAAK,KAAM,YAAa,KAAK,GAAI,CAE3D,CACF,EA/LaiF,GAANd,EAAMc,GACI,OAAqC,CAAC,EA+LhD,IAAMC,GAAN,KAAsB,CAC3B,YAAmB3C,EAAmB,CAAnB,KAAA,OAAAA,CAAoB,CAChC,YAAY/E,EAA+B,CAChD,IAAM2H,EAAuB,CAAC,EAC9B,QAASxJ,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IACtCwJ,EAAU,KAAK,KAAK,OAAOxJ,CAAA,EAAG,IAAI6B,EAAE,OAAO7B,CAAA,CAAE,CAAC,EAEhD,OAAOwJ,CACT,CAEU,aAAyB,CACjC,IAAMA,EAAuB,CAAC,EAC9B,QAAWC,KAAS,KAAK,OACvBD,EAAU,KAAKC,EAAM,IAAI,CAAC,EAE5B,OAAOD,CACT,CAEO,MAAM3H,EAA6B,CACxC,QAAS7B,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IACtC,GAAI,CAAC,KAAK,OAAOA,CAAA,EAAG,MAAM6B,EAAE,OAAO7B,CAAA,CAAE,EACnC,MAAO,GAGX,MAAO,EACT,CAEU,SAAgB,CACxB,QAAWyJ,KAAS,KAAK,OACvBA,EAAM,QAAQ,EAEhB,OAAO,IACT,CAEO,QAAe,CACpB,IAAMC,EAAQ,IAAI,MACdrF,EAAI,EACR,QAAWoF,KAAS,KAAK,OAAQ,CAC/B,IAAME,EAAIF,EAAM,OAAO,EACvBC,EAAM,KAAKC,CAAC,EACZtF,GAAKsF,EAAE,CACT,CACA,IAAMf,EAAU,IAAI,MAAcvE,CAAC,EACnCA,EAAI,EACJ,QAAWsF,KAAKD,EAAO,CACrB,QAASzJ,EAAI,EAAGA,EAAI0J,EAAE,EAAG1J,IACvB2I,EAAQvE,EAAIpE,CAAA,EAAKoE,EAAIsF,EAAE,EAAE1J,CAAA,EAE3BoE,GAAKsF,EAAE,CACT,CACA,OAAO,IAAIlF,GAAKmE,CAAO,CACzB,CAEO,iBAA8B,CACnC,IAAMxI,EAAgB,CAAC,EACnBiE,EAAI,EACR,QAAWoF,KAAS,KAAK,OAAQ,CAC/B,IAAM9B,EAAI8B,EAAM,OACVtJ,EAAIsJ,EAAM,gBAAgB,EAChC,QAASxJ,EAAI,EAAGA,EAAIE,EAAE,OAAQF,IAC5BG,EAAE,KAAKD,EAAEF,CAAA,EAAG,IAAKiI,GAAMA,EAAIP,EAAItD,CAAC,CAAC,EAEnCA,GAAKsD,EAAI8B,EAAM,KAAK,MACtB,CACA,OAAOrJ,CACT,CAEO,OAAgB,CACrB,IAAIA,EAAI,EACR,QAAWqJ,KAAS,KAAK,OACvBrJ,EAAI0E,GAAI1E,EAAGqJ,EAAM,MAAM,CAAC,EAE1B,OAAOrJ,CACT,CACF,EACa+H,GAAN,cAA0BoB,EAAgB,CAC/C,YAAY3C,EAAmB,CAC7B,MAAMA,CAAM,CACd,CAEO,IAAI/E,EAA6B,CACtC,OAAO,IAAIsG,GAAY,KAAK,YAAYtG,CAAC,CAAC,CAC5C,CAEO,UAAUwC,EAAwB,CACvC,GAAIA,IAAM,EACR,OAAO,KAAK,EAAE,EAEhB,IAAIO,EAAiB,KAKrB,IAJIP,EAAI,IACNO,EAAIA,EAAE,IAAI,EACVP,EAAI,CAACA,GAEC,EAAAA,EAAI,IACVO,EAAIA,EAAE,IAAIA,CAAC,EACXP,IAAM,EAER,GAAIA,IAAM,EACR,OAAOO,EAET,IAAI,EAAIA,EACJxE,EAAI,KAAK,EAAE,EACf,KAAOiE,EAAI,GACLA,EAAI,IACNjE,EAAIA,EAAE,IAAI,CAAC,GAETiE,EAAI,IACN,EAAI,EAAE,IAAI,CAAC,GAEbA,IAAM,EAER,OAAOjE,CACT,CAEO,KAAmB,CACxB,OAAO,IAAI+H,GAAY,KAAK,YAAY,CAAC,CAC3C,CAEO,GAAiB,CACtB,OAAO,IAAIA,GACT,KAAK,OAAO,IAAKD,GAAeoB,GAAQ,EAAEpB,EAAE,KAAK,OAAQA,EAAE,MAAM,CAAC,CACpE,CACF,CACF,EACaD,GAAN,cAA2BsB,EAAgB,CAChD,YAAY3C,EAAmB,CAC7B,MAAMA,CAAM,CACd,CAEO,IAAI/E,EAA8B,CACvC,OAAO,IAAIoG,GAAa,KAAK,YAAYpG,CAAC,CAAC,CAC7C,CACF,EAEMyF,GAAN,KAAoB,CAElB,YAAmBjD,EAAW,CAAX,KAAA,EAAAA,EACjB,KAAK,MAAQ,IAAI,MAAcA,CAAC,EAChC,QAASrE,EAAI,EAAGA,EAAIqE,EAAGrE,IACrB,KAAK,MAAMA,CAAA,EAAKA,CAEpB,CAEO,KAAK+I,EAAmB,CAC7B,IAAIa,EAAI,KAAK,MAAMb,CAAA,EACnB,OAAI,KAAK,MAAMa,CAAA,IAAOA,IAGtBA,EAAI,KAAK,KAAK,KAAK,MAAMA,CAAA,CAAE,EAC3B,KAAK,MAAMb,CAAA,EAAKa,GACTA,CACT,CAEO,MAAMhI,EAAWC,EAAiB,CACvC,IAAMgI,EAAK,KAAK,KAAKjI,CAAC,EAChBkI,EAAK,KAAK,KAAKjI,CAAC,EAClBgI,EAAKC,EACP,KAAK,MAAMA,CAAA,EAAMD,EACRA,EAAKC,IACd,KAAK,MAAMD,CAAA,EAAMC,EAErB,CACF,EACO,SAASC,GAAUhJ,EAAgBiJ,EAAiC,CAEzE,IAAM3F,EAAItD,EAAE,QAAQ,OACpB,GAAIsD,EAAI,GACN,MAAM,IAAI,MAAM,gCAAgC,EAElD,IAAM4F,EAAS,CAAC,EACVC,EAAW,CAAC,EAClB,QAASlK,EAAI,EAAGA,EAAIqE,EAAGrE,IAAK,CAC1B,IAAMmK,EAAQpJ,EAAE,QAAQf,CAAA,EACxBiK,EAAO,KAAKE,EAAM,MAAM,CAAC,EACzB,IAAIC,EAAO,EACX,QAASnK,EAAI,EAAGA,EAAIoE,EAAGpE,IAAK,CAC1B,GAAIA,IAAMD,EACR,SAEF,IAAMqK,EAAQtJ,EAAE,QAAQd,CAAA,EACpBkK,EAAM,IAAIE,CAAK,EAAE,MAAMA,EAAM,IAAIF,CAAK,CAAC,IACzCC,GAAQ,GAAKnK,EAEjB,CACAiK,EAAS,KAAKE,CAAI,CACpB,CACA,IAAIE,EAAc,CAAC,EACnBA,EAAO,CAAA,EAAK,EACZ,QAASC,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC5B,IAAIC,EAAM,EACJC,EAAe,CAAC,EAClBC,EAAO,EACX,QAAWC,KAAOL,EAAQ,CACxB,IAAMM,EAAK,CAACD,EACNE,EAAMP,EAAOM,CAAA,EACnBJ,GAAOK,EACPH,IACA,QAAS/E,EAAK,EAAGA,EAAKsE,EAAO,OAAQtE,IACnC,GACI,EAAAiF,GAAMjF,EAAM,IACb,EAAAiF,EAAKV,EAASvE,CAAA,GAAQ,GAAKA,GAAM,GAClC,CACA,IAAMmF,EAAOF,EAAKV,EAASvE,CAAA,EAAQ,GAAKA,EACpC8E,EAAQK,CAAA,IAAS,SACnBL,EAAQK,CAAA,EAAO,GAEjBL,EAAQK,CAAA,IAASb,EAAOtE,CAAA,EAAM,GAAKkF,CACrC,CAEJ,CACAb,EAAK,GAAGO,eAAeC,YAAcE,GAAM,EAC3CJ,EAASG,CACX,CACF,CChwBO,IAAMM,GAAyD,CACpE,QAAS,QACT,QAAS,wBACT,QAAS,cACT,QAAS,gBACT,QAAS,gDACT,QAAS,gEACT,QAAS,4BACT,QACE,oFACF,WAAY,gCACZ,WACE,yGACF,WACE,8FACF,WACE,6HACF,WAAY,qDACZ,WACE,gIACF,WACE,iHACF,MAAO,QACP,eAAgB,YAChB,kBAAmB,eACnB,aAAc,wBACd,WAAY,wBACZ,eAAgB,WAChB,KAAM,wBACN,cAAe,QACf,YAAa,QACb,cAAe,wBACf,SAAU,2CACV,UAAW,wBACX,kBAAmB,gBACnB,mBAAoB,YACpB,qBAAsB,6BACtB,sBAAuB,uBACvB,gBAAiB,QACjB,qBAAsB,wBACtB,SAAU,UACV,SAAU,kBACV,SAAU,yBACV,SAAU,gCACV,QAAS,2CACT,SAAU,6CACV,UAAW,iEACX,aAAc,QACd,sBAAuB,UACvB,qBAAsB,mBAEtB,SAAU,wBACV,aAAc,uBACd,mBAAoB,wBACpB,YAAa,QACb,WAAY,QACZ,gBAAiB,QACjB,IAAK,wBACL,aAAc,cACd,sBAAuB,wBACvB,SAAU,QACV,uBAAwB,wBACxB,aAAc,QACd,UAAW,QACX,gBAAiB,uBACjB,gBAAiB,2BACjB,2BAA4B,WAC5B,2BAA4B,WAC5B,eAAgB,uBAChB,eAAgB,4BAChB,sBAAuB,YACvB,qBAAsB,4BACtB,6BAA8B,gCAC9B,yBAA0B,wBAC1B,iBAAkB,0CACpB,ECvEMC,GAAM,KAEL,SAASC,GAAeC,EAAoB,CAEjD,IAAI/K,EAAI,IAAIgL,EAAK,EAAG,EAAG,EAAG,CAAC,EAC3B,QAASnL,EAAI,EAAGA,EAAIkL,EAAK,OAAQlL,IAC/BG,EAAIA,EAAE,IAAI+K,EAAKlL,CAAA,CAAE,EAEnB,OAAOG,EAAE,KAAK,EAAM+K,EAAK,MAAM,CACjC,CAEO,SAASE,GACdC,EACAtG,EACAuG,EACAC,EACK,CAIL,IAAM5B,EAAI4B,EAAOF,CAAA,EAAI,WAAWE,EAAOxG,CAAA,EAAKwG,EAAOD,CAAA,CAAG,EACtD,GAAI,CAAC3B,EACH,OAAOA,EAET,QAAS3J,EAAI,EAAGA,EAAIuL,EAAO,OAAQvL,IACjC,GAAIA,IAAMqL,GAAMrL,IAAM+E,GAAM/E,IAAMsL,EAAI,CACpC,IAAME,EAAKD,EAAOvL,CAAA,EAAG,EAAI2J,EAAE,EAAI4B,EAAOvL,CAAA,EAAG,EAAI2J,EAAE,EAAI4B,EAAOvL,CAAA,EAAG,EAAI2J,EAAE,EACnE,GACG4B,EAAOvL,CAAA,EAAG,EAAI,GAAKwL,EAAKD,EAAOvL,CAAA,EAAG,GAClCuL,EAAOvL,CAAA,EAAG,EAAI,GAAKwL,EAAKD,EAAOvL,CAAA,EAAG,EAEnC,MAAO,EAEX,CAEF,OAAO2J,CACT,CAEO,IAAMwB,EAAN,KAAW,CAChB,YACSvJ,EACAC,EACAyC,EACAiG,EACP,CAJO,KAAA,EAAA3I,EACA,KAAA,EAAAC,EACA,KAAA,EAAAyC,EACA,KAAA,EAAAiG,CACN,CAEI,IAAIkB,EAAe,CAExB,OAAO,IAAIN,EACT,KAAK,EAAIM,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EACxD,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EACxD,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EACxD,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,CAC1D,CACF,CAEO,UAAmB,CACxB,MAAO,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,IACjD,CAEO,KAAKA,EAAiB,CAE3B,OAAO,KAAK,MAAM,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,CAAC,CAC1E,CAEO,KAAc,CAEnB,OAAO,KAAK,MAAM,KAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,CAAC,CAClD,CAEO,MAAMA,EAAe,CAE1B,OAAO,IAAIN,EACT,EACA,KAAK,EAAIM,EAAE,EAAI,KAAK,EAAIA,EAAE,EAC1B,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAC1B,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,CAC5B,CACF,CAEO,IAAIA,EAAiB,CAE1B,OAAO,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,EAAI,KAAK,EAAIA,EAAE,CAClD,CAEO,WAAkB,CAEvB,IAAMlB,EAAI,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC,EAClC,OAAO,IAAIY,EAAK,KAAK,EAAIZ,EAAG,KAAK,EAAIA,EAAG,KAAK,EAAIA,EAAG,KAAK,EAAIA,CAAC,CAChE,CAEO,YAAmB,CAExB,OAAO,IAAIY,EAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,CAAC,EAAE,UAAU,CACvD,CAEO,gBAAuB,CAE5B,IAAMZ,EAAI,KAAK,MAAM,KAAK,EAAG,KAAK,EAAG,KAAK,CAAC,EAC3C,OAAO,IAAIY,EAAK,KAAK,EAAIZ,EAAG,KAAK,EAAIA,EAAG,KAAK,EAAIA,EAAG,KAAK,EAAIA,CAAC,CAChE,CAEO,KAAK1F,EAAiB,CAE3B,OAAO,IAAIsG,EAAK,KAAK,EAAItG,EAAG,KAAK,EAAIA,EAAG,KAAK,EAAIA,EAAG,KAAK,EAAIA,CAAC,CAChE,CAEO,IAAI4G,EAAe,CAExB,OAAO,IAAIN,EAAK,KAAK,EAAIM,EAAE,EAAG,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,CAAC,CACxE,CAEO,IAAIA,EAAe,CAExB,OAAO,IAAIN,EAAK,KAAK,EAAIM,EAAE,EAAG,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,EAAG,KAAK,EAAIA,EAAE,CAAC,CACxE,CAEO,OAAgB,CAErB,MAAO,GAAI,KAAK,KAAK,KAAK,CAAC,CAC7B,CAEO,QAAe,CAEpB,OAAO,IAAIN,EAAK,KAAK,EAAG,CAAC,KAAK,EAAG,CAAC,KAAK,EAAG,CAAC,KAAK,CAAC,CACnD,CAEO,OACLO,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACQ,CAER,OACER,GAAOI,EAAMI,EAAMH,EAAME,GACzBN,GAAOI,EAAMC,EAAMH,EAAMK,GACzBN,GAAOC,EAAMI,EAAMH,EAAME,EAE7B,CAEO,YAAYP,EAAe,CAEhC,IAAM7G,EAAI6G,EAAE,IAAI,IAAIN,EAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,CAAC,CAAC,EAAE,IAAIM,EAAE,OAAO,CAAC,EACnE,OAAA7G,EAAE,EAAI,KAAK,EACJA,CACT,CAKO,YAAmB,CACxB,IAAMuH,EAAK,KAAK,IAAI,KAAK,CAAC,EACpBC,EAAK,KAAK,IAAI,KAAK,CAAC,EACpBC,EAAK,KAAK,IAAI,KAAK,CAAC,EAC1B,OAAIF,EAAKC,GAAMD,EAAKE,EACX,KAAK,MAAM,IAAIlB,EAAK,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,UAAU,EACzCiB,EAAKD,GAAMC,EAAKC,EAClB,KAAK,MAAM,IAAIlB,EAAK,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,UAAU,EAE3C,KAAK,MAAM,IAAIA,EAAK,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,UAAU,CAEtD,CAIO,cAActJ,EAAe,CAClC,IAAMD,EAAI,KAAK,UAAU,EAEzB,GADAC,EAAIA,EAAE,UAAU,EACZD,EAAE,IAAIC,CAAC,EAAE,IAAI,EAAImJ,GACnB,OAAO,IAAIG,EAAK,EAAG,EAAG,EAAG,CAAC,EAE5B,IAAIvB,EAAIhI,EAAE,IAAIC,CAAC,EACX+H,EAAE,IAAI,EAAIoB,GACZpB,EAAIA,EAAE,WAAW,EAEjBA,EAAIA,EAAE,UAAU,EAElB,IAAMxJ,EAAIwB,EAAE,MAAMgI,CAAC,EACnB,OAAAxJ,EAAE,EAAIwB,EAAE,IAAIgI,CAAC,EACNxJ,CACT,CAIO,UAAUyB,EAAe,CAC9B,OAAO,KAAK,IAAIA,EAAE,KAAK,CAAC,KAAK,IAAIA,CAAC,GAAK,KAAK,IAAI,EAAIA,EAAE,IAAI,EAAE,CAAC,CAC/D,CAEO,YAAY4J,EAAe,CAEhC,OAAOA,EAAE,IAAI,IAAI,EAAE,IAAIA,EAAE,OAAO,CAAC,CACnC,CAEO,WAAWP,EAAsB,CAEtC,OAAOA,EAAK,IAAKhD,GAAYA,EAAE,YAAY,IAAI,CAAC,CAClD,CAEO,WAAWnD,EAAUuG,EAAwB,CAElD,IAAMgB,EAAM,KAAK,OACf,KAAK,EACL,KAAK,EACL,KAAK,EACLvH,EAAG,EACHA,EAAG,EACHA,EAAG,EACHuG,EAAG,EACHA,EAAG,EACHA,EAAG,CACL,EACA,OAAI,KAAK,IAAIgB,CAAG,EAAItB,GACX,GAEF,IAAIG,EACT,EACA,KAAK,OAAO,KAAK,EAAG,KAAK,EAAG,KAAK,EAAGpG,EAAG,EAAGA,EAAG,EAAGA,EAAG,EAAGuG,EAAG,EAAGA,EAAG,EAAGA,EAAG,CAAC,EACpEgB,EACF,KAAK,OAAO,KAAK,EAAG,KAAK,EAAG,KAAK,EAAGvH,EAAG,EAAGA,EAAG,EAAGA,EAAG,EAAGuG,EAAG,EAAGA,EAAG,EAAGA,EAAG,CAAC,EACpEgB,EACF,KAAK,OAAO,KAAK,EAAG,KAAK,EAAG,KAAK,EAAGvH,EAAG,EAAGA,EAAG,EAAGA,EAAG,EAAGuG,EAAG,EAAGA,EAAG,EAAGA,EAAG,CAAC,EACpEgB,CACJ,CACF,CAEO,KAAKC,EAAmB,CAE7B,OAAIA,EAAIvB,GACC,EAELuB,EAAI,CAACvB,GACA,GAEF,CACT,CAOO,QAAQE,EAA+B,CAC5C,IAAMX,EAAI,KAAK,EACXtF,EAAO,EACP7E,EAAI,KACR,QAASJ,EAAI,EAAGA,EAAIkL,EAAK,OAAQlL,IAC/BiF,GAAQ,GAAM,KAAK,KAAKiG,EAAKlL,CAAA,EAAG,IAAI,IAAI,EAAIuK,CAAC,EAAI,EAEnD,IAAKtF,EAAO,KAAO,EAAG,CACpB7E,EAAI,CAAC,EAEL,IAAMoM,EAAQtB,EAAK,IAAKhD,GAAY,KAAK,KAAKA,EAAE,IAAI,IAAI,EAAIqC,CAAC,CAAC,EAC9D,QAASpK,EAAI,GAAIA,GAAK,EAAGA,GAAK,EAAG,CAC/B,IAAMsM,EAAQ,CAAC,EACf,QAASjF,EAAI,EAAGA,EAAI0D,EAAK,OAAQ1D,IAAK,EAChCgF,EAAMhF,CAAA,IAAOrH,GAAKqM,EAAMhF,CAAA,IAAO,IACjCiF,EAAM,KAAKvB,EAAK1D,CAAA,CAAE,EAEpB,IAAMkF,GAAMlF,EAAI,GAAK0D,EAAK,OAC1B,GAAIsB,EAAMhF,CAAA,EAAKgF,EAAME,CAAA,IAAQ,GAAKF,EAAMhF,CAAA,IAAO,EAAG,CAChD,IAAMmF,EAAKzB,EAAK1D,CAAA,EAAG,IAAI,IAAI,EAAI+C,EACzBqC,EAAM1B,EAAKwB,CAAA,EAAI,IAAI,IAAI,EAAInC,EAC3BnK,EAAIuM,GAAMA,EAAKC,GACfC,EAAK3B,EAAK1D,CAAA,EAAG,KAAK,EAAIpH,CAAC,EAAE,IAAI8K,EAAKwB,CAAA,EAAI,KAAKtM,CAAC,CAAC,EACnDqM,EAAM,KAAKI,CAAE,CACf,CACF,CACAzM,EAAE,KAAKqM,CAAK,CACd,CACF,CACA,OAAOrM,CACT,CAEO,SAAS0M,EAA2B,CAEzC,IAAMC,EAAS,CAAC,EAChB,QAAS9M,EAAI,EAAGA,EAAI6M,EAAM,OAAQ7M,IAAK,CACrC,IAAMiL,EAAO4B,EAAM7M,CAAA,EACb2E,EAAI,KAAK,QAAQsG,CAAI,EACvBtG,GACFmI,EAAO,KAAKnI,EAAE,CAAA,CAAE,EAChBmI,EAAO,KAAKnI,EAAE,CAAA,CAAE,GAEhBmI,EAAO,KAAK7B,CAAI,CAEpB,CACA,OAAO6B,CACT,CAEO,SAAS7B,EAAsB,CAEpC,IAAMX,EAAI,KAAK,EACf,QAASvK,EAAI,EAAGA,EAAIkL,EAAK,OAAQlL,IAAK,CACpC,IAAMG,EAAI,KAAK,KAAK+K,EAAKlL,CAAA,EAAG,IAAI,IAAI,EAAIuK,CAAC,EACzC,GAAIpK,IAAM,EACR,OAAOA,CAEX,CACA,MAAM,IAAI,MAAM,+CAA+C,CACjE,CAEO,UAAUwJ,EAAkB,CAEjC,IAAM/H,EAAI,KAAK,UAAU,EACnBC,EAAI8H,EAAE,UAAU,EACtB,OAAO/H,EAAE,KAAKC,CAAC,EAAImJ,IAAOpJ,EAAE,KAAKC,EAAE,KAAK,EAAE,CAAC,EAAImJ,EACjD,CAEO,QAAQ5K,EAAiB,CAE9B,OAAO,IAAI+K,EAAK/K,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,CAAC,CAC3C,CACF,ECrTM4K,GAAM,KAEL,SAASgC,IAAe,CAC7B,IAAMC,EAAK,KAAK,KAAK,EAAG,EACxB,MAAO,CAAC,IAAI9B,EAAK8B,EAAIA,EAAI,EAAG,CAAC,EAAG,IAAI9B,EAAK8B,EAAI,EAAGA,EAAI,CAAC,CAAC,CACxD,CAEO,SAASC,IAAsB,CACpC,MAAO,CAAC,IAAI/B,EAAK,GAAK,GAAK,GAAK,EAAG,EAAG,IAAIA,EAAK,GAAK,GAAK,GAAK,GAAI,CAAC,CACrE,CAEO,SAASgC,IAAuB,CACrC,IAAMC,EAAO,EAAI,KAAK,GAAM,GACxBC,EAAK,GAAM,GAAM,KAAK,KAAK,CAAC,EAC5BC,EAAK,GAAM,GAAM,KAAK,KAAK,CAAC,EAC1BC,EAAK,KAAK,KAAKF,EAAKA,EAAKC,EAAKA,CAAE,EACtC,OAAAD,GAAME,EACND,GAAMC,EACC,CACL,IAAIpC,EAAK,KAAK,IAAIiC,CAAG,EAAGC,EAAK,KAAK,IAAID,CAAG,EAAGE,EAAK,KAAK,IAAIF,CAAG,EAAG,CAAC,EACjE,IAAIjC,EAAK,GAAK,GAAK,GAAK,EAAG,CAC7B,CACF,CAEO,SAASqC,IAAsB,CACpC,IAAIH,EAAK,mBAAQ,KAAK,KAAK,CAAC,EAAI,EAC5BC,EAAK,EAAI,EAAI,KAAK,KAAK,CAAC,EAAI,EAC1BC,EAAK,KAAK,KAAKF,EAAKA,EAAKC,EAAKA,CAAE,EACtCD,GAAME,EACND,GAAMC,EACN,IAAME,EAAO,EAAI,KAAK,GAAM,EAC5B,MAAO,CACL,IAAItC,EAAK,KAAK,IAAIsC,CAAG,EAAGJ,EAAK,KAAK,IAAII,CAAG,EAAGH,EAAK,KAAK,IAAIG,CAAG,EAAG,CAAC,EACjE,IAAItC,EAAK,KAAK,IAAIsC,CAAG,EAAG,CAACJ,EAAK,KAAK,IAAII,CAAG,EAAGH,EAAK,KAAK,IAAIG,CAAG,EAAG,CAAC,CACpE,CACF,CAEO,SAASC,IAAqB,CACnC,IAAMT,EAAK,KAAK,KAAK,EAAG,EACxB,MAAO,CAAC,IAAI9B,EAAK,GAAK,GAAK,GAAK,EAAG,EAAG,IAAIA,EAAK8B,EAAI,EAAG,EAAGA,CAAE,CAAC,CAC9D,CAEO,SAASU,GAAQ5M,EAAmB,CAKzC,IAAM0K,EAAI,CAAC,IAAIN,EAAK,EAAG,EAAG,EAAG,CAAC,CAAC,EAC/B,QAASnL,EAAI,EAAGA,EAAIyL,EAAE,OAAQzL,IAC5B,QAASC,EAAI,EAAGA,EAAIc,EAAE,OAAQd,IAAK,CACjC,IAAM2N,EAAK7M,EAAEd,CAAA,EAAG,IAAIwL,EAAEzL,CAAA,CAAE,EAClB6N,EAAQD,EAAG,KAAK,EAAE,EACpBE,EAAU,GACd,QAAStG,EAAI,EAAGA,EAAIiE,EAAE,OAAQjE,IAC5B,GAAIoG,EAAG,KAAKnC,EAAEjE,CAAA,CAAE,EAAIwD,IAAO6C,EAAM,KAAKpC,EAAEjE,CAAA,CAAE,EAAIwD,GAAK,CACjD8C,EAAU,GACV,KACF,CAEGA,GACHrC,EAAE,KAAKmC,CAAE,CAEb,CAEF,OAAOnC,CACT,CAEO,SAASsC,GAAapE,EAAS5I,EAAmB,CAIvD,IAAMwK,EAAS,CAAC,EACVyC,EAAW,CAAC,EAClB,QAAShO,EAAI,EAAGA,EAAIe,EAAE,OAAQf,IAAK,CACjC,IAAM+E,EAAK4E,EAAE,YAAY5I,EAAEf,CAAA,CAAE,EACzB8N,EAAU,GACd,QAAS7N,EAAI,EAAGA,EAAIsL,EAAO,OAAQtL,IACjC,GAAI8E,EAAG,KAAKwG,EAAOtL,CAAA,CAAE,EAAI+K,GAAK,CAC5B8C,EAAU,GACV,KACF,CAEGA,IACHvC,EAAO,KAAKxG,CAAE,EACdiJ,EAAS,KAAKjN,EAAEf,CAAA,CAAE,EAEtB,CACA,OAAOgO,CACT,CAEO,SAASC,GAAQ1C,EAAwB,CAM9C,IAAML,EAAe,CAAC,EACtB,QAASlL,EAAI,EAAGA,EAAIuL,EAAO,OAAQvL,IACjC,QAASC,EAAID,EAAI,EAAGC,EAAIsL,EAAO,OAAQtL,IAAK,CAC1C,IAAM0J,EAAIyB,GAAiB,EAAGpL,EAAGC,EAAGsL,CAAM,EAC1C,GAAI5B,EAAG,CACL,IAAImE,EAAU,GACd,QAAStG,EAAI,EAAGA,EAAI0D,EAAK,OAAQ1D,IAC/B,GAAImC,EAAE,KAAKuB,EAAK1D,CAAA,CAAE,EAAIwD,GAAK,CACzB8C,EAAU,GACV,KACF,CAEGA,GACH5C,EAAK,KAAKvB,CAAC,CAEf,CACF,CAEF,OAAS,CACP,IAAIpC,EAAU,GACd,QAAS,EAAI,EAAG,EAAI2D,EAAK,OAAQ,IAAK,CACpC,IAAMjL,GAAa,EAAI,GAAKiL,EAAK,OACjC,GAAIK,EAAO,CAAA,EAAG,IAAIL,EAAK,CAAA,EAAG,MAAMA,EAAKjL,CAAA,CAAE,CAAC,EAAI,EAAG,CAC7C,IAAM2E,EAAUsG,EAAK,CAAA,EACrBA,EAAK,CAAA,EAAKA,EAAKjL,CAAA,EACfiL,EAAKjL,CAAA,EAAK2E,EACV2C,EAAU,EACZ,CACF,CACA,GAAI,CAACA,EACH,KAEJ,CACA,OAAO2D,CACT,CC/IA,IAAMgD,GAAN,KAAqB,CAEnB,aAAc,CACZ,KAAK,KAAO,CAAC,CACf,CAEO,SAAS7J,EAAiB,CAC/B,QAAS8J,EAAI,EAAGA,EAAIA,GAAK9J,EAAG8J,IAC1B,KAAO9J,EAAI8J,IAAM,GACG,KAAK,KAAKA,CAAA,IAAxB,OACF,KAAK,KAAKA,CAAA,IAEV,KAAK,KAAKA,CAAA,EAAK,EAEjB9J,GAAK8J,EAGL9J,EAAI,IACY,KAAK,KAAKA,CAAA,IAAxB,OACF,KAAK,KAAKA,CAAA,IAEV,KAAK,KAAKA,CAAA,EAAK,EAGrB,CAEO,UAAmB,CACxB,IAAIjE,EAAI,GACR,QAASJ,EAAI,EAAGA,EAAI,KAAK,KAAK,OAAQA,IAClB,KAAK,KAAKA,CAAA,IAAxB,SACEI,IAAM,KACRA,GAAK,KAEPA,GAAKJ,EACD,KAAK,KAAKA,CAAA,EAAK,IACjBI,GAAK,IAAI,KAAK,KAAKJ,CAAA,MAIzB,OAAOI,CACT,CACF,EAEO,SAASgO,GAAarN,EAAWiJ,EAAmC,CACzE,IAAM3F,EAAItD,EAAE,CAAA,EAAG,EAAE,OACXsN,EAAI7J,GAASH,CAAC,EAChBiK,EAAgB,CAAC,EACjBC,EAAiB,CAAC,EAClBC,EAAqB,CAAC,EACtBC,EAAe,CAAC,EAChBC,EAAoB,CAAC,EACzB,SAASC,EAAQhF,EAAkB,CACjC,QAAS3J,EAAI2J,EAAE,EAAE,OAAS,EAAG3J,GAAK,EAAGA,IAAK,CACxC,IAAMC,EAAI0J,EAAE,EAAE3J,CAAA,EACd,GAAIC,IAAMD,EAAG,CACX,GAAI,CAACsO,EAAItO,CAAA,EAAGC,CAAA,EACV,MAAO,GAET0J,EAAIA,EAAE,IAAI4E,EAAKvO,CAAA,EAAGC,CAAA,CAAE,CACtB,CACF,CACA,MAAO,EACT,CACA,SAAS2O,EAAOpH,EAAWmC,EAASkF,EAAmB,CACrDJ,EAAGjH,CAAA,EAAG,KAAKmC,CAAC,EACZ+E,EAAMlH,CAAA,EAAG,KAAKqH,CAAG,EACjB,QAAS7O,EAAI,EAAGA,EAAIsO,EAAI9G,CAAA,EAAG,OAAQxH,IAC7BsO,EAAI9G,CAAA,EAAGxH,CAAA,GACT8O,EAAOtH,EAAG8G,EAAI9G,CAAA,EAAGxH,CAAA,EAAG,IAAI2J,CAAC,EAAGkF,EAAML,EAAOhH,CAAA,EAAGxH,CAAA,CAAE,CAGpD,CACA,SAAS8O,EAAOtH,EAAWmC,EAASkF,EAAmB,CACrD,IAAM5O,EAAI0J,EAAE,EAAEnC,CAAA,EACd,GAAI,CAAC8G,EAAI9G,CAAA,EAAGvH,CAAA,EAAI,CACdqO,EAAI9G,CAAA,EAAGvH,CAAA,EAAK0J,EACZ4E,EAAK/G,CAAA,EAAGvH,CAAA,EAAK0J,EAAE,IAAI,EACnB6E,EAAOhH,CAAA,EAAGvH,CAAA,EAAK4O,EACf,QAAS7O,EAAI,EAAGA,EAAIyO,EAAGjH,CAAA,EAAG,OAAQxH,IAChC8O,EAAOtH,EAAGmC,EAAE,IAAI8E,EAAGjH,CAAA,EAAGxH,CAAA,CAAE,EAAG6O,EAAMH,EAAMlH,CAAA,EAAGxH,CAAA,CAAE,EAE9C,MACF,CACA,IAAM+E,EAAK4E,EAAE,IAAI4E,EAAK/G,CAAA,EAAGvH,CAAA,CAAE,EACtB0O,EAAQ5J,CAAE,GACb6J,EAAOpH,EAAI,EAAGzC,EAAI8J,EAAML,EAAOhH,CAAA,EAAGvH,CAAA,CAAE,CAExC,CACA,SAAS8O,GAAiB,CACxBT,EAAM,CAAC,EACPC,EAAO,CAAC,EACRE,EAAK,CAAC,EACND,EAAS,CAAC,EACVE,EAAQ,CAAC,EACT,QAAS1O,EAAI,EAAGA,EAAIqE,EAAGrE,IACrBsO,EAAI,KAAK,CAAC,CAAC,EACXC,EAAK,KAAK,CAAC,CAAC,EACZC,EAAO,KAAK,CAAC,CAAC,EACdC,EAAG,KAAK,CAAC,CAAC,EACVC,EAAM,KAAK,CAAC,CAAC,EACbJ,EAAItO,CAAA,EAAGA,CAAA,EAAKqO,EACZE,EAAKvO,CAAA,EAAGA,CAAA,EAAKqO,EACbG,EAAOxO,CAAA,EAAGA,CAAA,EAAK,EAEjB,IAAIgP,EAAO,EACPC,EAAK,OAAO,CAAC,EACjB,QAASjP,EAAI,EAAGA,EAAIe,EAAE,OAAQf,IAAK,CACjC4O,EAAOvK,EAAI,EAAGtD,EAAEf,CAAA,EAAI,CAAC,EACrBiP,EAAK,OAAO,CAAC,EACb,IAAIC,EAAM,EACNC,EAAS,EACPC,EAAO,CAAC,EACRC,EAAQ,IAAInB,GAClB,QAASjO,EAAI,EAAGA,EAAIoE,EAAGpE,IAAK,CAC1B,IAAI4K,EAAM,EACNyE,EAAS,EACb,QAAS9H,EAAI,EAAGA,EAAInD,EAAGmD,IACjB8G,EAAIrO,CAAA,EAAGuH,CAAA,IACTqD,IACAyE,GAAUd,EAAOvO,CAAA,EAAGuH,CAAA,EAChBvH,IAAMuH,GACRwH,KAINE,GAAOT,EAAGxO,CAAA,EAAG,OACbgP,GAAM,OAAOpE,CAAG,EACZA,EAAM,GACRwE,EAAM,SAASxE,CAAG,EAEpB,IAAM0E,EAAMD,EAASzE,EACrBuE,EAAK,KAAKG,CAAG,EACbJ,GAAUI,CACZ,CACAvF,EACE,GAAGhK,SAASiP,OAAQC,SAAWC,UAAeH,WAAcK,EAAM,SAAS,GAC7E,CACF,CACA,OAAOJ,CACT,CACA,OAAOF,EAAO,CAChB,CCzDA,IAAMS,GAAN,KAAW,CAGT,YAAYC,EAAW,CACrB,KAAK,OAAS,IAAI,MAAMA,EAAE,OAAS,CAAC,EACpC,QAASC,EAAI,EAAGA,EAAID,EAAE,OAAQC,IAC5B,KAAK,OAAO,EAAIA,CAAA,EAAKD,EAAEC,CAAA,EAAG,EAC1B,KAAK,OAAO,EAAIA,EAAI,CAAA,EAAKD,EAAEC,CAAA,EAAG,EAC9B,KAAK,OAAO,EAAIA,EAAI,CAAA,EAAKD,EAAEC,CAAA,EAAG,EAEhC,KAAK,OAASD,EAAE,MAClB,CAEA,IAAIE,EAAmB,CACrB,OAAO,IAAIC,EACT,EACA,KAAK,OAAO,EAAID,CAAA,EAChB,KAAK,OAAO,EAAIA,EAAM,CAAA,EACtB,KAAK,OAAO,EAAIA,EAAM,CAAA,CACxB,CACF,CAEA,YAAmB,CACjB,IAAIE,EAAK,EACLC,EAAK,EACLC,EAAK,EACT,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAC/BF,GAAM,KAAK,OAAO,EAAI,CAAA,EACtBC,GAAM,KAAK,OAAO,EAAI,EAAI,CAAA,EAC1BC,GAAM,KAAK,OAAO,EAAI,EAAI,CAAA,EAE5B,OAAO,IAAIH,EAAK,EAAGC,EAAK,KAAK,OAAQC,EAAK,KAAK,OAAQC,EAAK,KAAK,MAAM,CACzE,CAEA,OAAON,EAAe,CACpB,IAAMO,EAAI,CAAC,EACX,QAASN,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BM,EAAE,KAAK,KAAK,IAAIN,CAAC,EAAE,YAAYD,CAAC,CAAC,EAEnC,OAAO,IAAID,GAAKQ,CAAC,CACnB,CAEA,eAAsB,CACpB,IAAMA,EAAI,CAAC,EACX,QAASN,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BM,EAAE,KAAK,KAAK,IAAIN,CAAC,CAAC,EAEpB,OAAAM,EAAE,KAAK,KAAK,IAAI,CAAC,CAAC,EACX,IAAIR,GAAKQ,CAAC,CACnB,CACF,EAEaC,GAAN,KAAe,CACpB,YACUC,EACAC,EACAC,EACR,CAHQ,KAAA,KAAAF,EACA,KAAA,KAAAC,EACA,KAAA,MAAAC,CACP,CAEI,MAAMX,EAAmB,CAC9B,IAAMY,EAAIZ,EAAE,QAAQ,KAAK,IAAI,EAC7B,OAAIY,IAAM,OACJ,KAAK,OAAS,QAChB,KAAK,KAAO,IAAIJ,GAASI,EAAE,CAAA,CAAE,EAC7B,KAAK,MAAQ,IAAIJ,GAASI,EAAE,CAAA,CAAE,IAE9B,KAAK,KAAO,KAAK,MAAM,MAAMZ,CAAC,EAC9B,KAAK,MAAQ,KAAK,OAAO,MAAMA,CAAC,IAG7B,IACT,CAEO,QAAQa,EAAaC,EAA4B,CACtD,OAAI,KAAK,OAAS,OAChBD,EAAI,KAAK,IAAId,GAAK,KAAK,IAAI,CAAC,EACnBe,GACT,KAAK,MAAM,QAAQD,EAAK,EAAK,EAC7B,KAAK,OAAO,QAAQA,EAAK,EAAI,IAE7B,KAAK,OAAO,QAAQA,EAAK,EAAK,EAC9B,KAAK,MAAM,QAAQA,EAAK,EAAI,GAEvBA,CACT,CACF,EAEO,SAASE,GAAYC,EAAcC,EAAuB,CAE/D,IAAMC,EAAS,CAAC,EAChB,QAAWC,KAAOH,EAChB,QAAWP,KAAQQ,EACjBC,EAAO,KAAKT,EAAK,OAAOU,CAAG,CAAC,EAGhC,OAAOD,CACT,CAmBA,IAAME,EAAc,KACdC,GAAY,mDACZC,GAAyB,GAuB/B,SAASC,IAAmB,CAC1B,MAAO,CAEL,EAAG,CAAC,CAAC,IAAK,IAAK,IAAK,GAAG,CAAC,EAExB,EAAG,CACD,CAAC,IAAK,IAAK,IAAK,IAAK,GAAG,EACxB,CAAC,IAAK,IAAK,GAAI,IAAK,EAAE,CACxB,EAEA,EAAG,CACD,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,KAAM,EAAE,EACnB,CAAC,KAAM,IAAK,GAAI,IAAI,EACpB,CAAC,KAAM,KAAM,IAAK,IAAI,CACxB,EAEA,GAAI,CACF,CAAC,IAAK,IAAK,GAAI,GAAI,GAAI,EAAE,EACzB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAC7B,CAAC,IAAK,IAAK,GAAI,GAAI,IAAK,EAAE,EAC1B,CAAC,IAAK,IAAK,GAAI,KAAM,GAAI,EAAE,EAC3B,CAAC,KAAM,IAAK,KAAM,KAAM,IAAK,GAAG,CAClC,EAEA,GAAI,CACF,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,EAAE,EAClB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnB,CAAC,IAAK,IAAK,IAAK,EAAE,CACpB,CACF,CACF,CAGA,SAASC,IAAqB,CAC5B,MAAO,CAEL,EAAG,CAAE,EAAG,UAAW,EAAG,UAAW,EAAG,UAAW,EAAG,SAAU,EAC5D,EAAG,CACD,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,SACL,EACA,EAAG,CACD,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,GAAI,UACJ,EAAG,UACH,GAAI,UACJ,GAAI,SACN,EACA,GAAI,CACF,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,GAAI,UACJ,GAAI,UACJ,GAAI,UACJ,EAAG,UACH,EAAG,SACL,EACA,GAAI,CACF,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,SACL,CACF,CACF,CAUA,IAAMC,GAAsB,CAC1B,EAAG,CACD,EAAG,CAAC,MAAO,MAAO,MAAO,KAAK,EAC9B,EAAG,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,EACtC,EAAG,CAAC,KAAM,KAAM,KAAM,IAAI,CAC5B,EACA,EAAG,CACD,EAAG,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAK,EAC1D,EAAG,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,EAC1E,EAAG,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,CACxC,EACA,EAAG,CACD,EAAG,CAAC,SAAU,OAAQ,SAAU,UAAW,QAAS,OAAO,EAC3D,EAAG,CACD,KACA,MACA,KACA,MACA,MACA,KACA,MACA,KACA,KACA,MACA,OACA,MACF,EACA,EAAG,CAAC,MAAO,KAAM,KAAM,MAAO,KAAM,MAAO,KAAM,KAAK,CACxD,EACA,GAAI,CACF,EAAG,CACD,MACA,MACA,OACA,QACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,QACA,SACA,QACA,MACF,EACA,EAAG,CACD,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,OACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,KACF,EACA,EAAG,CACD,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,KACF,CACF,EACA,GAAI,CACF,EAAG,CACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OACF,EACA,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACF,EACA,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACF,CACF,CACF,EAYA,SAASC,IAA6D,CACpE,MAAO,CACL,EAAG,CACD,CAAC,MAAO,CAAC,EAAG,EAAG,CAAC,CAAC,EACjB,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,CACjB,EACA,EAAG,CACD,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,EACf,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,CACjB,EACA,EAAG,CACD,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,EACf,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,CACjB,EACA,GAAI,CACF,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,EACf,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,CACjB,EACA,GAAI,CACF,CAAC,QAAS,CAAC,EAAG,EAAG,CAAC,CAAC,EACnB,CAAC,IAAK,CAAC,EAAG,EAAG,CAAC,CAAC,CACjB,CACF,CACF,CAEA,SAASC,GAAYpB,EAAaqB,EAAiB,CAEjD,QAAS3B,EAAI,EAAGA,EAAIM,EAAE,OAAQN,IAC5B,GAAIM,EAAEN,CAAA,EAAG,CAAA,EAAG,KAAK2B,CAAC,EAAIR,EACpB,OAAOnB,EAGX,MAAM,IAAI,MAAM,mBAAmB,CACrC,CAEO,SAAS4B,IAEd,CAEA,OAAOC,EACT,CAEO,SAASC,GACdC,EACyB,CAEzB,OAAOF,GAAUE,CAAA,CACnB,CAEO,IAAMC,GAAqB,CAAC,IAAK,IAAK,IAAK,IAAK,GAAG,EAG7CC,GAAmB,CAAC,IAAK,IAAK,GAAG,EASvC,SAASC,GACdC,EAC0B,CAE1B,IAAM7B,EAAI6B,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,EACrC,GAAI7B,EAAE,OAAS,IAAM,EACnB,OAAO,KAET,IAAM8B,EAAQ9B,EAAE,CAAA,EAChB,GACE8B,IAAU,KACVA,IAAU,KACVA,IAAU,KACVA,IAAU,KACVA,IAAU,IAEV,OAAO,KAET,IAAMC,EAA+B,CAAC,EACtC,QAASrC,EAAI,EAAGA,EAAIM,EAAE,OAAQN,GAAK,EAAG,CACpC,GAAIM,EAAEN,CAAA,IAAO,KAAOM,EAAEN,CAAA,IAAO,KAAOM,EAAEN,CAAA,IAAO,IAC3C,OAAO,KAETqC,EAAK,KAAK,CACR,QAAS/B,EAAEN,CAAA,EACX,SAAU,WAAWM,EAAEN,EAAI,CAAA,CAAE,CAC/B,CAAC,CACH,CACA,MAAO,CAAE,MAAAoC,EAAO,KAAAC,CAAK,CACvB,CAEO,SAASC,GACdC,EACAC,EAAiC,CAAC,EAClB,CAChB,IAAMC,EAASP,GAAuBK,CAAI,EAC1C,GAAIE,IAAW,KACb,MAAM,IAAI,MAAM,wCAAwC,EAE1D,IAAMC,EAAK,IAAIC,GACbF,EACA,OAAO,OAAO,CAAC,EAAG,CAAE,SAAU,EAAK,EAA4BD,CAAO,CACxE,EACA,OAAAE,EAAG,YAAY,EACfA,EAAG,SAAS,EACLA,CACT,CAEO,SAASE,GACdb,EACAS,EACgB,CAChB,OAAOF,GAAwBT,GAAUE,CAAA,EAAaS,CAAO,CAC/D,CAEA,SAASK,GACPC,EACAC,EACAC,EACmB,CAInB,IAAIC,EAAW,GACXD,EAASD,EAAK,CAAA,EAAKA,EAAK,CAAA,IAE1BD,EAAM,CAACA,EAAI,CAAA,EAAIA,EAAI,CAAA,EAAIA,EAAI,CAAA,EAAIA,EAAI,CAAA,CAAE,EACrCC,EAAO,CAACC,EAASD,EAAK,CAAA,EAAIC,EAASD,EAAK,CAAA,CAAE,EAC1CE,EAAW,IAEb,IAAIC,EAAiBJ,EAAI,CAAA,EACrBK,EAAiB,GACrB,GAAIJ,EAAK,CAAA,IAAO,GAAKA,EAAK,CAAA,IAAOC,EAC/BE,EAAiB,GAAGA,aACXH,EAAK,CAAA,IAAOA,EAAK,CAAA,EACtBA,EAAK,CAAA,EAAK,IACZI,EAAiB,OAAOJ,EAAK,CAAA,EAAK,CAAC,WAE5BA,EAAK,CAAA,IAAO,EACrBG,EAAiBA,EAAe,YAAY,EACxCH,EAAK,CAAA,EAAK,IACZI,EAAiB,OAAOJ,EAAK,CAAA,EAAK,CAAC,OAGrC,OAAM,IAAI,MACR,0DAA0DA,GAC5D,EAEF,MAAO,CAACI,EAAiBD,EAAgBD,CAAQ,CACnD,CAIA,SAASG,GAAiBjB,EAAWkB,EAAyC,CAC5E,IAAMC,EAAc,CAAC,EACjBC,EAAK,EACT,KAAOA,EAAKpB,EAAE,QAAQ,CAChBoB,EAAK,GAAKA,EAAKpB,EAAE,QAAUA,EAAEoB,CAAA,IAAQ,KACvCA,IAEF,IAAIC,EAAe,GACnB,QAAWC,KAAYJ,EAEnBlB,EAAE,OAAOoB,CAAE,EAAE,WAAWE,EAAS,CAAA,CAAE,GACnCA,EAAS,CAAA,EAAG,OAASD,EAAa,SAElCA,EAAeC,EAAS,CAAA,GAG5B,GAAID,IAAiB,GACnBF,EAAE,KAAKE,CAAY,EACnBD,GAAMC,EAAa,WAEnB,OAAM,IAAI,MAAM,mBAAmBrB,oBAAoB,CAE3D,CACA,OAAOmB,CACT,CAEA,SAASI,GAAS3D,EAAS4D,EAA2B,CACpD,MAAO,CAAC5D,EAAE,EAAI4D,EAAS,CAAC5D,EAAE,EAAI4D,EAAS5D,EAAE,EAAI4D,CAAO,CACtD,CAEA,SAASC,GAAa7D,EAAS4D,EAA2B,CACxD,IAAML,EAAI,CAAC,EACLO,EAAI9D,EAAE,OACZ,QAASC,EAAI,EAAGA,EAAI6D,EAAG7D,IAAK,CAC1B,IAAM8D,EAAKJ,GAAS3D,EAAE,IAAI8D,EAAI7D,EAAI,CAAC,EAAG2D,CAAO,EAC7CL,EAAE,EAAItD,CAAA,EAAK8D,EAAG,CAAA,EACdR,EAAE,EAAItD,EAAI,CAAA,EAAK8D,EAAG,CAAA,EAClBR,EAAE,EAAItD,EAAI,CAAA,EAAK8D,EAAG,CAAA,CACpB,CACA,OAAOR,CACT,CAGO,IAAMX,GAAN,KAAqB,CA0D1B,YACSoB,EACPvB,EACA,CAFO,KAAA,kBAAAuB,EAvBT,KAAO,cAA8B,CAAC,EAUtC,KAAQ,gBAA4B,CAAC,EACrC,KAAQ,iBAA6B,CAAC,EACtC,KAAQ,WAAqB,GAC7B,KAAQ,IAAkB,CAAC,EAC3B,KAAQ,OAAc,CAAC,EAEvB,KAAO,eAAiC,IAAIC,GAC5C,KAAQ,kBAA4B,GACpC,KAAQ,aAAwB,GAQ9B,IAAMC,EAAY,WAClB,KAAK,QAAU,IAAIC,GAA0B1B,CAAO,EAChD,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,KAAK,OAAO,IAAI,CAAC,EAE/B,KAAK,OAAOuB,CAAiB,CAE/B,CAEO,OAAOA,EAA4C,CACxD,GAAM,CAAE,MAAA3B,EAAO,KAAAC,CAAK,EAAI0B,EAOxB,KAAK,WAAa,CAAC,EACnB,KAAK,YAAc,CAAC,EACpB,KAAK,MAAQ,CAAC,EACd,KAAK,OAAS,CAAC,EACf,IAAII,EAAI,KACR,OAAQ/B,EAAO,CACb,IAAK,IAAK,CACR+B,EAAIC,GAAK,EACT,KACF,CACA,IAAK,IAAK,CACRD,EAAIE,GAAW,EACf,KACF,CACA,IAAK,IAAK,CACRF,EAAIG,GAAY,EAChB,KACF,CACA,IAAK,IAAK,CACRH,EAAII,GAAY,EAChB,KACF,CACA,IAAK,IAAK,CACRJ,EAAIK,GAAa,EACjB,KACF,CACA,QACE,MAAM,IAAI,MAAM,uBAAuBpC,GAAO,CAClD,CACA,KAAK,UAAYqC,GAAQN,CAAC,EACtB,KAAK,QAAQ,WACf,QAAQ,IAAI,gBAAgB,KAAK,UAAU,QAAQ,EAErD,IAAMO,EAAYP,EAAE,CAAA,EACpB,KAAK,aAAeQ,GAAaD,EAAW,KAAK,SAAS,EAC1D,IAAME,EAAa,KAAK,aAAa,IAAKC,GAAMH,EAAU,YAAYG,CAAC,CAAC,EACxE,KAAK,WAAaD,EAClB,KAAK,cAAgBA,EAAW,OAChC,IAAME,EAAMxD,GAAY,EAAEsD,EAAW,MAAA,EACrC,KAAK,IAAME,EACX,KAAK,OAASvD,GAAc,EAAEqD,EAAW,MAAA,EACrC,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,kBAAkBA,EAAW,QAAQ,EAEnD,IAAMG,EAAWC,GAAQJ,CAAU,EAC7BK,EAAO,IAAI/E,EAAK,EAAG,EAAG,EAAG,CAAC,EAC5B,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,oBAAoB6E,EAAS,QAAQ,EAEnD,IAAMG,EAAaN,EAAW,CAAA,EAAG,WAAW,EACtCO,EAAaJ,EAAS,CAAA,EAAG,IAAIA,EAAS,CAAA,CAAE,EAAE,WAAW,EACrDK,EAAeL,EAAS,CAAA,EAAG,WAAW,EACtCM,EAAW,IAAInF,EAAK,EAAGgF,EAAW,EAAGA,EAAW,EAAGA,EAAW,CAAC,EACjE,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,iBAAiBG,GAAU,EAGzC,IAAMC,EADWX,GAAaU,EAAU,KAAK,SAAS,EAC9B,IAAKR,GAAMQ,EAAS,YAAYR,CAAC,CAAC,EACpDU,EAAYP,GAAQM,CAAM,EAChC,KAAK,aAAeC,EAAU,CAAA,EAC3B,IAAIA,EAAU,CAAA,CAAE,EAChB,KAAK,EAAG,EACR,KAAKN,CAAI,EACZ,KAAK,eAAiBM,EAAU,CAAA,EAAG,KAAKN,CAAI,EAC5C,IAAMO,EAAY,CAAC,EACbC,EAAa,CAAC,EAChBC,EAAU,GACVC,EAAU,GACVC,EAAY,GAChB,QAAWC,KAAOxD,EAAM,CACtB,IAAIyD,EAAS,KACTC,EAAW,EACf,OAAQF,EAAI,QAAS,CACnB,IAAK,IAAK,CACRC,EAASZ,EACTa,EAAW,EACXL,EAAU,GACV,KACF,CACA,IAAK,IAAK,CACRI,EAASV,EACTW,EAAW,KAAK,eAChBH,EAAY,GACZ,KACF,CACA,IAAK,IAAK,CACRE,EAASX,EACTY,EAAW,KAAK,aAChBJ,EAAU,GACV,KACF,CACA,QACE,MAAM,IAAI,MAAM,qBAAqBE,EAAI,SAAS,CACtD,CACAL,EAAU,KAAKM,EAAO,QAAQD,EAAI,QAAQ,CAAC,EAC3CJ,EAAW,KAAKI,EAAI,SAAWE,CAAQ,CACzC,CACI,KAAK,QAAQ,eACVL,GACHF,EAAU,KAAKN,EAAW,QAAQ,EAAE,CAAC,EAElCU,GACHJ,EAAU,KAAKJ,EAAa,QAAQ,EAAE,CAAC,EAEpCO,GACHH,EAAU,KAAKL,EAAW,QAAQ,EAAE,CAAC,GAGzC,KAAK,UAAY,CAAC,EAClB,QAAWa,KAAgB,KAAK,aAAc,CAC5C,IAAMxF,EAAOwF,EAAa,WAAWT,CAAS,EAC9C,KAAK,UAAU,KAAK,IAAIzF,GAAKU,CAAI,CAAC,CACpC,CASA,IAAM6C,EAAgC,CAAC,EACjC4C,EAA+B,CAAC,EAChCC,EAAqB,CAAC,EACtBC,EAAmB,CAAC,EACpBC,EAAeb,EAAU,OAC/B,SAASc,EAAiB/F,EAAUqB,EAAS2E,EAAiB,CAC5D,QAAWC,KAAMjG,EACf,GAAIiG,EAAG,CAAA,EAAG,KAAK5E,CAAC,EAAIR,EAAK,CACvBoF,EAAG,KAAKD,CAAI,EACZ,MACF,CAEFhG,EAAE,KAAK,CAACqB,EAAG2E,CAAI,CAAC,CAClB,CACA,QAAStG,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQA,IAAK,CACjD,IAAMQ,EAAO,KAAK,aAAaR,CAAA,EAAG,WAAWuF,CAAS,EACtD,QAASiB,EAAI,EAAGA,EAAIhG,EAAK,OAAQgG,IAAK,CACpC,IAAMC,GAAMD,EAAI,GAAKhG,EAAK,OACpBkG,EAAWlG,EAAKgG,CAAA,EAAG,IAAIhG,EAAKiG,CAAA,CAAG,EAAE,KAAK,EAAG,EAC/CJ,EAAiBF,EAAWO,EAAU1G,CAAC,CACzC,CACF,CACA,IAAM2G,EAAa,CAAC,EACpB,QAAS3G,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQA,IAAK,CACjD,IAAMQ,EAAO,KAAK,aAAaR,CAAA,EAAG,WAAWuF,CAAS,EAChDqB,EAAW,CAAC,EAClB,QAASJ,EAAI,EAAGA,EAAIhG,EAAK,OAAQgG,IAAK,CACpC,IAAMC,GAAMD,EAAI,GAAKhG,EAAK,OACpBkG,EAAWlG,EAAKgG,CAAA,EAAG,IAAIhG,EAAKiG,CAAA,CAAG,EAAE,KAAK,EAAG,EACzCF,EAAKJ,EAAUzE,GAAYyE,EAAWO,CAAQ,CAAA,EACpD,GAAI1G,IAAMuG,EAAG,CAAA,EACXK,EAAS,KAAKL,EAAG,CAAA,CAAE,UACVvG,IAAMuG,EAAG,CAAA,EAClBK,EAAS,KAAKL,EAAG,CAAA,CAAE,MAEnB,OAAM,IAAI,MAAM,qBAAqB,CAEzC,CACAI,EAAW,KAAKC,CAAQ,CAC1B,CACA,IAAMC,EAAuB,CAAC,EACxBC,EAA4B,CAAC,EACnCA,EAAgB,KAAKhC,EAAI,CAAA,EAAG,CAAA,CAAE,EAC9B+B,EAAgB/B,EAAI,CAAA,EAAG,CAAA,CAAA,EAAM,EAC7BgC,EAAgBH,EAAW,CAAA,EAAG,CAAA,CAAA,EAAM7B,EAAI,CAAA,EAAG,CAAA,EAC3C+B,EAAgB/B,EAAI,CAAA,EAAG,CAAA,CAAA,EAAM6B,EAAW,CAAA,EAAG,CAAA,EAC3C,QAAWI,KAAQjC,EAAK,CACtB,IAAMkC,EAAKD,EAAK,CAAA,EACVE,EAAKJ,EAAgBG,CAAA,EAC3B,GAAIC,IAAO,OACT,MAAM,IAAI,MAAM,gDAAgD,EAElE,IAAIC,EAAK,GACT,QAASV,EAAI,EAAGA,EAAIG,EAAWM,CAAA,EAAI,OAAQT,IAAK,CAC9C,IAAMW,EAAML,EAAgBH,EAAWM,CAAA,EAAIT,CAAA,CAAA,EAC3C,GAAIW,IAAQ,QAAaA,IAAQJ,EAAK,CAAA,EAAI,CACxCG,EAAKV,EACL,KACF,CACF,CACA,GAAIU,EAAK,EACP,MAAM,IAAI,MAAM,kCAAkC,EAEpD,QAASV,EAAI,EAAGA,EAAIO,EAAK,OAAQP,IAAK,CACpC,GAAIO,EAAKP,CAAA,IAAO,GACd,SAEF,IAAMY,EAAKT,EAAWM,CAAA,GAAKT,EAAIU,EAAK,GAAKd,CAAA,EACnCe,EAAML,EAAgBM,CAAA,EAC5B,GAAID,IAAQ,QAAaA,IAAQJ,EAAKP,CAAA,EACpC,MAAM,IAAI,MAAM,sBAAsB,EAExCM,EAAgBM,CAAA,EAAML,EAAKP,CAAA,EAC3BK,EAAgBE,EAAKP,CAAA,CAAA,EAAMY,CAC7B,CACF,CACA,QAASpH,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQA,IAAK,CACjD,IAAMQ,EAAO,KAAK,aAAaR,CAAA,EAAG,WAAWuF,CAAS,EAChD8B,EAAYhC,EAAS,YAAY,KAAK,aAAarF,CAAA,CAAE,EACrDyD,EAAWqD,EAAgB9G,CAAA,EACjCqD,EAAU,KAAK,CAAC7C,EAAMiD,CAAQ,CAAC,EAC/BwC,EAAW,KAAK,CAACoB,EAAW5D,CAAQ,CAAC,CACvC,CACA,QAASzD,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQA,IAAK,CACjD,IAAMQ,EAAO,KAAK,aAAaR,CAAA,EAAG,WAAWuF,CAAS,EAChD9B,EAAWqD,EAAgB9G,CAAA,EACjC,QAASwG,EAAI,EAAGA,EAAIhG,EAAK,OAAQgG,IAAK,CACpC,IAAMC,GAAMD,EAAI,GAAKhG,EAAK,OACpBkG,EAAWlG,EAAKgG,CAAA,EAAG,IAAIhG,EAAKiG,CAAA,CAAG,EAAE,KAAK,EAAG,EACzCa,GAAOd,EAAI,GAAKhG,EAAK,OACrB+G,GAAY/G,EAAKiG,CAAA,EAAI,IAAIjG,EAAK8G,CAAA,CAAI,EAAE,KAAK,EAAG,EAC5CE,GAAK9F,GAAYyE,EAAWO,CAAQ,EACpCe,GAAK/F,GAAYyE,EAAWoB,EAAS,EAC3ClB,EAAiBH,EAAa1F,EAAKiG,CAAA,EAAK,CAAChD,EAAUgE,GAAID,EAAE,CAAC,CAC5D,CACF,CACA,KAAK,SAAW,IAAIE,GAAiBrE,EAAU,IAAKwB,GAAMA,EAAE,CAAA,CAAE,CAAC,EAC/D,IAAM8C,EAAM,KAAK,SAAS,WAAa,GAAK,IAEtCC,EAAUpG,GAAoB,KAAK,aAAA,EACnCqG,EAAa,CAAC,EACpB,QAAS7H,EAAI,EAAGA,EAAI,KAAK,cAAeA,IACtC6H,EAAW,GAAK7H,CAAA,EAAKA,EAGvB,CACE,IAAM8H,EAAWF,EAAQ,EACzB,QAAWtB,KAAQwB,EAAU,CAC3B,IAAMC,EAAK,KAAK,SAAS,iBAAiBzB,CAAI,EAC1CvD,EAAO,EACX,QAAW/C,KAAK+H,EACdhF,GAAQ,GAAK/C,EAEf6H,EAAW9E,CAAA,EAAQgF,EAAG,CAAA,CACxB,CACF,CACA,CACE,IAAMD,EAAWF,EAAQ,EACzB,QAAWtB,KAAQwB,EAAU,CAC3B,IAAMC,EAAK,KAAK,SAAS,iBAAiBzB,CAAI,EAC1CvD,EAAO,EACX,QAAW/C,KAAK+H,EACdhF,GAAQ,GAAK/C,EAEf6H,EAAW9E,CAAA,EAAQgF,EAAG,CAAA,CACxB,CACF,CACA,CACE,IAAMD,EAAWF,EAAQ,EACzB,QAAWtB,KAAQwB,EAAU,CAC3B,IAAMC,EAAK,KAAK,SAAS,iBAAiBzB,CAAI,EACxCvD,EAAQ,GAAKgF,EAAG,CAAA,EAAO,GAAK,KAAK,cACvCF,EAAW9E,CAAA,EAAQgF,EAAG,CAAA,CACxB,CACF,CACA,QAAS/H,EAAI,EAAGA,EAAImG,EAAU,OAAQnG,IAAK,CACzC,GAAImG,EAAUnG,CAAA,EAAG,SAAW,EAC1B,MAAM,IAAI,MAAM,4BAA4BmG,EAAUnG,CAAA,GAAI,EAE5D,IAAMgI,EAAK7B,EAAUnG,CAAA,EAAG,CAAA,EAClBiI,EAAK9B,EAAUnG,CAAA,EAAG,CAAA,EACpBkI,EAAKpB,EAAgBkB,CAAA,EACnBG,EAAKrB,EAAgBmB,CAAA,EACrBlF,EAAQ,GAAKiF,EAAO,GAAKC,EAC3BJ,EAAW9E,CAAA,IAAUiF,EACvBE,EAAKA,EAAKP,EAAMQ,EAEhBD,EAAKC,EAAKR,EAAMO,EAElB/B,EAAUnG,CAAA,EAAK,CAACmG,EAAUnG,CAAA,EAAG,CAAA,EAAIkI,CAAE,CACrC,CAEA,QAASlI,EAAI,EAAGA,EAAIkG,EAAY,OAAQlG,IAAK,CAC3C,IAAI+C,EAAO,EACX,GAAImD,EAAYlG,CAAA,EAAG,OAAS,EAC1B,MAAM,IAAI,MAAM,4BAA4B,EAE9C,QAASwG,EAAI,EAAGA,EAAIN,EAAYlG,CAAA,EAAG,OAAQwG,IACzCzD,GAAQ,GAAK8D,EAAgBX,EAAYlG,CAAA,EAAGwG,CAAA,EAAG,CAAA,CAAA,EAEjD,IAAMS,EAAKY,EAAW9E,CAAA,EAClBqF,EAAK,GACT,QAAS5B,EAAI,EAAGA,EAAIN,EAAYlG,CAAA,EAAG,OAAQwG,IACrCS,IAAOJ,EAAgBX,EAAYlG,CAAA,EAAGwG,CAAA,EAAG,CAAA,CAAA,IAC3C4B,EAAK5B,GAGT,GAAI4B,EAAK,EACP,MAAM,IAAI,MACR,6DACF,EAEF,IAAI9E,EAAI,GACR,QAASkD,EAAI,EAAGA,EAAIN,EAAYlG,CAAA,EAAG,OAAQwG,IAAK,CAC1CA,IAAM,EACRlD,EAAI4C,EAAYlG,CAAA,EAAGoI,CAAA,EAAI,CAAA,EAEvB9E,EAAIA,EAAIqE,EAAMzB,EAAYlG,CAAA,EAAGoI,CAAA,EAAI,CAAA,EAEnC,QAASC,EAAI,EAAGA,EAAInC,EAAYlG,CAAA,EAAG,OAAQqI,IACzC,GAAInC,EAAYlG,CAAA,EAAGoI,CAAA,EAAI,CAAA,IAAOlC,EAAYlG,CAAA,EAAGqI,CAAA,EAAG,CAAA,EAAI,CAClDD,EAAKC,EACL,KACF,CAEJ,CACAnC,EAAYlG,CAAA,EAAK,CAACkG,EAAYlG,CAAA,EAAG,CAAA,EAAIsD,CAAC,CACxC,CACA,KAAK,WAAauE,EACd,KAAK,QAAQ,UAAY,IAC3B,QAAQ,IAAI,iBAAiBxE,EAAU,IAAKwB,GAAMA,EAAE,CAAA,CAAE,EAAE,KAAK,GAAG,GAAG,EAEnE,QAAQ,IAAI,iBAAiBsB,EAAU,IAAKtB,GAAMA,EAAE,CAAA,CAAE,EAAE,KAAK,GAAG,GAAG,EAEnE,QAAQ,IAAI,mBAAmBqB,EAAY,IAAKrB,GAAMA,EAAE,CAAA,CAAE,EAAE,KAAK,GAAG,GAAG,GAEzE,IAAMyD,EAAuC,CAAC,EAC9C,QAAWjB,KAAapB,EACtBqC,EAAW,KAAK,CAACjB,EAAU,CAAA,EAAG,WAAW,EAAGA,EAAU,CAAA,EAAI,GAAG,CAAC,EAEhE,QAAWkB,KAAYpC,EACrBmC,EAAW,KAAK,CAACC,EAAS,CAAA,EAAG,WAAW,EAAGA,EAAS,CAAA,EAAI,GAAG,CAAC,EAE9D,QAAWC,KAActC,EACvBoC,EAAW,KAAK,CAACE,EAAW,CAAA,EAAG,WAAW,EAAGA,EAAW,CAAA,EAAI,GAAG,CAAC,EAElE,KAAK,UAAYnF,EACjB,KAAK,WAAa4C,EAClB,KAAK,UAAYE,EACjB,KAAK,YAAcD,EACnB,KAAK,WAAaoC,EAClB,IAAMG,EAAiBH,EAAW,IAAKzD,GAAMA,EAAE,CAAA,CAAE,EACjD,KAAK,SAAS,aAAa4D,CAAc,EACrC,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IACN,qBAAqB,UAAU,KAAK,uBAClC,KAAK,gBAET,EAGF,QAASC,EAAI,EAAGA,EAAIlD,EAAU,OAAQkD,IACpC,QAAWC,KAAY,KAAK,UAAW,CACrC,IAAM5I,EAAIyF,EAAUkD,CAAA,EAAG,YAAYC,CAAQ,EACvCC,EAAU,GACd,QAAWC,KAAa,KAAK,WAC3B,GAAI9I,EAAE,UAAU8I,CAAS,EAAG,CAC1BD,EAAU,GACV,KACF,CAEGA,IACH,KAAK,WAAW,KAAK7I,CAAC,EAClB0F,EAAWiD,CAAA,GACb,KAAK,YAAY,KAAK3I,CAAC,EAG7B,CAEF,IAAI+I,EAAK,IAAIvI,GAASgF,CAAS,EACzBwD,EAAM,KAAK,YAAY,MAAM,EAM/BC,GAAO,GACX,QAAShJ,EAAI,EAAGA,EAAI+I,EAAI,OAAQ/I,IAAK,CACnC,IAAMwG,EAAIxG,EAAI,KAAK,OAAO+I,EAAI,OAAS/I,IAAMgJ,GAAO,MAAQ,EAC5DF,EAAKA,EAAG,MAAMC,EAAIvC,CAAA,CAAE,EACpBuC,EAAIvC,CAAA,EAAKuC,EAAI/I,CAAA,EACbgJ,IAAQA,GAAO,KAAO,KAAO,KAC/B,CACA,IAAMhI,EAAQ8H,EAAG,QAAQ,CAAC,EAAG,EAAI,EACjC,KAAK,MAAQ9H,EACT,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,kBAAkBA,EAAM,QAAQ,EAE9C,KAAK,gBAAkBA,EAAM,OAK7B,IAAMiI,GAAoB,CAAC,EACrBC,EAAKC,GAAe5D,CAAS,EACnC,QAAWoD,KAAY,KAAK,UAAW,CACrC,IAAMS,EAAIT,EAAS,WAAWpD,CAAS,EACnC2D,EAAG,KAAKC,GAAeC,CAAC,CAAC,EAAIjI,GAC/B8H,GAAU,KAAKN,CAAQ,CAE3B,CACA,IAAMU,EAAW,IAAI,MAAerI,EAAM,MAAM,EAC1CsI,EAAmC,CAAC,EAC1C,QAAStJ,EAAI,EAAGA,EAAIgB,EAAM,OAAQhB,IAAK,CACrC,IAAMuJ,EAAMvI,EAAMhB,CAAA,EAAG,WAAW,EAChCsJ,EAAO,KAAK,CAACJ,EAAG,KAAKK,CAAG,EAAGA,EAAKvJ,CAAC,CAAC,CACpC,CACAsJ,EAAO,KAAK,CAAChJ,EAAGkJ,IAAMlJ,EAAE,CAAA,EAAKkJ,EAAE,CAAA,CAAE,EACjC,QAAStC,EAAK,EAAGA,EAAKlG,EAAM,OAAQkG,IAAM,CACxC,IAAMlH,EAAIsJ,EAAOpC,CAAA,EAAI,CAAA,EACrB,GAAI,CAACmC,EAASrJ,CAAA,EAAI,CAChBqJ,EAASrJ,CAAA,EAAK,GACd,QAAWkB,KAAO+H,GAAW,CAC3B,IAAMhB,EAAKjH,EAAMhB,CAAA,EAAG,OAAOkB,CAAG,EACxBgI,EAAKjB,EAAG,WAAW,EACzB,QAASwB,EAAKvC,EAAK,EAAGuC,EAAKzI,EAAM,QAC3B,EAAAsI,EAAOG,CAAA,EAAI,CAAA,EAAKH,EAAOpC,CAAA,EAAI,CAAA,EAAK/F,GADGsI,IAAM,CAI7C,IAAMpB,EAAIiB,EAAOG,CAAA,EAAI,CAAA,EACrB,GAAI,CAACJ,EAAShB,CAAA,GAAMa,EAAG,KAAKI,EAAOG,CAAA,EAAI,CAAA,CAAE,EAAItI,EAAK,CAChDkI,EAAShB,CAAA,EAAK,GACdrH,EAAMqH,CAAA,EAAKJ,EACX,KACF,CACF,CACF,CACF,CACF,CAGA,KAAK,UAAY,KACjB,QAAWzH,KAAQQ,EACjB,QAASwF,EAAI,EAAGA,EAAIhG,EAAK,OAAQgG,IAAK,CACpC,IAAM6B,GAAK7B,EAAI,GAAKhG,EAAK,OACnBG,EAAIH,EAAK,IAAIgG,CAAC,EAAE,KAAKhG,EAAK,IAAI6H,CAAC,CAAC,EAClC1H,EAAI,KAAK,YACX,KAAK,UAAYA,EAErB,CAEE,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,mBAAmB,KAAK,WAAW,EAG7CyB,IAAU,KAAOsD,GAAW,CAACC,GAAW,CAACC,IAG3C,KAAK,kBAAoB,kBAEzB,KAAK,aAAe,IAElBxD,IAAU,KAAOwD,GAAa,CAACF,GAAW,CAACC,IAC7C,KAAK,kBAAoB,eAEvBvD,IAAU,MAAQwD,GAAaF,IAAY,CAACC,IAC9C,KAAK,kBAAoB,6BAEvBvD,IAAU,KAAOsD,IACnB,KAAK,eAAiB,IAAIgE,GACxB,KAAK,SACL,IAAIhC,GAAiB,CAAC,IAAK,IAAK,IAAK,KAAM,IAAK,IAAK,KAAM,GAAG,CAAC,CACjE,EACM/B,GAAWC,IACf,KAAK,kBAAoB,cAGzBxD,IAAU,KAAOsD,IACnB,KAAK,kBAAoB,iBACzB,KAAK,eAAiB,IAAIgE,GACxB,KAAK,SACL,IAAIhC,GAAiB,CACnB,IACA,IACA,IACA,KACA,KACA,IACA,KACA,KACA,KACA,IACA,KACA,GACF,CAAC,CACH,EAEJ,CAEQ,QAAQlH,EAAoB,CAClC,OAAO,KAAK,SAASA,EAAK,WAAW,CAAC,CACxC,CAEQ,SAAS0I,EAAkB,CAEjC,IAAI/G,EAAI,GACFwH,EAAO,OAAO,aACpB,QAAWC,KAAgB,KAAK,cAC9B,GAAIA,EAAa,OAAS,EAAG,CAC3B,IAAMC,EAAKX,EAAG,IAAIU,EAAa,CAAA,CAAE,EAC7BjJ,EAAI,EACJ6I,EAAI,EACR,KAAOA,EAAI,GAAKI,EAAa,QAC3BJ,GAAK,EAEP,KAAOA,EAAI,EAAGA,IAAM,EACd7I,EAAI6I,GAAKI,EAAa,QAAUC,EAAKD,EAAajJ,EAAI6I,EAAI,CAAA,EAAG,IAC/D7I,GAAK6I,GAGT,GAAI7I,EAAI,GACNwB,EAAIA,EAAIwH,EAAK,GAAKhJ,CAAC,UACVA,EAAI,GAAK,GAAK,GACvBwB,EAAIA,EAAIwH,EAAK,GAAK,GAAK,KAAK,MAAMhJ,EAAI,EAAE,EAAI,CAAC,EAAIgJ,EAAK,GAAMhJ,EAAI,EAAG,UAC1DA,EAAI,GAAK,GAAK,GAAK,GAAK,GAAK,GACtCwB,EACEA,EACAwH,EAAK,GAAK,GAAK,KAAK,OAAOhJ,EAAI,KAAO,GAAK,IAAM,CAAC,CAAC,EACnDgJ,EAAK,GAAK,GAAM,KAAK,OAAOhJ,EAAI,IAAM,EAAE,EAAI,EAAG,EAC/CgJ,EAAK,GAAMhJ,EAAI,EAAG,MAEpB,OAAM,MAAM,oCAAoC,CAEpD,CAEF,OAAOwB,CACT,CAIQ,SAAS3B,EAAsB,CACrC,IAAM0I,EAAK1I,EAAK,WAAW,EAErB8C,EAAI,CAAC,EACX,QAAWsG,KAAgB,KAAK,cAC9B,GAAIA,EAAa,OAAS,EAAG,CAC3B,IAAMC,EAAKX,EAAG,IAAIU,EAAa,CAAA,CAAE,EAC7BjJ,EAAI,EACJ6I,EAAI,EACR,KAAOA,EAAI,GAAKI,EAAa,QAC3BJ,GAAK,EAEP,KAAOA,EAAI,EAAGA,IAAM,EACd7I,EAAI6I,GAAKI,EAAa,QAAUC,EAAKD,EAAajJ,EAAI6I,EAAI,CAAA,EAAG,IAC/D7I,GAAK6I,GAGTlG,EAAE,KAAK3C,CAAC,CACV,CAEF,OAAO2C,CACT,CAEQ,SAAS4F,EAAkB,CACjC,IAAMY,EAAM,KAAK,SAASZ,CAAE,EACtBtI,EAAM,KAAK,aAAa,IAAIkJ,CAAG,EACrC,GAAIlJ,EAAI,SAAW,EACjB,OAAOA,EAAI,CAAA,EAEb,QAAS,EAAI,EAAG,EAAI,EAAIA,EAAI,OAAQ,IAAK,CACvC,IAAMmJ,EAAQ,KAAK,aAAa,IAAID,CAAG,EAAG,CAAA,EAC1C,GAAI,KAAK,IAAIZ,EAAG,KAAK,KAAK,eAAea,CAAA,CAAM,CAAC,EAAI5I,EAClD,OAAO4I,CAEX,CACA,OAAOnJ,EAAIA,EAAI,OAAS,CAAA,CAC1B,CAEQ,UACNoJ,EACAC,EACAC,EACoB,CAKpB,IAAM1J,EAAO,KAAK,UAAUwJ,CAAA,EAAO,CAAA,EAC7BG,GAAUF,EAAQ,GAAKzJ,EAAK,OAC5B4J,EAAQ,KAAK,WAAWJ,CAAA,EAC1BK,EAAK7J,EAAK2J,CAAA,EAAQ,IAAI3J,EAAKyJ,CAAA,CAAM,EAC/BK,EAAOD,EAAG,IAAI,EACpBA,EAAKA,EAAG,UAAU,EAClB,IAAME,EAAKF,EAAG,MAAMD,CAAK,EAAE,UAAU,EACjCI,EAAQN,EAAQ,CAAA,EAAG,IAAIA,EAAQ,CAAA,CAAE,EAC/BO,EAAMD,EAAM,IAAI,EAAIF,EAC1BE,EAAQA,EAAM,UAAU,EACxB,IAAME,EAAOF,EAAM,EACbG,EAAOH,EAAM,EACbI,EAAKP,EAAG,KAAKK,CAAI,EAAE,IAAIH,EAAG,KAAKI,CAAI,CAAC,EAAE,KAAKF,CAAG,EAC9CI,EAAKN,EAAG,KAAKG,CAAI,EAAE,IAAIL,EAAG,KAAKM,CAAI,CAAC,EAAE,KAAKF,CAAG,EAC9CxK,EAAM,IAAIC,EACd,EACAgK,EAAQ,CAAA,EAAG,EAAIU,EAAG,IAAIpK,EAAKyJ,CAAA,CAAM,EACjCC,EAAQ,CAAA,EAAG,EAAIW,EAAG,IAAIrK,EAAKyJ,CAAA,CAAM,EACjC,CACF,EACA,MAAO,CAACW,EAAIC,EAAI5K,CAAG,CACrB,CAEO,aAAoB,CACzB,IAAMgE,EAAY,cAKlB,KAAK,MAAQnD,GAAY,KAAK,aAAc,KAAK,KAAK,EAClD,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,2BAA2B,KAAK,MAAM,QAAQ,EAE5D,KAAK,eAAiB,IAAI,MAAM,KAAK,MAAM,MAAM,EACjD,QAASd,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IACrC,KAAK,eAAeA,CAAA,EAAK,KAAK,MAAMA,CAAA,EAAG,WAAW,EAGpD,IAAM8K,EAA0B,CAAC,EAC3BC,EAA2B,CAAC,EAElC,QAAWhL,KAAK,KAAK,WAAY,CAC/B,IAAMiL,EAAUjL,EAAE,WAAW,EACzB6I,EAAU,GACd,QAAWqC,KAAmBF,EACxBC,EAAQ,UAAUC,EAAgB,WAAW,CAAC,IAChDrC,EAAU,IAGTA,IACHmC,EAAiB,KAAKC,CAAO,EAC7BF,EAAc,KAAK,CAAC,CAAC,EAEzB,CACA,QAAW/K,KAAK,KAAK,YAAa,CAChC,IAAMiL,EAAUjL,EAAE,WAAW,EAC7B,QAAS,EAAI,EAAG,EAAIgL,EAAiB,OAAQ,IAC3C,GAAIC,EAAQ,UAAUD,EAAiB,CAAA,CAAE,EAAG,CAC1CD,EAAc,CAAA,EAAG,KAAK/K,CAAC,EACvB,KACF,CAEJ,CAEA,QAASC,EAAI,EAAGA,EAAI8K,EAAc,OAAQ9K,IAAK,CAC7C,IAAMD,EAAY+K,EAAc9K,CAAA,EAAG,IAAK6E,GAAMA,EAAE,eAAe,CAAC,EAC1DqG,EAAaH,EAAiB/K,CAAA,EACpC,QAASwG,EAAI,EAAGA,EAAIzG,EAAE,OAAQyG,IACxBzG,EAAEyG,CAAA,EAAG,WAAW,EAAE,KAAK0E,CAAU,EAAI/J,IACvCpB,EAAEyG,CAAA,EAAKzG,EAAEyG,CAAA,EAAG,KAAK,EAAE,GAGvBzG,EAAE,KAAK,CAACO,EAAGkJ,IAAMlJ,EAAE,EAAIkJ,EAAE,CAAC,EAC1BsB,EAAc9K,CAAA,EAAKD,CACrB,CACA,KAAK,cAAgB+K,EACrB,KAAK,iBAAmBC,EACxB,IAAMI,EAAQL,EAAc,IAAKjG,GAAMA,EAAE,MAAM,EAC3C,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,sBAAsBsG,GAAO,EAG3C,IAAMC,EAA0B,CAAC,EACjC,QAASpL,EAAI,EAAGA,EAAI8K,EAAc,OAAQ9K,IACxCoL,EAAc,KAAK,CAAC,CAAC,EAEvB,QAAWrL,KAAK,KAAK,UAAW,CAC9B,GAAI,KAAK,IAAI,KAAK,IAAIA,EAAE,CAAC,EAAI,CAAC,EAAIoB,EAChC,SAEF,IAAM6J,EAAUjL,EAAE,WAAW,EAC7B,QAAS,EAAI,EAAG,EAAI+K,EAAc,OAAQ,IACxC,GAAIE,EAAQ,UAAUD,EAAiB,CAAA,CAAE,EAAG,CAC1CK,EAAc,CAAA,EAAG,KAAKrL,CAAC,EACvB,KACF,CAEJ,CACA,KAAK,cAAgBqL,EAIrB,QAASpL,EAAI,EAAGA,EAAIoL,EAAc,OAAQpL,IAAK,CAC7C,IAAMsD,EAAI8H,EAAcpL,CAAA,EAClBkL,EAAa5H,EAAE,CAAA,EAAG,WAAW,EACnC,QAASkD,EAAI,EAAGA,EAAIlD,EAAE,OAAQkD,IACxB0E,EAAW,KAAK5H,EAAEkD,CAAA,EAAG,WAAW,CAAC,EAAIrF,IACvCmC,EAAEkD,CAAA,EAAKlD,EAAEkD,CAAA,EAAG,KAAK,EAAE,GAGvBlD,EAAE,KAAK,CAAChD,EAAGkJ,IAAMlJ,EAAE,MAAM,EAAIkJ,EAAE,MAAM,CAAC,EAClC4B,EAAcpL,CAAA,EAAG,CAAA,EAAG,IAAI+K,EAAiB/K,CAAA,CAAE,EAAI,GACjDsD,EAAE,QAAQ,CAEd,CACA,IAAM+H,EAASD,EAAc,IAAKvG,GAAM,EAAIA,EAAE,MAAM,EACpD,KAAK,cAAgBwG,EACrB,IAAMC,EAA0D,CAAC,EAC7DC,EAAQ,IACZ,QAASvL,EAAI,EAAGA,EAAI8K,EAAc,OAAQ9K,IAAK,CAC7C,IAAMwL,EAAKT,EAAiB/K,CAAA,EACxByL,EAAM,KACNC,EAAM,KACV,QAAWC,KAAa,KAAK,WAAY,CACvC,IAAMC,EAAIJ,EAAG,IAAIG,EAAU,CAAA,CAAE,EACzB,KAAK,IAAIC,EAAI,CAAC,EAAIzK,GACpBuK,EAAM,CAACC,EAAU,CAAA,EAAIA,EAAU,CAAA,CAAE,EACjCJ,EAAQI,EAAU,CAAA,GACT,KAAK,IAAIC,EAAI,CAAC,EAAIzK,IAC3BsK,EAAM,CAACE,EAAU,CAAA,EAAIA,EAAU,CAAA,CAAE,EACjCJ,EAAQI,EAAU,CAAA,EAEtB,CACA,GAAID,IAAQ,MAAQD,IAAQ,KAC1B,MAAM,IAAI,MAAM,wCAAwC,EAE1DH,EAAY,KAAK,CACfI,EAAI,CAAA,EACJA,EAAI,CAAA,EACJD,EAAI,CAAA,EACJA,EAAI,CAAA,EACJ,EAAIX,EAAc9K,CAAA,EAAG,MACvB,CAAC,EACG,KAAK,oBAAsB,mBAAqBuL,IAAU,MAC5D,KAAK,eAAiB,IAAIM,GAAgB,EAAIf,EAAc9K,CAAA,EAAG,MAAM,EACrE,KAAK,kBAAoB,IAGzB,KAAK,oBAAsB,eAC3B8K,EAAc,CAAA,EAAG,SAAW,IAE5B,KAAK,eAAiB,IAAIgB,GAAoB,KAAK,QAAQ,EAC3D,KAAK,kBAAoB,IAEvB,KAAK,oBAAsB,8BAE3BhB,EAAc,CAAA,EAAG,SAAW,GAC5BA,EAAc,CAAA,EAAG,CAAA,EAAG,IAAM,kBAC1BA,EAAc,CAAA,EAAG,CAAA,EAAG,IAAM,kBAE1B,KAAK,eAAiB,IAAIiB,GAAuB,KAAK,QAAQ,EAC9D,KAAK,kBAAoB,KAEzB,KAAK,eAAiB,IAAIC,GAAwB,KAAK,QAAQ,EAC/D,KAAK,kBAAoB,KAGzB,KAAK,oBAAsB,kBAAoBT,IAAU,MACvD,EAAIT,EAAc9K,CAAA,EAAG,SAAW,IAClC,KAAK,eAAiB,IAAIiM,GACxB,KAAK,cACP,GAEF,KAAK,kBAAoB,IAEvB,KAAK,oBAAsB,aAAeV,IAAU,MAClD,EAAIT,EAAc9K,CAAA,EAAG,SAAW,IAClC,KAAK,eAAiB,IAAIkM,GACxB,KAAK,eACL,KAAK,QACP,GAEF,KAAK,kBAAoB,GAE7B,CACA,KAAK,YAAcZ,EAQnB,IAAMa,EAAe,IAAI,IACnBnL,EAAQ,KAAK,MACnB,QAAShB,EAAI,EAAGA,EAAIgB,EAAM,OAAQhB,IAAK,CACrC,IAAMQ,EAAOQ,EAAMhB,CAAA,EACbmC,EAAI,KAAK,QAAQ3B,CAAI,EAC3B,GAAI,CAAC2L,EAAa,IAAIhK,CAAC,EACrBgK,EAAa,IAAIhK,EAAG,CAACnC,CAAC,CAAC,MAClB,CACL,IAAMY,EAAMuL,EAAa,IAAIhK,CAAC,EAK9B,GAJAvB,EAAI,KAAKZ,CAAC,EAINY,EAAI,SAAW,KAAK,cAAe,CACjC,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,mBAAmB,EAEjC,QAASwL,EAAO,EAAGA,EAAOxL,EAAI,OAAQwL,IAAQ,CAC5C,IAAMC,EAAK,GAAGlK,KAAKiK,IACnBD,EAAa,IAAIE,EAAI,CAACzL,EAAIwL,CAAA,CAAK,CAAC,CAClC,CACF,CACF,CACF,CACA,KAAK,aAAeD,EAChB,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,aAAaA,EAAa,MAAM,EAE9C,IAAMG,EAAqB,CAAC,EACtBC,EAAc,CAAC,EACfC,EAAY,CAAC,EACnB,QAAW5F,KAAYuF,EAAa,OAAO,EACzC,GAAIvF,EAAS,SAAW,KAAK,cAQ7B,IAAIA,EAAS,OAAS,EAAG,CACvB,IAAMsC,EAAKtC,EAAS,IAAK/B,GAAc7D,EAAM6D,CAAA,EAAG,WAAW,CAAC,EACtD4H,EAAQtD,GAAeD,CAAE,EAC/B,QAASwD,EAAY,EAAG9F,EAAS,OAAS,EAAG8F,IAAa,CACxD,IAAIC,EAAU,GACd,QAAS3M,EAAI,EAAGA,EAAI4G,EAAS,OAAQ5G,IAAK,CACxC,IAAMwG,GAAKxG,EAAI,GAAK4G,EAAS,OAE7B,GAAI6F,EAAM,IAAIvD,EAAGlJ,CAAA,EAAG,MAAMkJ,EAAG1C,CAAA,CAAE,CAAC,EAAI,EAAG,CACrC,IAAMoG,EAAI1D,EAAGlJ,CAAA,EACbkJ,EAAGlJ,CAAA,EAAKkJ,EAAG1C,CAAA,EACX0C,EAAG1C,CAAA,EAAKoG,EACR,IAAMC,EAAIjG,EAAS5G,CAAA,EACnB4G,EAAS5G,CAAA,EAAK4G,EAASJ,CAAA,EACvBI,EAASJ,CAAA,EAAKqG,EACdF,EAAU,EACZ,CACF,CACA,GAAI,CAACA,EACH,MAEF,GAAID,EAAY,IACd,MAAM,IAAI,MAAM,uCAAuC,CAE3D,CAEA,IAAI3J,EAAO,EACX,QAAWqG,KAAKxC,EACd7D,GAAQ,GAAK,KAAK,MAAMqG,EAAI,KAAK,eAAe,EAElD,IAAMvB,EAAa,KAAK,WAAW9E,CAAA,EAC/B+J,EAAO,GACX,QAAS9M,EAAI,EAAGA,EAAI4G,EAAS,OAAQ5G,IAC/B,KAAK,MAAM4G,EAAS5G,CAAA,EAAK,KAAK,eAAe,IAAM6H,IACrDiF,EAAO9M,GAGX,GAAI8M,EAAO,EACT,MAAM,IAAI,MAAM,oCAAoC,EAEtD,GAAIA,IAAS,EAAG,CACd,IAAMC,EAAYnG,EAAS,MAAM,EACjC,QAAS5G,EAAI,EAAGA,EAAI4G,EAAS,OAAQ5G,IACnC4G,EAAS5G,CAAA,EAAK+M,GAAWD,EAAO9M,GAAK4G,EAAS,MAAA,CAElD,CACF,CACA,QAASJ,EAAI,EAAGA,EAAII,EAAS,OAAQJ,IAAK,CACxC,IAAM6B,EAAIzB,EAASJ,CAAA,EACnB+F,EAAYlE,CAAA,EAAKiE,EAAO,OACxBE,EAAUnE,CAAA,EAAK7B,CACjB,CACA8F,EAAO,KAAK1F,CAAQ,EAEtB,KAAK,OAAS0F,EACd,KAAK,YAAcC,EACnB,KAAK,UAAYC,EAGjB,IAAMQ,EAAY,CAAC,IAAK,UAAW,QAAS,UAAW,SAAU,QAAQ,EACnEC,EAAgB,CAAC,EACjBC,EAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACnCC,EAAY,CAAC,EACbC,EAAO,CAAC,EACVC,EAAc,EACZC,EAAe,CAAC,EAChBC,EAAe,CAAC,EAChBC,EAAY,CAAC,EACbC,EAAgB,CAAC,EAGjBC,EAAeC,GACZrB,EAAOqB,CAAA,EAAU,IAAK9I,GAAM,KAAK,aAAaA,CAAC,CAAC,EAAE,KAAK,GAAG,EAE7D+I,EAAsB,CAAC,EAC7B,QAAS5N,EAAI,EAAGA,EAAIsM,EAAO,OAAQtM,IAAK,CACtC,IAAM6N,EAAQvB,EAAOtM,CAAA,EAIrB,GAHI6N,EAAM,SAAW,GAGjBT,EAAKpN,CAAA,EACP,SAEF,IAAM8N,EAAmB,CAAC,EACtBC,EAAe,EACnBP,EAAU,KAAK,CAAC,EAChBI,EAAe,KAAK,CAAC,CAAC,EACtB,IAAMI,EAAUH,EAAM,OAChBI,EAAUf,EAAgBc,CAAA,IAC5BE,EAAWlB,EAAUgB,CAAA,GACrBE,IAAa,QAAaF,IAAY,KAAK,iBAC7CE,EAAW,QAEbA,EAAWA,GAAYD,IAAY,EAAI,GAAKA,EAAU,GACtDhB,EAAcI,CAAA,EAAea,EAC7Bf,EAAUE,CAAA,EAAeW,EACzB,IAAMG,EAAQ,CAACnO,CAAC,EACZoO,EAAK,EAET,IADAhB,EAAKpN,CAAA,EAAK,GACHoO,EAAKD,EAAM,QAAQ,CACxB,IAAME,EAAOF,EAAMC,GAAA,EACbE,EAAgBZ,EAAYW,CAAI,EAQtC,IAPIR,EAAM,OAAS,GAAKC,EAAYQ,CAAA,IAAmB,UACrDR,EAAYQ,CAAA,EAAiBP,KAE/BN,EAAcY,CAAA,EAAQP,EAAYQ,CAAA,EAClChB,EAAae,CAAA,EAAQhB,EACrBO,EAAeP,CAAA,EAAa,KAAKgB,CAAI,EACrCd,EAAac,CAAA,EAAQb,EAAUH,CAAA,IAC3Bc,EAAM,OAAS,KAAK,UAAU,OAAQ,CACxC,IAAMjF,EAAK,KAAK,eAAeoD,EAAO+B,CAAA,EAAM,CAAA,CAAA,EAC5C,QAAWE,MAAgBnD,EAAe,CACxC,IAAMoD,EACJ,KAAK,YAAY,KAAK,SAAStF,EAAG,YAAYqF,GAAa,CAAA,CAAE,CAAC,CAAA,EAC3DnB,EAAKoB,CAAA,IACRL,EAAM,KAAKK,CAAE,EACbpB,EAAKoB,CAAA,EAAM,GAEf,CACF,CACF,CACAnB,GACF,CACA,GACE,KAAK,cACL,GAAK,KAAK,iBACV,KAAK,iBAAmB,EACxB,CACA,IAAMoB,EAAY,CAChB,CACE,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACF,EACA,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAK,EACvD,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,CAC/B,EACMC,EAAqC,CAAC,EAC5C,QAAWb,KAASY,EAClB,QAASjI,EAAI,EAAGA,EAAIqH,EAAM,OAAQrH,IAAK,CACrC,IAAImI,EAAO,EACX,QAAStG,EAAI,EAAGA,EAAIwF,EAAMrH,CAAA,EAAG,OAAQ6B,IACnCsG,GAAQ,GAAMd,EAAMrH,CAAA,EAAG,WAAW6B,CAAC,EAAI,GAEzCqG,EAAQC,CAAA,EAAQnI,CAClB,CAEF,QAAWoI,KAAYhB,EACrB,QAAWD,KAAYiB,EAAU,CAC/B,IAAID,EAAO,EACX,QAAWd,KAASvB,EAAOqB,CAAA,EACzBgB,GACE,GACC,KAAK,UAAU,KAAK,aAAad,CAAK,CAAA,EAAG,CAAA,EAAG,WAAW,CAAC,EAAI,GAEjEN,EAAaI,CAAA,EAAYe,EAAQC,CAAA,CACnC,CAEJ,CASA,GARA,KAAK,aAAerB,EACpB,KAAK,aAAeC,EACpB,KAAK,cAAgBN,EACrB,KAAK,UAAYO,EACjB,KAAK,UAAYL,EACjB,KAAK,cAAgBM,EACrB,KAAK,eAAiBG,EAElB,KAAK,QAAQ,iBAAmB,KAAM,CACxC,QAAS5N,EAAI,EAAGA,EAAIsM,EAAO,OAAQtM,IACjC,GACG,KAAK,QAAQ,iBAAmB,KAAOsM,EAAOtM,CAAA,EAAG,OAAS,GAC1D,KAAK,QAAQ,iBAAmB,KAAOsM,EAAOtM,CAAA,EAAG,SAAW,GAC5D,KAAK,QAAQ,iBAAmB,KAAOsM,EAAOtM,CAAA,EAAG,SAAW,EAC7D,CACA,KAAK,WAAaA,EAClB,KACF,CAEF,GAAI,KAAK,WAAa,EACpB,MAAM,IAAI,MACR,kCAAkC,KAAK,QAAQ,wBACjD,CAEJ,CAEI,KAAK,QAAQ,UAAY,GAC3B,QAAQ,IAAI,uBAAuBwN,GAAW,CAGlD,CAEO,UAAUqB,EAAuB,CACtC,IAAMC,EAAQ,KAAK,eAAe,mBAAmBD,CAAE,EACvD,OAAIC,IAAU,KACL,KAEFA,EAAM,SAAS,CAAE,OAAQ,KAAK,SAAS,UAAUA,EAAM,MAAM,CAAE,CAAC,CACzE,CAIQ,kBAAkBD,EAAkB,CAE1C,IAAME,EAAK,OAAO,6CAA6C,EACzDpN,EAAIkN,EAAG,MAAME,CAAE,EACrB,GAAIpN,IAAM,KACR,MAAM,IAAI,MAAM,mBAAmBkN,GAAI,EAEzC,IAAMG,EAAOrN,EAAE,CAAA,EACXsN,EACAC,EACJ,GAAIvN,EAAE,CAAA,IAAO,OAAW,CACtB,GAAIA,EAAE,CAAA,IAAO,OACX,MAAM,IAAI,MAAM,gCAAgC,EAElDsN,EAAU,SAAStN,EAAE,CAAA,EAAI,EAAE,CAC7B,CACIA,EAAE,CAAA,IAAO,SACXuN,EAAU,SAASvN,EAAE,CAAA,EAAI,EAAE,GAE7B,IAAIwN,EAAY,IACZC,EAAS,EACb,OAAIzN,EAAE,CAAA,IAAO,SACXwN,EAAYxN,EAAE,CAAA,EACVwN,EAAU,CAAA,IAAO,MACnBA,EAAY,IAAIA,EAAU,UAAU,CAAC,KAEvCC,EAAS,SAASD,EAAW,EAAE,GAE1B,IAAIE,EAAK,IAAIC,EAAYN,EAAME,EAASD,CAAO,EAAGG,CAAM,CACjE,CAEO,UACLG,EAC+D,CAC/D,IAAMC,EAAK,KAAK,eAAe,mBAAmBD,CAAI,EACtD,GAAIC,IAAO,KACT,MAAM,IAAI,MAAM,YAAYD,EAAK,QAAQ,EAE3CA,EAAOC,EACP,IAAIR,EAAOO,EAAK,OACZE,EAAe,GACnB,GAAIT,EAAK,SAAS,GAAG,GAAKA,EAAK,CAAA,GAAM,IAAK,CACxC,GAAIO,EAAK,aAAe,QAAaA,EAAK,aAAe,OACvD,MAAM,IAAI,MAAM,8CAA8C,EAEhEP,EAAOA,EAAK,MAAM,EAAG,EAAE,EACvBS,EAAe,EACjB,CACIT,EAAK,SAAS,GAAG,GAAKA,EAAK,CAAA,GAAM,MACnCA,EAAOA,EAAK,MAAM,EAAG,EAAE,EAAE,YAAY,GAEvC,IAAIlM,EACA4M,EAAM,GACJC,EAAU,KAAK,SAAS,UAAUX,CAAI,EACxCY,EAAY,GAChB,QAAS5P,EAAI,EAAGA,EAAI,KAAK,YAAY,OAAQA,IAAK,CAChD,IAAMmE,EAAI,KAAK,YAAYnE,CAAA,EACvB2P,IAAYxL,EAAE,CAAA,IAChByL,EAAY,GACZ9M,EAAMqB,EACNuL,EAAM1P,GAEJ2P,IAAYxL,EAAE,CAAA,IAChByL,EAAY,GACZ9M,EAAMqB,EACNuL,EAAM1P,EAEV,CACA,IAAIiP,EAAU,EACVC,EAAU,EAId,GAHIF,EAAK,YAAY,IAAMA,IACzBE,EAAU,GAERpM,IAAQ,OACV,MAAM,IAAI,MAAM,oBAAoByM,EAAK,QAAQ,EA4BnD,GA1BIA,EAAK,aAAe,SACtBN,EAAUM,EAAK,YAEbA,EAAK,aAAe,SAClBA,EAAK,aAAe,QACtBL,EAAUK,EAAK,WAIXP,GAAQ,IAEVC,EAAUC,EAGVD,EAAU,GAGZC,EAAUK,EAAK,YAGnBN,IACAC,IACIO,IACFR,EAAU,EACVC,EAAU,KAAK,cAAcQ,CAAA,EAAK,QAGlCT,EAAU,GACVA,EAAU,KAAK,cAAcS,CAAA,EAAK,QAClCR,EAAU,GACVA,EAAU,KAAK,cAAcQ,CAAA,EAAK,OAElC,MAAM,IAAI,MACR,kBAAkBT,KAAWC,QAAc,KAAK,cAAcQ,CAAA,EAAK,QACrE,EAEF,GACE,CAACrO,IACD4N,IAAY,GACZC,IAAY,KAAK,cAAcQ,CAAA,EAAK,QACpC,CAACD,EAED,MAAM,IAAI,MACR,0DACF,EAEF,MAAO,CAAC,OAAWC,EAAKT,EAASC,EAASU,EAAWL,EAAK,MAAM,CAClE,CAEQ,UACNV,EAC+D,CAC/D,IAAMvL,EAAI,KAAK,UAAU,KAAK,kBAAkBuL,CAAE,CAAC,EACnD,OAAAvL,EAAE,CAAA,EAAKuL,EACAvL,CACT,CAEO,UAAiB,CACtB,IAAMW,EAAY,WAElB,GAAI,KAAK,cAAc,OAAS,EAE9B,OAEF,IAAM4L,EAAgB,CAAC,EAOvB,GAAI,KAAK,QAAQ,eACf,QAASxH,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IACtC,GAAI,KAAK,OAAOA,CAAA,EAAG,SAAW,EAAG,CAC/B,IAAMoB,EAAK,KAAK,OAAOpB,CAAA,EAAG,CAAA,EACpBrI,EAAI,KAAK,aAAayJ,CAAE,EACxBqG,EAAS,KAAK,UAAU9P,CAAA,EAAG,WAAW,EAC5C,GAAI8P,EAAO,KAAK,KAAK,eAAerG,CAAA,CAAG,EAAItI,EAAK,CAC9C,IAAM4B,EAAQ,GAAK/C,EAAM,GAAK,KAAK,cAC7B+P,EAAU,KAAK,WAAWhN,CAAA,EAC1B+C,EAAS,KAAK,WAAWiK,CAAA,EAAS,WAAW,EAC/CC,EAAM,GACNC,EAAM,GACV,QAAS/I,EAAK,EAAGA,EAAK,KAAK,MAAMuC,CAAA,EAAI,OAAQvC,IAAM,CACjD,IAAMpD,EAAK,KAAK,MAAM2F,CAAA,EAAI,IAAIvC,CAAE,EAC1BvG,EAAImF,EAAO,IAAIhC,EAAG,IAAIgM,CAAM,CAAC,EAC/BnP,EAAIqP,IACNA,EAAMrP,EACNsP,EAAM/I,EAEV,CAEA,IAAMgJ,GAAQD,EAAM,GAAK,KAAK,MAAMxG,CAAA,EAAI,OAQxC,GANE,KAAK,IAAI3D,EAAO,IAAI,KAAK,MAAM2D,CAAA,EAAI,IAAIyG,CAAI,EAAE,IAAIJ,CAAM,CAAC,EAAIE,CAAG,EAC/D7O,IAEA8O,EAAMC,GAGJD,IAAQ,EAAG,CACb,IAAME,EAAK,CAAC,EACZ,QAASjJ,EAAK,EAAGA,EAAK,KAAK,MAAMuC,CAAA,EAAI,OAAQvC,IAC3CiJ,EAAG,KAAK,KAAK,MAAM1G,CAAA,EAAI,KAAKvC,EAAK+I,GAAO,KAAK,MAAMxG,CAAA,EAAI,MAAM,CAAC,EAEhE,KAAK,MAAMA,CAAA,EAAM,IAAI3J,GAAKqQ,CAAE,CAC9B,CACA,IAAMC,EAAI,KAAK,UAAUpQ,CAAA,EAAG,OAC5B,QAASqQ,EAAI,EAAGA,EAAID,EAAGC,IACrB,KAAK,OAAOhI,CAAA,EAAG,KAAK,KAAK,OAAOA,CAAA,EAAGgI,EAAI,CAAA,CAAE,EAE3C,KAAK,gBAAgB5G,CAAA,EAAM2G,EAC3B,KAAK,iBAAiB/H,CAAA,EAAK+H,EAC3B,KAAK,UAAU,KAAK,aAAa/H,CAAA,CAAA,EAAM+H,CACzC,CACF,EAGJ,QAAS/H,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAClD,IAAMuB,EAAe,KAAK,cAAcvB,CAAA,EAClCiI,EAAW,CAAC,EACZC,EAAY,CAAC3G,EAAa,OAAS,EAAG,CAAC,EACzC4G,EAAM,EACV,KAAOA,EAAM,GAAK5G,EAAa,QAC7B4G,GAAO,EAET,QAASxQ,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IAAK,CAC1C,IAAIW,EAAI,EACR,GAAIiJ,EAAa,OAAS,EAAG,CAC3B,IAAMC,EAAK,KAAK,eAAe7J,CAAA,EAAG,IAAI4J,EAAa,CAAA,CAAE,EACrD,QAAS,EAAI4G,EAAK,EAAI,EAAG,IAAM,EAE3B7P,EAAI,GAAKiJ,EAAa,QACtBC,EAAKD,EAAajJ,EAAI,EAAI,CAAA,EAAG,IAE7BA,GAAK,GAGTA,EAAIiJ,EAAa,OAASjJ,CAC5B,CAEA,IADA2P,EAAS,KAAK3P,CAAC,EACR4P,EAAU,QAAU5P,GACzB4P,EAAU,KAAK,CAAC,EAElBA,EAAU5P,CAAA,GACZ,CACA,IAAM8P,EAAa,IAAI,MAAMF,EAAU,MAAM,EAC7C,QAASG,EAAK,EAAGA,EAAKH,EAAU,OAAQG,IACtCD,EAAWC,CAAA,EAAM,CAAC,EAEpB,IAAMC,EAAY,CAAC,EACnB,QAAS3Q,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IAAK,CAC1C,GAAIsQ,EAAStQ,CAAA,EAAK,EAChB,SAEF,IAAMwJ,EAAI,CAAC,KAAK,YAAYxJ,CAAA,EAAI,KAAK,UAAUA,CAAA,CAAE,EAC7CkJ,EAAK,KAAK,eAAelJ,CAAA,EACvB4Q,EAAM1H,EACR2H,EAAM7Q,EACJ0Q,EAAKJ,EAASO,CAAA,EACpB,OAAS,CACPP,EAASO,CAAA,EAAO,GAChB,IAAMtH,EAAML,EAAG,YAAY,KAAK,cAAcb,CAAA,EAAG,CAAA,CAAE,EACnD,GAAIkB,EAAI,KAAKqH,CAAG,EAAIzP,EAClB,MAEF0P,EAAM,KAAK,SAAStH,CAAG,EACvBC,EAAE,KAAK,KAAK,YAAYqH,CAAA,EAAM,KAAK,UAAUA,CAAA,CAAI,EACjD3H,EAAKK,CACP,CAqBA,GACEC,EAAE,OAAS,GACX,KAAK,QAAQ,gBACZ,KAAK,OAAOA,EAAE,CAAA,CAAA,EAAI,SAAW,GAAK,KAAK,iBAAiBA,EAAE,CAAA,CAAA,EAAM,IAI/D,KAAK,eAAexJ,CAAA,EAAG,KACrB,KAAK,UAAU,KAAK,aAAaA,CAAC,CAAA,EAAG,WAAW,CAClD,EAAImB,EACJ,CAEA,IAAI2P,EAAQ,KAAK,MAAM,KAAK,OAAOtH,EAAE,CAAA,CAAA,EAAI,CAAA,CAAA,EACzC,QAAStC,EAAK,EAAGA,EAAKsC,EAAE,OAAQtC,GAAM,EAAG,CACvC,IAAM6J,EAAQ,KAAK,MAAM,KAAK,OAAOvH,EAAEtC,CAAA,CAAA,EAAK,CAAA,CAAA,EACxCkJ,EAAI,GACR,QAAS3J,EAAK,EAAGA,EAAKqK,EAAM,OAAQrK,IAClC,GAAIsK,EAAM,IAAItK,CAAE,EAAE,KAAKqK,EAAM,IAAI,CAAC,CAAC,EAAI3P,EAAK,CAC1CiP,EAAI3J,EACJ,KACF,CAEF,GAAI2J,EAAI,EACN,MAAM,IAAI,MACR,2DACF,EAEA5G,EAAEtC,EAAK,CAAA,EAAKkJ,EACZU,EAAQA,EAAM,OAAO,KAAK,cAAczI,CAAA,EAAG,CAAA,CAAE,CAEjD,CACF,CAKF,GAAImB,EAAE,SAAW,GAAK,KAAK,QAAQ,cACjC,QAAStC,EAAK,EAAGA,EAAK,KAAK,cAAcmB,CAAA,EAAInB,IACvCwJ,IAAO,EACTlH,EAAE,KAAKA,EAAE,CAAA,EAAItC,CAAE,EAEfsC,EAAE,KACAA,EAAE,CAAA,GACD,KAAK,cAAcnB,CAAA,EAAKnB,GAAM,KAAK,cAAcmB,CAAA,CACpD,EAIN,GAAImB,EAAE,OAAS,GAAK,CAACmH,EAAUnH,EAAE,CAAA,CAAA,EAAK,CACpC,GAAIA,EAAE,SAAW,EAAI,KAAK,cAAcnB,CAAA,EACtC,MAAM,IAAI,MAAM,wBAAwB,EAE1C,QAAWwE,KAAKrD,EACdiH,EAAWC,CAAA,EAAI,KAAK7D,CAAC,CAEzB,CACA,QAASrG,EAAI,EAAGA,EAAIgD,EAAE,OAAQhD,GAAK,EACjCmK,EAAUnH,EAAEhD,CAAA,CAAA,EAAM,EAEtB,CACA,QAASiD,EAAK,EAAGA,EAAKgH,EAAW,OAAQhH,IACvCgH,EAAWhH,CAAA,EAAMgH,EAAWhH,CAAA,EAAI,MAAM,EAExCoG,EAAc,KAAKY,CAAU,CAC/B,CAEA,GADA,KAAK,cAAgBZ,EACjB,KAAK,QAAQ,SAAU,CACzB,IAAMmB,EAOA,CAAC,EAEP,QAAWC,KAAc,KAAK,QAAQ,SACpCD,EAAe,KAAK,KAAK,UAAUC,CAAU,CAAC,EAEhD,KAAK,eAAiBD,CACxB,CACA,KAAK,aAAa,MAAM,EACxB,KAAK,eAAiB,CAAC,CAEzB,CAEQ,qBAA2B,CAEjC,MAAO,CACL,WAAY,KAAK,WACjB,UAAW,KAAK,UAChB,WAAY,KAAK,WACjB,YAAa,KAAK,YAClB,UAAW,KAAK,UAChB,WAAY,KAAK,UACnB,CACF,CAEQ,YAAY3I,EAAgB,CAKlC,IAAMrF,EAAS,KAAK,cAAcqF,CAAA,EAAG,OACjC/E,EAAW,CAAC,EAChB,GAAI,KAAK,iBAAmB,OAC1B,QAAW4N,KAAc,KAAK,eACxBA,EAAW,CAAA,IAAO7I,IAGlB6I,EAAW,CAAA,EACb5N,EAAE,KAAK,CAAC4N,EAAW,CAAA,EAAIA,EAAW,CAAA,CAAE,CAAC,EAErC5N,EAAE,KAAK,CAACN,EAASkO,EAAW,CAAA,EAAIlO,EAASkO,EAAW,CAAA,CAAE,CAAC,EAEzD5N,EAAE,KAAK4N,EAAW,CAAA,CAAE,WAEb,KAAK,QAAQ,aAAe,CAAC,KAAK,QAAQ,SAAU,CAC7D,IAAMC,EAAM,KAAK,YAAY9I,CAAA,EAC7B,GAAI8I,EAAI,CAAA,IAAOA,EAAI,CAAA,EACjB,QAASnR,EAAI,EAAGA,EAAIgD,EAAQhD,IACtBmR,EAAI,CAAA,IAAO,KACT,KAAK,QAAQ,gBACf7N,EAAE,KAAK,CAACtD,EAAI,EAAGgD,CAAM,CAAC,EAEtBM,EAAE,KAAK,CAACtD,EAAI,CAAC,CAAC,EAEhBsD,EAAE,KAAK,CAAC,IAEJ,KAAK,QAAQ,gBACfA,EAAE,KAAK,CAAC,EAAGtD,CAAC,CAAC,EAEbsD,EAAE,KAAK,CAACtD,EAAGA,CAAC,CAAC,EAEfsD,EAAE,KAAK,CAAC,EAIhB,KACE,SAAS,EAAI,EAAG,GAAKN,EAAQ,IACvB,CAAC,KAAK,QAAQ,UAAY,EAAI,IAAMA,IAGpC,KAAK,QAAQ,gBACX,EAAI,EAAIA,EACVM,EAAE,KAAK,CAAC,EAAGN,CAAM,CAAC,EAElBM,EAAE,KAAK,CAAC,EAAG,CAAC,CAAC,EAGfA,EAAE,KAAK,CAAC,EAAG,CAAC,CAAC,EAEfA,EAAE,KAAK,CAAC,GAGZ,GAAI,KAAK,YAAc,EAAG,CACxB,IAAM8N,EAAM,KAAK,SAAS,KAAK,MAAM,KAAK,OAAO,KAAK,UAAA,EAAY,CAAA,CAAA,CAAG,EAAE/I,CAAA,EACjEgJ,EAAO,CAAC,EACd,QAASrR,EAAI,EAAGA,EAAIsD,EAAE,OAAQtD,GAAK,EAAG,CACpC,IAAIoQ,EAAI9M,EAAEtD,CAAA,EACV,GAAIoR,GAAOhB,EAAE,CAAA,GAAMgB,GAAOhB,EAAE,CAAA,EAC1B,GAAIA,EAAE,CAAA,IAAO,EACXA,EAAI,CAACA,EAAE,CAAA,EAAK,EAAGpN,CAAM,UACZA,IAAWoN,EAAE,CAAA,EACtBA,EAAI,CAAC,EAAGA,EAAE,CAAA,EAAK,CAAC,MAEhB,OAAM,MAAM,0CAA0C,EAG1D,IAAIkB,EAAQ,GACZ,QAAS9K,EAAI,EAAGA,EAAI6K,EAAK,OAAQ7K,GAAK,EACpC,GACE6K,EAAK7K,CAAA,EAAG,CAAA,IAAO4J,EAAE,CAAA,GACjBiB,EAAK7K,CAAA,EAAG,CAAA,IAAO4J,EAAE,CAAA,GACjBiB,EAAK7K,EAAI,CAAA,IAAOlD,EAAEtD,EAAI,CAAA,EACtB,CACAsR,EAAQ,GACR,KACF,CAEGA,IACHD,EAAK,KAAKjB,CAAC,EACXiB,EAAK,KAAK/N,EAAEtD,EAAI,CAAA,CAAE,EAEtB,CACAsD,EAAI+N,CACN,CAEA,OAAO/N,CACT,CAEQ,UAAUuK,EAAwB,CACxC,IAAI0D,EAAM,KAAK,OAAO1D,CAAA,EAAO,OAC7B,OAAI,KAAK,iBAAiBA,CAAA,IACxB0D,EAAM,GAGLA,IAAQ,IACN,KAAK,QAAQ,aAAe,CAAC,KAAK,QAAQ,sBAC5CA,IAAQ,IACN,KAAK,QAAQ,WAAa,CAAC,KAAK,QAAQ,oBAC1CA,EAAM,IACJ,KAAK,QAAQ,aAAe,CAAC,KAAK,QAAQ,oBAEjD,CAEQ,UAAU1D,EAAwB,CACxC,IAAI0D,EAAM,KAAK,OAAO1D,CAAA,EAAO,OAC7B,OAAI,KAAK,iBAAiBA,CAAA,IACxB0D,EAAM,GAGLA,IAAQ,GAAK,CAAC,KAAK,QAAQ,qBAC3BA,IAAQ,GAAK,CAAC,KAAK,QAAQ,mBAC3BA,EAAM,GAAK,CAAC,KAAK,QAAQ,mBAE9B,CAEQ,UAAUtK,EAAqB,CACrC,OAAO,KAAK,UAAUA,CAAE,CAC1B,CAEQ,OAAOuK,EAAyB,CACtC,OAAOA,EAAUpQ,GAAY;EAAOoQ,EAAU;CAChD,CAEO,UAAmB,CAExB,IAAMC,EAAK,KAAK,aAAa,EAAK,EAC5BnO,EAAI,CAAC,EACLoO,EAAM,CAAC,EACb,QAAS1R,EAAI,EAAGA,EAAIyR,EAAG,QAAQ,OAAQzR,IAAK,CAC1C,IAAI2R,EAAW,KAAKC,GAAa,KAAK,eAAgBH,EAAG,UAAUzR,CAAA,CAAE,IACjE6R,EAAQ,GACRF,EAASA,EAAS,OAAS,CAAA,IAAO,MACpCA,EAAWA,EAAS,UAAU,EAAGA,EAAS,OAAS,CAAC,EACpDE,EAAQ,IAGVH,EAAI,KAAKC,CAAQ,EACbE,EACFvO,EAAE,KAAK,GAAGqO,MAAaF,EAAG,QAAQzR,CAAA,EAAG,OAAO,EAAE,IAAI,EAAE,MAAM,IAAI,EAE9DsD,EAAE,KAAK,GAAGqO,MAAaF,EAAG,QAAQzR,CAAA,EAAG,OAAO,EAAE,MAAM,IAAI,CAE5D,CACAsD,EAAE,KAAK,QAAQ,EACfA,EAAE,KAAKoO,EAAI,KAAK,GAAG,CAAC,EACpBpO,EAAE,KAAK,IAAI,EACX,IAAMwO,EAAKL,EAAG,OAAO,gBAAgB,EACrC,OAAAnO,EAAE,KACA,QAAQwO,EACL,IAAKjN,GAAM,IAAIA,EAAE,IAAKkN,GAAOA,EAAK,CAAC,EAAE,KAAK,GAAG,IAAI,EACjD,KAAK,GAAG,KACb,EACAzO,EAAE,KAAK,qBAAqB,EAC5BA,EAAE,KAAK,mDAAmD,EAC1DA,EAAE,KAAK,EAAE,EACF,KAAK,OAAO,IAAI,EAAIA,EAAE,KAAK;CAAI,CACxC,CAEO,YAAYgD,EAAe,uBAAgC,CAChE,IAAM0L,EAAK,KAAK,aAAa,EAAK,EAClC,OACE,KAAK,OAAO,IAAI,EAAIA,EAAG,SAAS1L,EAAM,KAAK,cAAc,EAAE,KAAK;CAAI,CAExE,CAEO,qBACL2L,EAAqB,GACrBC,EAAwB,GACL,CAEnB,IAAMC,EADK,KAAK,aAAaF,EAAWC,CAAY,EACtB,oBAAoBA,CAAY,EAG9D,GAFCC,EAA2B,8BAC1B,KAAK,kBACH,CAACA,EACH,MAAM,IAAI,MAAM,qBAAqB,EAEvC,OAAOA,CACT,CAEO,gBACLC,EACAhD,EACAnM,EACAwN,EACA4B,EACAC,EACa,CACb,IAAMC,EAAwB,CAAC,EACzBC,EAAQ,CAAC,EACTC,EAAO,CAAC,EACd,QAAWhI,KAAO,KAAK,UACrB+H,EAAM,KAAKE,EAAKjI,CAAG,CAAC,EACpBgI,EAAK,KAAKE,GAAMlI,CAAG,CAAC,EAEtB,QAAS4F,EAAI+B,EAAU,CAAA,EAAI/B,GAAK+B,EAAU,CAAA,EAAI/B,IAAK,CACjD,IAAMuC,EAAcnC,EAAWJ,CAAA,EAC/B,QAAS7J,EAAI,EAAGA,EAAIoM,EAAY,OAAQpM,GAAK,EAAI8L,EAAc,CAC7D,IAAMO,EAAQD,EAAY,MAAMpM,EAAGA,EAAI,EAAI8L,CAAY,EACjDQ,EAAS,KAAK,aAAaD,EAAM,CAAA,CAAA,EACvC,QAAS3L,EAAK,EAAGA,EAAK2L,EAAM,OAAQ3L,GAAM,EACxC2L,EAAM3L,CAAA,EAAM,KAAK,aAAa2L,EAAM3L,CAAA,CAAA,EAEtC,IAAI6L,EAAM,EACNC,EAAO,EACP/P,IACF8P,EAAMF,EAAM,OAAS,EACrBG,EAAOH,EAAM,OAAS,GAEpBL,EAAMM,CAAA,IAAYJ,EAAK,KAAK,UAAUI,CAAA,CAAO,IAC/CN,EAAMM,CAAA,EAAUN,EAAMM,CAAA,EAAQ,MAAM,EAChC,KAAK,UAAUA,CAAA,EAAU,GAAK,CAAC,KAAK,QAAQ,mBAC9CL,EAAKK,CAAA,EAAUL,EAAKK,CAAA,EAAQ,MAAM,IAGtC,QAAS5L,EAAK,EAAGA,EAAK2L,EAAM,OAAQ3L,GAAM,EACxCsL,EAAMM,CAAA,EAAQD,GAAO3L,EAAK6L,GAAOF,EAAM,MAAA,CAAA,EAAWA,EAAM3L,CAAA,EACpD,KAAK,UAAU4L,CAAA,EAAU,GAAK,CAAC,KAAK,QAAQ,mBAC9CL,EAAKK,CAAA,EAAQD,EAAM3L,CAAA,CAAA,GAChB2L,GAAO3L,EAAK8L,GAAQH,EAAM,MAAA,EACzBA,GAAO3L,EAAK,GAAK2L,EAAM,MAAA,EACvB,EAAI,KAAK,UAAUC,CAAA,GACrB,KAAK,UAAUA,CAAA,EAGvB,CACF,CACA,IAAIG,EAAS,IAAIC,GAAQR,EAAK,EAAE,EAAGC,GAAM,EAAE,EAAG,CAAC,EAC/C,QAASzL,EAAK,EAAGA,EAAK,KAAK,cAAc,OAAQA,IAC/C,GAAI,EAAAmL,GAAY,CAACA,EAASnL,CAAA,GAG1B,GAAI,KAAK,UAAUA,CAAA,IAAQ,GAAK,KAAK,QAAQ,iBACvCsL,EAAMtL,CAAA,IAAQwL,EAAKO,EAAO,KAAK,MAAM,GACnCT,EAAMtL,CAAA,IAAQ+L,EAAO,OACvBA,EAAS,IAAIC,GAAQV,EAAMtL,CAAA,EAAKuL,EAAKvL,CAAA,EAAK,CAAC,GAE7CqL,EAAW,KAAKU,CAAM,GAEtBV,EAAW,KAAK,IAAIW,GAAQV,EAAMtL,CAAA,EAAKuL,EAAKvL,CAAA,EAAK,CAAC,CAAC,MAEhD,CACL,IAAMiM,EAAK,IAAI,MAAcV,EAAKvL,CAAA,EAAI,MAAM,EAE5C,QAAST,EAAK,EAAGA,EAAK+L,EAAMtL,CAAA,EAAI,OAAQT,IACtC0M,EAAG1M,CAAA,EAAMgM,EAAKvL,CAAA,EAAIsL,EAAMtL,CAAA,EAAIT,CAAA,CAAA,EAE9B8L,EAAW,KAAK,IAAIW,GAAQV,EAAMtL,CAAA,EAAKiM,EAAI,KAAK,UAAUjM,CAAA,CAAG,CAAC,CAChE,CAEF,IAAI2H,EAAK,IAAIuE,GAAYb,CAAU,EACnC,OAAInD,IAAW,IACbP,EAAKA,EAAG,UAAUO,CAAM,GAEnBP,CACT,CAEQ,QAAQvI,EAAuB,CACrC,QAAW+M,KAAe,KAAK,QAAQ,cACrC,GAAIA,IAAgB/M,EAClB,MAAO,GAGX,MAAO,EACT,CAEQ,WAAWhG,EAAUkJ,EAAUxG,EAAgByI,EAAc,CACnE,QAASzL,EAAI,EAAGA,EAAIM,EAAE,OAAQN,GAAK,EAAG,CACpC,IAAIsR,EAAQ,GACZ,QAAS9K,EAAI,EAAG,CAAC8K,GAAS9K,EAAIgD,EAAE,OAAQhD,GAAK,EACvCiF,EAEAnL,EAAEN,CAAA,EAAG,CAAA,EAAKwJ,EAAEhD,CAAA,EAAG,CAAA,IAAOxD,GACtB1C,EAAEN,CAAA,EAAG,CAAA,EAAKwJ,EAAEhD,CAAA,EAAG,CAAA,IAAOxD,GACtB1C,EAAEN,EAAI,CAAA,IAAOwJ,EAAEhD,EAAI,CAAA,IAEnB8K,EAAQ,IAIRhR,EAAEN,CAAA,EAAG,CAAA,IAAOwJ,EAAEhD,CAAA,EAAG,CAAA,GACjBlG,EAAEN,CAAA,EAAG,CAAA,IAAOwJ,EAAEhD,CAAA,EAAG,CAAA,GACjBlG,EAAEN,EAAI,CAAA,IAAOwJ,EAAEhD,EAAI,CAAA,IAEnB8K,EAAQ,IAId,GAAI,CAACA,EACH,MAAO,EAEX,CACA,MAAO,EACT,CAGO,aACLW,EACAC,EAAwB,GACX,CAEb,IAAMG,EAAW,CAAC,EAClB,GAAIJ,EACF,QAASjS,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAC7CqS,EAAS,KAAK,CAAC,EAGnB,IAAMiB,EAAqB,CAAC,EACtBC,EAAwB,CAAC,EAGzBC,EAAM,CAAC,EACPC,EAAS,CAAC,EAChB,QAASpL,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAClD,IAAMqL,EAAU,KAAK,YAAYrL,CAAC,EAClCmL,EAAI,KAAKE,CAAO,EACZ,KAAK,QAAQ,aACfD,EAAO,KAAK,CAAC,EAEbA,EAAO,KAAK,CAAC,CAEjB,CACA,IAAME,EAAc,CAAC,EACrB,QAAStL,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAClD,IAAMrF,EAAS,KAAK,cAAcqF,CAAA,EAAG,OAEjCuL,EAAS,GACPF,EAAUF,EAAInL,CAAA,EACpB,QAASrI,EAAI,EAAGA,EAAI0T,EAAQ,OAAQ1T,GAAK,EACnC0T,EAAQ1T,CAAA,EAAG,CAAA,IAAO,GAAK0T,EAAQ1T,CAAA,EAAG,CAAA,IAAOgD,IAC3C4Q,EAAS,IAGbD,EAAYtL,CAAA,EAAKuL,CACnB,CACA,GACE,KAAK,QAAQ,eACZ,KAAK,QAAQ,UAAY,KAAK,QAAQ,iBAAmB,MAC1D,CACA,QAAS5T,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAC7CyT,EAAOzT,CAAA,EAAK,EAEd,QAASqI,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAElD,GAAIsL,EAAYtL,CAAA,EAAI,CAClBoL,EAAOpL,CAAA,EAAK,EACZ,QACF,CAEA,QAASrI,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAClD,IAAI6T,EAAK,KAAK,iBAAiBxL,CAAA,EAC/B,QAASnB,EAAK,EAAGA,EAAK,GAAK,KAAK,cAAclH,CAAA,EAAIkH,IAAM,CAEtD,GADA2M,EAAKA,EAAG,YAAY,KAAK,cAAc7T,CAAA,EAAG,CAAA,CAAE,EACxCyT,EAAOzT,CAAA,EAAKkH,EACd,SAEF,IAAIoK,EAAQ,GACR7F,EAAM,GACV,QAASjF,EAAI,EAAGA,EAAI,KAAK,iBAAiB,OAAQA,IAChD,GAAIqN,EAAG,KAAK,KAAK,iBAAiBrN,CAAA,CAAE,EAAIrF,EAAK,CAC3CmQ,EAAQ9K,EACR,KACF,SAAWqN,EAAG,KAAK,KAAK,iBAAiBrN,CAAA,EAAG,KAAK,EAAE,CAAC,EAAIrF,EAAK,CAC3DmQ,EAAQ9K,EACRiF,EAAM,GACN,KACF,CAEF,GAAI6F,EAAQ,EACV,MAAM,IAAI,MAAM,yBAAyB,EAE3C,IAAMwC,EAAMN,EAAIlC,CAAA,GAEdwC,EAAI,SAAWN,EAAInL,CAAA,EAAG,QACtB,KAAK,cAAcA,CAAA,EAAG,SACpB,KAAK,cAAciJ,CAAA,EAAO,QAC5B,KAAK,WACHwC,EACAN,EAAInL,CAAA,EACJ,KAAK,cAAciJ,CAAA,EAAO,OAC1B7F,CACF,KAEAgI,EAAOzT,CAAA,GAAMkH,EAEjB,CACF,CACF,CACA,QAASlH,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAC7C,GAAIyT,EAAOzT,CAAA,IAAO,EAChByT,EAAOzT,CAAA,EAAK,UACHyT,EAAOzT,CAAA,IAAO,EACnB,KAAK,cAAcA,CAAA,EAAK,EAC1ByT,EAAOzT,CAAA,EAAK,EAEZyT,EAAOzT,CAAA,EAAK,UAELyT,EAAOzT,CAAA,IAAO,EACvByT,EAAOzT,CAAA,EAAK,MAEZ,OAAM,IAAI,MAAM,uBAAuB,CAG7C,CACA,QAASqI,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IACzCoL,EAAOpL,CAAA,IAAO,GAAK,CAACsL,EAAYtL,CAAA,IAClCmL,EAAInL,CAAA,EAAG,KAAK,CAAC,EAAG,KAAK,cAAcA,CAAA,EAAG,MAAM,CAAC,EAC7CmL,EAAInL,CAAA,EAAG,KAAKoL,EAAOpL,CAAA,CAAE,GAGzB,QAASA,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAClD,IAAMqL,EAAUF,EAAInL,CAAA,EACdiK,EAAe,KAAK,cAAcjK,CAAA,EAExC,QAASrI,EAAI,EAAGA,EAAI0T,EAAQ,OAAQ1T,GAAK,EACvC,QAASwG,EAAI,EAAGA,EAAIxG,EAAGwG,GAAK,EAC1B,GACEkN,EAAQ1T,CAAA,EAAG,CAAA,IAAO0T,EAAQlN,CAAA,EAAG,CAAA,GAC7BkN,EAAQ1T,CAAA,EAAG,CAAA,IAAO0T,EAAQlN,CAAA,EAAG,CAAA,EAE7B,MAAM,IAAI,MAAM,6BAA6B,EAInD,IAAMuN,EAAU,CAAC,EACjB,QAAS/T,EAAI,EAAGA,EAAI0T,EAAQ,OAAQ1T,GAAK,EACvC,QAASwG,EAAIkN,EAAQ1T,CAAA,EAAG,CAAA,EAAIwG,GAAKkN,EAAQ1T,CAAA,EAAG,CAAA,EAAIwG,IAC9CuN,EAAQvN,CAAA,EAAK,EAGjB,IAAMiK,EAAa,KAAK,cAAcpI,CAAA,EACtC,QAASrI,EAAI,EAAGA,EAAIyQ,EAAW,OAAQzQ,IAAK,CAC1C,GAAI+T,EAAQ/T,CAAA,IAAO,EACjB,SAEF,IAAM4S,EAAcnC,EAAWzQ,CAAA,EAC/B,QAASwG,EAAI,EAAGA,EAAIoM,EAAY,OAAQpM,GAAK,EAAI8L,EAAc,CAC7D,GAAI,KAAK,UAAUM,EAAYpM,CAAA,CAAE,EAC/B,SAEF,IAAMwN,EAAM,KAAK,aAAapB,EAAYpM,CAAA,CAAA,EAC1C6L,EAAS2B,CAAA,EAAO,CAClB,CACF,CACF,CACA,QAAShU,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAC7C,GAAKqS,EAASrS,CAAA,EAGd,IAAI,KAAK,QAAQ,KAAK,cAAcA,CAAA,CAAE,EAAG,CACvCqS,EAASrS,CAAA,EAAK,EACd,QACF,CACAsT,EAAS,KAAK,KAAK,cAActT,CAAA,CAAE,EACnCuT,EAAQ,KACN,IAAIU,GACF,KAAK,UAAUjU,CAAA,EACf,KAAK,QAAQ,iBAAmB,EAAI,KAAK,UAAUA,CAAA,CACrD,CACF,EAEF,IAAMkU,EAAoB,CAAC,EAC3B,QAASlU,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAIlD,GAHI,CAACqS,EAASrS,CAAA,GAGV,KAAK,QAAQ,KAAK,cAAcA,CAAA,CAAE,EACpC,SAEF,IAAM2B,EAAI,CAAC,EACLyO,EAAI,CAAC,EACX,QAAS5J,EAAI,EAAGA,EAAI,KAAK,UAAUxG,CAAA,EAAIwG,IAAK,CAC1C,GAAIyL,EACFtQ,EAAE,KAAK6E,CAAC,MACH,CACL,IAAMqH,EAAQ,KAAK,eAAe7N,CAAA,EAAGwG,CAAA,EACrC7E,EAAE,KAAK,KAAK,cAAckM,CAAA,CAAM,CAClC,CACAuC,EAAE,KAAK,CAAC,CACV,CACA8D,EAAO,KACL,IAAIhB,GACFvR,EACAyO,EACA,KAAK,QAAQ,iBAAmB,EAAI,KAAK,UAAUpQ,CAAA,CACrD,CACF,CACF,CACA,IAAMmU,EAAsB,CAAC,EACvBC,EAAwB,CAAC,EACzBC,EAAuB,CAAC,EACxBC,EAAoB,CAAC,EAC3B,GAAIpC,EACF,QAAS7J,EAAI,EAAGA,EAAI,KAAK,cAAc,OAAQA,IAAK,CAElD,IAAMrF,EADe,KAAK,cAAcqF,CAAA,EACZ,OACtBqL,EAAUF,EAAInL,CAAA,EACdkM,EAAa,KAAK,YAAYlM,CAAA,EACpC,QAASrI,EAAI,EAAGA,EAAI0T,EAAQ,OAAQ1T,GAAK,EAAG,CAC1C,IAAMwU,EAAWd,EAAQ1T,CAAA,EAGrByU,EACAxR,EAAW,GACf,GAAI,KAAK,iBAAmB,OAC1B,QAAWiO,KAAc,KAAK,eAAgB,CAC5C,GAAIA,EAAW,CAAA,IAAO7I,EACpB,SAEF,IAAI/E,EAAI,CAAC,EACL4N,EAAW,CAAA,EACb5N,EAAI,CAAC4N,EAAW,CAAA,EAAIA,EAAW,CAAA,CAAE,EAEjC5N,EAAI,CAACN,EAASkO,EAAW,CAAA,EAAIlO,EAASkO,EAAW,CAAA,CAAE,EAEjD5N,EAAE,CAAA,IAAOkR,EAAS,CAAA,GAAMlR,EAAE,CAAA,IAAOkR,EAAS,CAAA,IAC5CC,EAAevD,EAAW,CAAA,EAC1BjO,EAAW,CAACiO,EAAW,CAAA,EAE3B,CAEF,GAAIuD,EACFN,EAAU,KAAKM,CAAY,EAC3BL,EAAW,KAAK,EAAI,MACf,CACL,IAAMM,EAAM7R,GAAY0R,EAAYC,EAAUxR,CAAM,EACpDC,EAAWyR,EAAI,CAAA,EACf,IAAM/C,EAAW+C,EAAI,CAAA,EACjBhB,EAAQ1T,EAAI,CAAA,IAAO,EACrBmU,EAAU,KAAKxC,CAAQ,EAEvBwC,EAAU,KAAKxC,EAAW+B,EAAQ1T,EAAI,CAAA,CAAE,EAE1CoU,EAAW,KAAK,EAAK,CACvB,CACAE,EAAO,KAAKE,EAAS,CAAA,IAAO,GAAKA,EAAS,CAAA,IAAOxR,CAAM,EACvD,IAAM6L,EAAK,KAAK,gBACd2F,EACAd,EAAQ1T,EAAI,CAAA,EACZiD,EACA,KAAK,cAAcoF,CAAA,EACnBgK,EACA,KAAK,cAAchK,CAAA,CACrB,EACAgM,EAAM,KAAKxF,CAAE,CACf,CACF,CAEF,IAAIvL,EAAI,IAAIqR,GACVrB,EACAC,EACA,IAAIqB,GAAaV,CAAM,EACvBC,EACAE,EACAC,EACAF,CACF,EACA,OAAI,KAAK,QAAQ,iBACf9Q,EAAIA,EAAE,SAAS,GAEb,KAAK,QAAQ,iBAAmB,GAClCA,EAAE,SAAS,KAAK,QAAQ,cAAc,EAEjCA,CACT,CAEO,YAAYO,EAAY,EAAwB,CACrD,IAAMmO,EAAK,KAAK,aAAa,EAAK,EAClC,OAAOA,EAAG,+BAA+BA,EAAG,0BAA0BnO,CAAC,CAAC,CAC1E,CAEO,iBAA0B,CAC/B,OAAO,KAAK,aAAa,EAAK,EAAE,QAAQ,IAAKgB,GAAMA,EAAE,OAAO,CAAC,CAC/D,CAEO,UAAUgQ,EAAiC,CAEhDC,GAAU,KAAK,aAAa,EAAK,EAAGD,CAAI,CAC1C,CAEO,WAAkB,CAEvB,IAAMvR,EAAI,CAAC,EACX,QAAStD,EAAI,EAAGA,EAAI,KAAK,cAAeA,IACtC,QAASwG,EAAI,EAAGA,EAAI,KAAK,gBAAiBA,IACxClD,EAAE,KAAKtD,CAAC,EAGZ,OAAO,IAAI+U,GAAKzR,CAAC,CACnB,CAMQ,uBAAuB0R,EAA8B,CAC3D,GAAM,CAACC,EAAc,CAACrK,EAAIC,EAAIqK,CAAE,CAAC,EAAIF,EAAgB,CAAA,EAC/CG,EAAa,IAAIjV,EAAK,EAAG0K,EAAI,CAACC,EAAIqK,CAAE,EAEpC,CAACE,EAAc,CAACC,EAAIC,EAAIC,CAAE,CAAC,EAAIP,EAAgB,CAAA,EAC/CQ,EAAa,IAAItV,EAAK,EAAGmV,EAAI,CAACC,EAAIC,CAAE,EACtCE,EAAwB,KACxBC,EAAwB,KACtBC,EAAkB,KAAK,SAAS,UAAUV,CAAY,EACtDW,EAAkB,KAAK,SAAS,UAAUR,CAAY,EAC5D,QAAWS,KAAM,KAAK,WAChBF,IAAoBE,EAAG,CAAA,IACzBJ,EAAWI,EAAG,CAAA,GAEZD,IAAoBC,EAAG,CAAA,IACzBH,EAAWG,EAAG,CAAA,GAGlB,GAAI,CAACJ,EACH,MAAM,IAAI,MAAM,0BAA0BR,GAAc,EAE1D,GAAI,CAACS,EACH,MAAM,IAAI,MAAM,0BAA0BN,GAAc,EAE1D,IAAMU,EAAKL,EAAS,cAAcN,CAAU,EAK5C,OAJoBO,EAAS,YAAYI,CAAE,EAExC,UAAUX,CAAU,EACpB,cAAcK,EAAW,UAAUL,CAAU,CAAC,EACvC,IAAIW,CAAE,CAClB,CAEQ,sBAA6B,CACnC,IAAMC,EAAgB,KAAK,cACvBC,EAAiE,KAWrE,GAVI,KAAK,QAAQ,kBACfA,EAAyB,KAAK,QAAQ,kBAC7B,KAAK,QAAQ,qBACtBA,EAAyB,KAAK,QAAQ,mBAAmBD,CAAA,GAItDC,IACHA,EAAyBvU,GAAoB,EAAEsU,CAAA,GAE7C,CAACC,EACH,MAAM,IAAI,MAAM,yBAAyB,EAE3C,OAAO,KAAK,uBAAuBA,CAAsB,CAC3D,CAEQ,kBACNC,EAAY,IACZC,EAAY,IACZC,EAAe,GACfC,EAAkB,GAClBC,EAAqB,IACc,CAEnCJ,GAAK,EAAIE,EACTD,GAAK,EAAIC,EACT,SAASG,EAAYhW,EAAeuD,EAAiB,CACnD,IAAI0S,EAAKjW,EAAE,CAAA,EAAG,CAAA,EAAKA,EAAE,CAAA,EAAG,CAAA,EACpBkW,EAAKlW,EAAE,CAAA,EAAG,CAAA,EAAKA,EAAE,CAAA,EAAG,CAAA,EAClBmW,EAAO,EAAI,KAAK,GAAM5S,EACtB6S,EAAO,KAAK,IAAID,CAAG,EACnBE,EAAO,KAAK,IAAIF,CAAG,EACzB,QAASzW,EAAI,EAAGA,EAAI6D,EAAG7D,IAAK,CAC1B,IAAM4W,EAAML,EAAKG,EAAOF,EAAKG,EAC7BH,EAAKA,EAAKE,EAAOH,EAAKI,EACtBJ,EAAKK,EACLtW,EAAE,KAAK,CAACA,EAAEN,EAAI,CAAA,EAAG,CAAA,EAAKuW,EAAIjW,EAAEN,EAAI,CAAA,EAAG,CAAA,EAAKwW,CAAE,CAAC,CAC7C,CACF,CAKA,KAAK,SAAS,EAGd,IAAMK,EAFc,KAAK,oBAAoB,EACnB,UAAU,CAAA,EAAG,CAAA,EACnB,OACd/R,EAAM,KAAK,IACjB,GAAIA,IAAQ,KACV,MAAM,IAAI,MAAM,SAAS,EAE3B,IAAMgS,EAAa,CAAC,EAChBC,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAO,EACXJ,EAAMhS,EAAI,CAAA,EAAG,CAAA,CAAA,EAAM,CACjB,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,CAAC,CACP,EACAwR,EAAYQ,EAAMhS,EAAI,CAAA,EAAG,CAAA,CAAA,EAAK+R,CAAK,EACnC,QAAW9P,KAAQjC,EAAK,CACtB,IAAMkC,EAAKD,EAAK,CAAA,EAChB,GAAI,CAAC+P,EAAM9P,CAAA,EACT,MAAM,IAAI,MAAM,iDAAiD,EAEnE,QAASR,EAAI,EAAGA,EAAIO,EAAK,OAAQP,IAAK,CACpC,IAAMwB,EAAKjB,EAAKP,CAAA,EACZwB,IAAO,IAAM8O,EAAM9O,CAAA,IAGvB8O,EAAM9O,CAAA,EAAM,CAAC8O,EAAM9P,CAAA,EAAIR,EAAIqQ,CAAA,EAAQC,EAAM9P,CAAA,GAAKR,EAAIqQ,EAAQ,GAAKA,CAAA,CAAM,EACrEP,EAAYQ,EAAM9O,CAAA,EAAK6O,CAAK,EAC9B,CACF,CACA,QAAWzN,KAAK0N,EAAO,CACrB,IAAMK,EAAKL,EAAM1N,CAAA,EACjB,QAAWgO,KAAOD,EAChBJ,EAAO,KAAK,IAAIA,EAAMK,EAAI,CAAA,CAAE,EAC5BH,EAAO,KAAK,IAAIA,EAAMG,EAAI,CAAA,CAAE,EAC5BJ,EAAO,KAAK,IAAIA,EAAMI,EAAI,CAAA,CAAE,EAC5BF,EAAO,KAAK,IAAIA,EAAME,EAAI,CAAA,CAAE,CAEhC,CACA,IAAM1G,EAAK,KAAK,IAAIuF,GAAKgB,EAAOF,GAAOb,GAAKgB,EAAOF,EAAK,EAClDK,EAAO,IAAOpB,EAAIvF,GAAMuG,EAAOF,IAC/BO,EAAO,IAAOpB,EAAIxF,GAAMwG,EAAOF,IAC/BO,EAA+B,CAAC,EAChCC,EAAK,KAAK,oBAAoB,EAC9BC,EAAc,CAAC,EACfC,EAAQ,CACZ,CAAChH,EAAK2G,EAAMC,CAAI,EAChB,CAACD,EAAMC,CAAI,CACb,EACAG,EAAO3S,EAAI,CAAA,EAAG,CAAA,CAAA,EAAM4S,EACpBpB,EAAYmB,EAAO3S,EAAI,CAAA,EAAG,CAAA,CAAA,EAAK+R,CAAK,EACpCU,EAAK,KAAK,UAAU,CAAA,EAAG,CAAA,CAAA,EAAM,KAAK,UAAU,EAAG,EAAG,CAChD,IAAIrX,EAAK,EAAGwX,EAAM,CAAA,EAAG,CAAA,EAAIA,EAAM,CAAA,EAAG,CAAA,EAAI,CAAC,EACvC,IAAIxX,EAAK,EAAGwX,EAAM,CAAA,EAAG,CAAA,EAAIA,EAAM,CAAA,EAAG,CAAA,EAAI,CAAC,CACzC,CAAC,EACD,IAAMC,EAAY,CAAC,EACnBA,EAAU,CAAA,EAAK,EACf,QAAW5Q,KAAQjC,EAAK,CACtB,IAAMkC,EAAKD,EAAK,CAAA,EAChB,GAAI,CAAC0Q,EAAOzQ,CAAA,EACV,MAAM,IAAI,MAAM,iDAAiD,EAEnE,IAAI4Q,EAAM,GACV,QAASpR,EAAI,EAAGA,EAAIgR,EAAG,UAAU,OAAQhR,IACvC,GAAIQ,IAAOwQ,EAAG,UAAUhR,CAAA,EAAG,CAAA,EAAI,CAC7BoR,EAAMpR,EACN,KACF,CAEF,GAAIoR,EAAM,EACR,MAAM,IAAI,MAAM,kCAAkC5Q,GAAI,EAExD,IAAM6Q,EAAWL,EAAG,UAAUI,CAAA,EAAK,CAAA,EACnC,QAASpR,EAAI,EAAGA,EAAIO,EAAK,OAAQP,IAAK,CACpC,IAAMwB,EAAKjB,EAAKP,CAAA,EAChB,GAAIwB,IAAO,IAAMyP,EAAOzP,CAAA,EACtB,SAEFyP,EAAOzP,CAAA,EAAM,CACXyP,EAAOzQ,CAAA,EAAIR,EAAIqQ,CAAA,EACfY,EAAOzQ,CAAA,GAAKR,EAAIqQ,EAAQ,GAAKA,CAAA,CAC/B,EACAP,EAAYmB,EAAOzP,CAAA,EAAK6O,CAAK,EAE7B,IAAMiB,EAAOH,EAAUC,CAAA,EACjBG,EAAKF,GAAUC,EAAOtR,GAAKqQ,CAAA,EAC9B,IAAIgB,GAAUC,EAAOtR,EAAIqQ,EAAQ,GAAKA,CAAA,CAAM,EAC5C,KAAK,EAAG,EACLmB,EAAMtW,GAAY8V,EAAG,UAAWO,CAAE,EAClCxP,GAAWiP,EAAG,UAAUQ,CAAA,EAAK,CAAA,EAC7BzR,EAAKnD,GAAiBmF,GAAU,KAAK,SAAS,EAC9C0P,GAAM1R,EAAGS,IAAOT,EAAG,CAAA,EAAK,EAAI,CAAA,EAC9B2R,EAAO,GACX,QAAS7P,EAAI,EAAGA,EAAImP,EAAG,UAAU,OAAQnP,IACvC,GAAI4P,KAAQT,EAAG,UAAUnP,CAAA,EAAG,CAAA,EAAI,CAC9B6P,EAAO7P,EACP,KACF,CAEF,GAAI6P,EAAO,EACT,MAAM,IAAI,MAAM,iCAAiC,EAEnD,IAAMC,EAAYX,EAAG,UAAUU,CAAA,EAAM,CAAA,EACrC,QAAS7P,EAAI,EAAGA,EAAI8P,EAAU,OAAQ9P,IAEpC,GADY8P,EAAU9P,CAAA,EAAG,IAAI8P,GAAW9P,EAAI,GAAKwO,CAAA,CAAM,EAAE,KAAK,EAAG,EACzD,KAAKkB,CAAE,GAAK5W,EAAK,CACvB,IAAMiX,EAAKX,EAAOzQ,CAAA,GAAKR,EAAIqQ,EAAQ,GAAKA,CAAA,EAClCwB,EAAKZ,EAAOzQ,CAAA,EAAIR,EAAIqQ,CAAA,EAC1Bc,EAAUO,CAAA,EAAQ7P,EAClBkP,EAAKU,EAAA,EAAO,KAAK,UAAUC,EAAM7P,EAAG,CAClC,IAAInI,EAAK,EAAGmY,EAAG,CAAA,EAAIA,EAAG,CAAA,EAAI,CAAC,EAC3B,IAAInY,EAAK,EAAGkY,EAAG,CAAA,EAAIA,EAAG,CAAA,EAAI,CAAC,CAC7B,CAAC,EACD,KACF,CAEJ,CACF,CACA,IAAIE,EAAM,EACNC,EAAM,EACJrX,EAAM,KAAK,qBAAqB,EACtC,QAASV,KAAQ,KAAK,MAAO,CACvB4V,IACF5V,EAAOA,EAAK,OAAOU,CAAG,GAExB,QAASsF,EAAI,EAAGA,EAAIhG,EAAK,OAAQgG,IAC/B8R,EAAM,KAAK,IAAIA,EAAK,KAAK,IAAI9X,EAAK,IAAIgG,CAAC,EAAE,CAAC,CAAC,EAC3C+R,EAAM,KAAK,IAAIA,EAAK,KAAK,IAAI/X,EAAK,IAAIgG,CAAC,EAAE,CAAC,CAAC,CAE/C,CACA,IAAMgS,EAAM,KAAK,IAAItC,EAAIqC,EAAM,GAAItC,EAAIE,GAAQmC,EAAM,CAAC,EAkBtD,MAjBgB,CAACvQ,EAAYhI,IAAsB,CACjD,GAAIqW,EAAQ,CACVrW,EAAIA,EAAE,YAAYmB,CAAG,EACrB,IAAMuX,EAAQ,GAAMtC,EAAO,IAAOF,EAC5ByC,EAAO,KAAK,WAAW3Q,CAAA,EAAI,YAAY7G,CAAG,EAAE,EAAI,EAAI,EAAI,GAC9D,MAAO,CACLiV,EAAOF,EAAI,GAAMyC,GAAQD,EAAQ1Y,EAAE,EAAIyY,GACvCrC,EAAOD,EAAI,GAAMnW,EAAE,EAAIyY,CACzB,CACF,KAAO,CACL,IAAMrU,EAAIoT,EAAK,KAAK,UAAUxP,CAAA,EAAI,CAAA,CAAA,EAClC,MAAO,CACLoO,EAAOE,EAAatW,EAAE,IAAIoE,EAAE,CAAA,CAAE,EAAIA,EAAE,CAAA,EAAG,EACvCgS,EAAOD,EAAIG,EAAatW,EAAE,IAAIoE,EAAE,CAAA,CAAE,EAAIA,EAAE,CAAA,EAAG,CAC7C,CACF,CACF,CAEF,CAEO,YACL8R,EAAY,IACZC,EAAY,IACZC,EAAe,GACfC,EAAkB,GACV,CACR,IAAMuC,EAAU,KAAK,kBAAkB1C,EAAGC,EAAGC,EAAMC,CAAM,EACzD,SAASwC,EAAUC,EAAYC,EAAiBC,EAAuB,CACrE,MAAO,gBAAgBF,mCAAoCE,cAAkBD,EAC1E,IAAKnX,GAAM,GAAGA,EAAE,CAAA,KAAMA,EAAE,CAAA,GAAI,EAC5B,KAAK,GAAG;CACb,CAKA,IAAM+J,EAAM,KAAK,UAAU,EACrBsN,EAAW,CAAC,EACZC,EAAU,CAAC,EACjB,QAASjZ,EAAI,EAAGA,EAAI,KAAK,cAAeA,IACtCgZ,EAAShZ,CAAA,EAAK,KAAK,OAAO,KAAK,UAAUA,CAAA,EAAG,CAAA,CAAA,EAE9C,QAASA,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IAAK,CAC1C,IAAMQ,EAAO,KAAK,MAAMR,CAAA,EAClBkZ,EAAU,KAAK,MAAMlZ,EAAI,KAAK,eAAe,EAC7CmZ,EAAK,CAAC,EACZ,QAAS3S,EAAI,EAAGA,EAAIhG,EAAK,OAAQgG,IAC/B2S,EAAG,KAAKR,EAAQO,EAAS1Y,EAAK,IAAIgG,CAAC,CAAC,CAAC,EAEvCyS,EAAQ,KAAKE,CAAE,CACjB,CACA,IAAMC,EAAM,CAAC,EAEb,QAAS5S,EAAI,EAAGA,EAAI,KAAK,cAAeA,IAAK,CAC3C4S,EAAI,KAAK,KAAK,EACdA,EAAI,KAAK,UAAU,KAAK,UAAU5S,CAAA,EAAG,CAAA;CAAc,EACnD,QAASU,EAAK,EAAGA,EAAK,KAAK,gBAAiBA,IAAM,CAChD,IAAMlH,EAAIwG,EAAI,KAAK,gBAAkBU,EAC/B2G,EAAQ,KAAK,YAAY7N,CAAA,EACzBqZ,EAAW,KAAK,UAAUrZ,CAAA,EAC1BqN,EAAc,KAAK,aAAaQ,CAAA,EAChCyL,EAAW,KAAK,aAAazL,CAAA,EAC7BkL,EAAQ,KAAK,UAAUlL,CAAK,EAAI,UAAYmL,EAAStN,EAAI,EAAE1L,CAAA,CAAA,EAC7D6Y,EAAK,GAAG,KAAK,cAAcxL,CAAA,MAAiBiM,MAAaD,IAE7D,GADAD,EAAI,KAAKR,EAAUC,EAAII,EAAQjZ,CAAA,EAAI+Y,CAAK,CAAC,EACrC,KAAK,gBAAgB/Y,CAAA,EACvB,QAASyG,EAAK,EAAGA,EAAK,KAAK,gBAAgBzG,CAAA,EAAIyG,IAC7CoS,EAAK,GAAG,KAAK,cAAcxL,CAAA,MAAiBiM,MAAa7S,IACzD2S,EAAI,KAAKR,EAAUC,EAAII,EAAQjZ,CAAA,EAAI+Y,CAAK,CAAC,CAG/C,CACAK,EAAI,KAAK,MAAM,CACjB,CAIA,MAHa;;EAAoNA,EAAI,KACnO,EACF,SAEF,CAMO,MAAM5W,EAAoD,CAC/D,IAAM+W,EAAW,CAAC,EACZrY,EAAM,KAAK,qBAAqB,EAChCF,EAAQ,CAAC,EACT2C,EAAkB,IAAO,KAAK,UAAU,CAAA,EAAG,IAAI,CAAC,EAAE,IAAI,EAC5D,QAAS3D,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAAK,CAC9C,IAAMwZ,EAAS,KAAK,UAAUxZ,CAAA,EAAG,OAAOkB,CAAG,EACrCoF,EAAO,KAAK,UAAUtG,CAAA,EAAG,CAAA,EAC/BgB,EAAM,KAAK,CAAE,OAAQ4C,GAAa4V,EAAQ7V,CAAO,EAAG,KAAA2C,CAAK,CAAC,CAC5D,CACA,QAAStG,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IAAK,CAC1C,IAAMkZ,EAAU,KAAK,MAAMlZ,EAAI,KAAK,eAAe,EAC7C6N,EAAQ,KAAK,YAAY7N,CAAA,EACzBqZ,EAAW,KAAK,UAAUrZ,CAAA,EAC1BqN,EAAc,KAAK,aAAaQ,CAAA,EAChCyL,EAAW,KAAK,aAAazL,CAAA,EAC/BkL,EAAQ,KAAK,UAAUlL,CAAK,EAC5B,UACA,KAAK,OAAO,KAAK,UAAUqL,CAAA,EAAS,CAAA,CAAA,EACpC1W,GAAS,gBACXuW,EAAQvW,EAAQ,cAAcxC,CAAA,GAEhC,IAAMwZ,EAAS,KAAK,MAAMxZ,CAAA,EAAG,OAAOkB,CAAG,EACvCqY,EAAS,KAAK,CACZ,OAAQ3V,GAAa4V,EAAQ7V,CAAO,EACpC,MAAAoV,EACA,MAAO,KAAK,cAAc1L,CAAA,EAC1B,IAAKiM,EACL,IAAKD,EACL,KAAMH,CACR,CAAC,EACD,IAAIO,EAAUD,EACd,GAAI,KAAK,gBAAgBxZ,CAAA,EAAI,CAC3B,IAAM0Z,EAAUD,EAAQ,OAAS,KAAK,gBAAgBzZ,CAAA,EACtD,QAASyG,EAAK,EAAGA,EAAK,KAAK,gBAAgBzG,CAAA,EAAIyG,IAAM,CACnD,QAAS4B,EAAI,EAAGA,EAAIqR,EAASrR,IAC3BoR,EAAUA,EAAQ,cAAc,EAElCF,EAAS,KAAK,CACZ,OAAQ3V,GAAa6V,EAAS9V,CAAO,EACrC,MAAAoV,EACA,MAAO,KAAK,cAAc1L,CAAA,EAC1B,IAAKiM,EACL,IAAK7S,EACL,KAAMyS,EACN,MAAO,EACT,CAAC,CACH,CACF,CACF,CACA,IAAMS,EAA0B,CAAC,EACjC,QAAS3Z,EAAI,EAAGA,EAAI,KAAK,YAAY,OAAQA,IAAK,CAChD,IAAMmR,EAAM,KAAK,YAAYnR,CAAA,EACvB4Z,EAAQ,KAAK,cAAc5Z,CAAA,EACjC,QAAW6V,KAAM,KAAK,WAChB1E,EAAI,CAAA,IAAO0E,EAAG,CAAA,GAAM1E,EAAI,CAAA,IAAO0E,EAAG,CAAA,IACpC8D,EAAM,KAAK,CACT,YAAajW,GAASmS,EAAG,CAAA,EAAG,YAAY3U,CAAG,EAAG,CAAC,EAC/C,YAAa,IAAImO,EAAK8B,EAAI,CAAA,CAAE,EAC5B,MAAAyI,CACF,CAAC,EACDD,EAAM,KAAK,CACT,YAAajW,GAASmS,EAAG,CAAA,EAAG,YAAY3U,CAAG,EAAE,KAAK,EAAE,EAAG,CAAC,EACxD,YAAa,IAAImO,EAAK8B,EAAI,CAAA,CAAE,EAC5B,MAAAyI,CACF,CAAC,EAGP,CACA,IAAMC,EAAa,KAAK,kBAAkB,KAAM,KAAM,EAAG,GAAO,CAAG,EAC7D1V,EAAK,UAAY,CACrB,IAAM2V,EAAO5Y,EAAI,OAAO,EACxB,OAAO,SAAUgY,EAAiBM,EAA4B,CAC5D,IAAIzZ,EAAI,IAAIG,EACV,EACAsZ,EAAO,CAAA,EAAK7V,EACZ,CAAC6V,EAAO,CAAA,EAAK7V,EACb6V,EAAO,CAAA,EAAK7V,CACd,EACA5D,EAAIA,EAAE,YAAY+Z,CAAI,EACtB,IAAMC,EAAIF,EAAWX,EAASnZ,CAAC,EAC/B,OAAAga,EAAE,CAAA,GAAM,KACRA,EAAE,CAAA,EAAK,EAAIA,EAAE,CAAA,EAAK,KACXA,CACT,CACF,EAAG,EAAE,KAAK,IAAI,EACd,MAAO,CACL,SAAAR,EACA,MAAAvY,EACA,KAAM2Y,EACN,UAAW,KAAK,UAAU,KAAK,IAAI,EACnC,eAAgB,KAAK,eACrB,cAAe,CAAE,MAAOxV,CAAE,CAC5B,CACF,CAOO,aAAawL,EAAuC,CACzD,IAAMzO,EAAM,KAAK,qBAAqB,EAChC8N,EAAO,KAAK,SAAS,UAAUW,CAAO,EAC5C,QAAWkG,KAAM,KAAK,WACpB,GAAI7G,IAAS6G,EAAG,CAAA,EAAI,CAClB,IAAMvS,EAAII,GAASmS,EAAG,CAAA,EAAG,YAAY3U,CAAG,EAAG,CAAC,EAO5C,OAAI,KAAK,IAAIoC,EAAE,CAAA,CAAE,EAAInC,GAAO,KAAK,IAAImC,EAAE,CAAA,CAAE,EAAInC,IAC3CmC,EAAE,CAAA,EAAK,EACPA,EAAE,CAAA,EAAK,MAEFA,CACT,CAGJ,CAEQ,aAAa4V,EAAyB,CAC5C,IAAMc,EAAQ,KAAK,gBACnB,OAAO,KAAK,MAAMd,EAAUc,CAAK,CACnC,CAEO,wBAAiC,CACtC,MAAO,SAAS,KAAK,aAAa;oBAClB,KAAK;aACZ,KAAK;SACT,KAAK,OAAO;gBACL,KAAK;kBACH,KAAK,gBACrB,CAEA,kBAAkBC,EAAyB,CAEzC,IAAMC,EADK,KAAK,aAAa,EAAK,EACpB,eAAe,EAC7BD,EAAG,sBAAsBC,GAAI,EAC7B,IAAMC,EAAKC,GAAa,KAAK,gBAAgB,EAAGH,CAAE,EAC5C3W,EAAI4W,EAAKC,EACfF,EAAG,YAAY3W,GAAG,CACpB,CACF,EAEa+W,GAAN,KAAiB,CAEtB,YAAoB3X,EAAoBsP,EAAiB,CAArC,KAAA,GAAAtP,EAClB,KAAK,WAAasP,EAAG,UACvB,CAEO,WAAWzC,EAAwC,CACxD,IAAMV,EAAK,KAAK,GAAG,UAAUU,CAAI,EAEjC,GAAI,KAAK,GAAG,eAAgB,CAC1B,IAAI+B,EAAQ,GACZ,QAAWJ,KAAc,KAAK,GAAG,eAE7BA,EAAW,CAAA,IAAOrC,EAAG,CAAA,GACrBqC,EAAW,CAAA,IAAOrC,EAAG,CAAA,GACrBqC,EAAW,CAAA,IAAOrC,EAAG,CAAA,GACrBqC,EAAW,CAAA,IAAOrC,EAAG,CAAA,IAErByC,EAAQ,IAGZ,GAAI,CAACA,EACH,OAAO,IAEX,CACA,IAAIvO,EAAO,CAAC8L,EAAG,CAAA,EAAIA,EAAG,CAAA,CAAE,EACxB,GAAI,CAACA,EAAG,CAAA,EAAI,CACV,IAAM7L,EAAS,KAAK,GAAG,cAAc6L,EAAG,CAAA,CAAA,EAAI,OAC5C9L,EAAO,CAACC,EAAS6L,EAAG,CAAA,EAAI7L,EAAS6L,EAAG,CAAA,CAAE,CACxC,CACA,IAAMyL,EAAO,KAAK,GAAG,gBACnBvX,EACA8L,EAAG,CAAA,EACH,CAACA,EAAG,CAAA,EACJ,KAAK,GAAG,cAAcA,EAAG,CAAA,CAAA,EACzB,OACA,KAAK,GAAG,cAAcA,EAAG,CAAA,CAAA,CAC3B,EAEA,OADU8F,GAAY,+BAA+B,KAAK,WAAY2F,CAAI,CAE5E,CACF",
  "names": ["FaceNameSwizzler", "facenames", "gripnames_arg", "i", "j", "names", "s", "r", "at", "currentMatch", "list", "sep", "userinput", "longname", "e1", "e2", "found", "upperCaseGrip", "g", "NullMapper", "move", "FTONotationMapper", "child", "sw", "Move", "QuantumMove", "fam", "FaceRenamingMapper", "internalNames", "externalNames", "grip", "a", "b", "suffix", "upper", "isLowerCase", "ngrip", "MegaminxScramblingNotationMapper", "NxNxNCubeMapper", "slices", "pyraminxFamilyMap", "tetraminxFamilyMap", "pyraminxFamilyMapWCA", "pyraminxExternalQuantumY", "pyraminxInternalQuantumY", "PyraminxNotationMapper", "newFamilyWCA", "newFamily", "external", "internal", "TetraminxNotationMapper", "skewbFamilyMap", "skewbExternalQuantumX", "skewbInternalQuantumX", "skewbInternalQuantumXPrime", "skewbExternalQuantumY", "skewbInternalQuantumY", "skewbInternalQuantumYPrime", "skewbExternalQuantumZ", "skewbInternalQuantumZ", "skewbInternalQuantumZPrime", "SkewbNotationMapper", "parseOptions", "argv", "argp", "options", "option", "parsePuzzleDescription", "PuzzleGeometryFullOptions", "zeroCache", "iotaCache", "zeros", "n", "c", "iota", "identity", "Perm", "factorial", "gcd", "t", "m", "lcm", "p2", "cyc", "seen", "incyc", "cs", "PGOrbitDef", "size", "mod", "lastGlobalDefinitionCounter", "externalName", "mapper", "moveString", "mv", "mv2", "PGOrbitsDef", "orbitnames", "orbitdefs", "solved", "movenames", "moveops", "isRotation", "forcenames", "mp", "mvname", "pd", "name", "result", "doinv", "includemoves", "orbits", "start", "startTransformation", "moves", "neworbitnames", "neworbitdefs", "newsolved", "newmoveops", "om", "du", "DisjointUnion", "changed", "k", "keepori", "duo", "o", "nontriv", "multiple", "no", "on", "nv", "VisibleState", "_", "PGTransform", "pool", "ri", "rj", "rm", "_PGOrbit", "perm", "ori", "orimod", "newPerm", "newOri", "done", "v", "nextNew", "reassign", "ov", "useVS", "concise", "newori", "PGOrbit", "PGTransformBase", "newOrbits", "orbit", "perms", "p", "h", "ah", "bh", "showcanon", "disp", "orders", "commutes", "permA", "bits", "permB", "curlev", "d", "sum", "nextlev", "uniq", "sti", "st", "cnt", "nst", "PGPuzzles", "eps", "centermassface", "face", "Quat", "solvethreeplanes", "p1", "p3", "planes", "dt", "q", "a00", "a01", "a02", "a10", "a11", "a12", "a20", "a21", "a22", "ab", "ac", "ad", "det", "x", "inout", "nface", "kk", "vk", "vkk", "pt", "faces", "nfaces", "cube", "s5", "tetrahedron", "dodecahedron", "d36", "dx", "dy", "dd", "icosahedron", "ang", "octahedron", "closure", "ns", "negns", "wasseen", "uniqueplanes", "planerot", "getface", "FactoredNumber", "f", "schreierSims", "e", "sgs", "sgsi", "sgslen", "Tk", "Tklen", "resolve", "knutha", "len", "knuthb", "getsgs", "none", "sz", "tks", "sollen", "avgs", "mults", "lensum", "avg", "Face", "q", "i", "off", "Quat", "sx", "sy", "sz", "a", "FaceTree", "face", "left", "right", "t", "arr", "leftfirst", "expandfaces", "rots", "faces", "nfaces", "rot", "eps", "copyright", "permissivieMoveParsing", "defaultnets", "defaultcolors", "orientationDefaults", "defaultOrientations", "findelement", "p", "getPG3DNamedPuzzles", "PGPuzzles", "getPuzzleDescriptionString", "puzzleName", "PUZZLE_BASE_SHAPES", "PUZZLE_CUT_TYPES", "parsePuzzleDescription", "s", "shape", "cuts", "getPuzzleGeometryByDesc", "desc", "options", "parsed", "pg", "PuzzleGeometry", "getPuzzleGeometryByName", "getmovename", "geo", "bits", "slices", "inverted", "movenameFamily", "movenamePrefix", "splitByFaceNames", "facenames", "r", "at", "currentMatch", "facename", "toCoords", "maxdist", "toFaceCoords", "n", "pt", "puzzleDescription", "NullMapper", "t1", "PuzzleGeometryFullOptions", "g", "cube", "octahedron", "icosahedron", "tetrahedron", "dodecahedron", "closure", "baseplane", "uniqueplanes", "baseplanes", "_", "net", "baseface", "getface", "zero", "facenormal", "edgenormal", "vertexnormal", "boundary", "planes", "firstface", "cutplanes", "intersects", "sawface", "sawedge", "sawvertex", "cut", "normal", "distance", "baseplanerot", "faceplanes", "vertexnames", "edgenames", "edgesperface", "searchaddelement", "name", "el", "j", "jj", "midpoint", "otherfaces", "facelist", "facenametoindex", "faceindextoname", "neti", "f0", "fi", "ii", "fn2", "of", "faceplane", "jjj", "midpoint2", "e1", "e2", "FaceNameSwizzler", "sep", "oridata", "markedface", "oriprefs", "fn", "f1", "f2", "c1", "c2", "st", "k", "geonormals", "edgename", "vertexname", "geonormalnames", "c", "rotation", "wasseen", "moveplane", "ft", "tar", "rval", "simplerot", "cm", "centermassface", "f", "finished", "sortme", "cm2", "b", "kk", "FaceRenamingMapper", "sfcc", "moveplaneset", "dv", "key", "face2", "facen", "edgen", "targvec", "edgen2", "plane", "x0", "olen", "y0", "delta", "len", "cosr", "sinr", "x1", "y1", "moveplanesets", "moveplanenormals", "qnormal", "moveplanenormal", "goodnormal", "sizes", "moverotations", "sizes2", "movesetgeos", "gtype", "p0", "neg", "pos", "geonormal", "d", "NxNxNCubeMapper", "SkewbNotationMapper", "PyraminxNotationMapper", "TetraminxNotationMapper", "MegaminxScramblingNotationMapper", "FTONotationMapper", "facelisthash", "suff", "s2", "cubies", "facetocubie", "facetoord", "cmall", "looplimit", "changed", "u", "v", "mini", "ofacelist", "typenames", "cubiesetnames", "cubietypecounts", "orbitoris", "seen", "cubiesetnum", "cubiesetnums", "cubieordnums", "cubieords", "cubievaluemap", "getcolorkey", "cubienum", "cubiesetcubies", "cubie", "cubiekeymap", "cubievalueid", "facecnt", "typectr", "typename", "queue", "qg", "cind", "cubiecolorkey", "moverotation", "tq", "reidorder", "reidmap", "mask", "cubieset", "mv", "newmv", "re", "grip", "loslice", "hislice", "amountstr", "amount", "Move", "QuantumMove", "move", "bm", "fullrotation", "msi", "geoname", "firstgrip", "cmovesbyslice", "center", "towards", "hiv", "hii", "hii2", "qs", "o", "m", "slicenum", "slicecnts", "bhi", "axiscmoves", "sc", "cubiedone", "ocm", "fi2", "face1", "face0", "parsedmovelist", "moveString", "parsedmove", "msg", "dep", "newr", "found", "ori", "comment", "os", "mvs", "movename", "externalName", "doinv", "ip", "__", "od", "fortwisty", "includemoves", "internalDefinition", "moverange", "setmoves", "movesetorder", "moveorbits", "perms", "oris", "iota", "zeros", "slicecmoves", "mperm", "setnum", "inc", "oinc", "lastId", "PGOrbit", "no", "PGTransform", "excludedSet", "setnames", "setdefs", "mps", "addrot", "moveset", "hasrotation", "sawone", "nn", "cmp", "allbits", "ind", "PGOrbitDef", "solved", "movenames", "forcenames", "moves", "isrots", "movesetgeo", "movebits", "nameoverride", "mna", "PGOrbitsDef", "VisibleState", "disp", "showcanon", "Perm", "desiredRotation", "feature1name", "z1", "direction1", "feature2name", "x2", "y2", "z2", "direction2", "feature1", "feature2", "feature1geoname", "feature2geoname", "gn", "r1", "basefacecount", "orientationDescription", "w", "h", "trim", "threed", "twodshrink", "extendedges", "dx", "dy", "ang", "cosa", "sina", "ndx", "polyn", "edges", "minx", "miny", "maxx", "maxy", "es", "esi", "xoff", "yoff", "geos", "bg", "edges2", "initv", "connectat", "gfi", "thisface", "caf0", "mp", "epi", "gf1", "gf1i", "otherface", "p1", "p2", "hix", "hiy", "sc2", "xoff2", "xmul", "mappt2d", "drawedges", "id", "pts", "color", "colormap", "facegeo", "facenum", "fg", "svg", "cubieori", "cubieord", "stickers", "coords", "fcoords", "rotdist", "grips", "order", "twodmapper", "irot", "x", "divid", "tw", "as", "ss", "schreierSims", "PGNotation", "pgmv"]
}
