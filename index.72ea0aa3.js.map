{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/runtime-c41f8503fb76ff5a.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/cubing/dist/esm/chunk-OFSJREI7.js","node_modules/cubing/src/cubing/twisty/debug.ts","node_modules/cubing/src/cubing/twisty/model/PromiseFreshener.ts","node_modules/cubing/src/cubing/twisty/model/props/TwistyProp.ts","node_modules/cubing/src/cubing/twisty/controllers/RenderScheduler.ts","node_modules/cubing/src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts","node_modules/cubing/src/cubing/twisty/views/3D/TAU.ts","node_modules/cubing/src/cubing/twisty/views/node-custom-element-shims.ts","node_modules/cubing/src/cubing/twisty/views/ManagedCustomElement.ts","node_modules/cubing/src/cubing/vendor/mit/three/examples/jsm/libs/stats.modified.module.ts","node_modules/cubing/src/cubing/twisty/heavy-code-imports/3d.ts","node_modules/cubing/src/cubing/twisty/views/canvas.ts","node_modules/cubing/src/cubing/twisty/views/3D/Twisty3DVantage.css.ts","node_modules/cubing/src/cubing/twisty/views/3D/DragTracker.ts","node_modules/cubing/src/cubing/twisty/views/3D/RendererPool.ts","node_modules/cubing/src/cubing/twisty/views/3D/TwistyOrbitControls.ts","node_modules/cubing/src/cubing/twisty/views/3D/Twisty3DVantage.ts","node_modules/cubing/dist/esm/chunk-4F4IORIH.js","node_modules/cubing/src/cubing/puzzles/stickerings/mask.ts","node_modules/cubing/src/cubing/puzzles/stickerings/puzzle-stickerings.ts","node_modules/cubing/src/cubing/puzzles/stickerings/cube-like-stickerings.ts","node_modules/cubing/src/cubing/puzzles/async/lazy-cached.ts","node_modules/cubing/src/cubing/vendor/mit/p-lazy/p-lazy.ts","node_modules/cubing/src/cubing/puzzles/async/async-pg3d.ts","node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts","node_modules/cubing/src/cubing/puzzles/PuzzleLoader.ts","node_modules/cubing/src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts","node_modules/cubing/src/cubing/puzzles/customPGPuzzleLoader.ts","node_modules/cubing/src/cubing/puzzles/cubing-private/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts","node_modules/cubing/dist/esm/chunk-KLI2E737.js","node_modules/cubing/src/cubing/kpuzzle/combine.ts","node_modules/cubing/src/cubing/kpuzzle/construct.ts","node_modules/cubing/src/cubing/kpuzzle/KState.ts","node_modules/cubing/src/cubing/kpuzzle/KTransformation.ts","node_modules/cubing/src/cubing/kpuzzle/calculate.ts","node_modules/cubing/src/cubing/kpuzzle/KPuzzle.ts","node_modules/cubing/dist/esm/chunk-VZP3KFTU.js","node_modules/cubing/src/cubing/alg/common.ts","node_modules/cubing/src/cubing/alg/iteration.ts","node_modules/cubing/src/cubing/alg/limits.ts","node_modules/cubing/src/cubing/alg/AlgBuilder.ts","node_modules/cubing/src/cubing/alg/debug.ts","node_modules/cubing/src/cubing/alg/alg-nodes/containers/Commutator.ts","node_modules/cubing/src/cubing/alg/alg-nodes/containers/Conjugate.ts","node_modules/cubing/src/cubing/alg/alg-nodes/leaves/LineComment.ts","node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Newline.ts","node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Pause.ts","node_modules/cubing/src/cubing/alg/parseAlg.ts","node_modules/cubing/src/cubing/alg/warnOnce.ts","node_modules/cubing/src/cubing/alg/alg-nodes/QuantumWithAmount.ts","node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Move.ts","node_modules/cubing/src/cubing/alg/alg-nodes/containers/Grouping.ts","node_modules/cubing/src/cubing/alg/is.ts","node_modules/cubing/src/cubing/alg/traversal.ts","node_modules/cubing/src/cubing/alg/simplify/options.ts","node_modules/cubing/src/cubing/alg/simplify/append.ts","node_modules/cubing/src/cubing/alg/simplify/simplify.ts","node_modules/cubing/src/cubing/alg/Alg.ts","node_modules/cubing/src/cubing/alg/example.ts","node_modules/cubing/src/cubing/alg/keyboard.ts","node_modules/cubing/src/cubing/alg/url.ts","node_modules/@parcel/runtime-js/lib/runtime-b00f945a81c68652.js","node_modules/@parcel/runtime-js/lib/runtime-4bf2b7243f651c4d.js","node_modules/cubing/dist/esm/chunk-VJBQAZ63.js","node_modules/cubing/src/cubing/puzzles/events.ts","node_modules/cubing/src/cubing/puzzles/implementations/2x2x2/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/puzzle-specific-simplifications.ts","node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/clock/index.ts","node_modules/cubing/src/cubing/puzzles/stickerings/fto-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/fto/index.ts","node_modules/cubing/src/cubing/puzzles/stickerings/megaminx-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/megaminx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/pyraminx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/square1/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/kilominx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/redi-cube/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/4x4x4/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/melindas2x2x2x2/index.ts","node_modules/cubing/src/cubing/puzzles/index.ts","node_modules/@parcel/runtime-js/lib/runtime-6c19ae2ea0d6b23d.js","node_modules/@parcel/runtime-js/lib/runtime-4ef50d1eabbda03f.js","node_modules/@parcel/runtime-js/lib/runtime-a0888a22a578bc1c.js","node_modules/@parcel/runtime-js/lib/runtime-9ecf3ad668feec29.js","node_modules/@parcel/runtime-js/lib/runtime-b72e5290e28d25da.js"],"sourcesContent":["require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"1eRHv\\\":\\\"index.72ea0aa3.js\\\",\\\"eXwSi\\\":\\\"puzzle-geometry.6a169758.js\\\",\\\"98R2k\\\":\\\"twisty-dynamic-3d-FXC3LBQE.83a14b00.js\\\",\\\"7RujL\\\":\\\"puzzles-dynamic-side-events-D2VNVUXH.264352ee.js\\\",\\\"3INkf\\\":\\\"puzzles-dynamic-3x3x3-QN5DUJUA.05472cf6.js\\\",\\\"fxIkj\\\":\\\"puzzles-dynamic-unofficial-QXSDLTK5.839bc25f.js\\\",\\\"53f60\\\":\\\"puzzles-dynamic-megaminx-QPQBRZVY.2519ff42.js\\\",\\\"kbZbg\\\":\\\"puzzles-dynamic-4x4x4-DT42HVIY.5fc06a73.js\\\"}\"));","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import {\n  from\n} from \"./chunk-4F4IORIH.js\";\n\n// src/cubing/twisty/debug.ts\nvar twistyDebugGlobals = {\n  shareAllNewRenderers: \"auto\",\n  showRenderStats: false\n};\nfunction setTwistyDebug(options) {\n  for (const [key, value] of Object.entries(options)) {\n    if (key in twistyDebugGlobals) {\n      twistyDebugGlobals[key] = value;\n    }\n  }\n}\n\n// src/cubing/twisty/model/PromiseFreshener.ts\nvar StaleDropper = class {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n  queue(p) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++this.#latestAssignedIdx;\n        const result = await p;\n        if (idx > this.#latestResolvedIdx) {\n          this.#latestResolvedIdx = idx;\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n};\n\n// src/cubing/twisty/model/props/TwistyProp.ts\nvar globalSourceGeneration = 0;\nvar TwistyPropParent = class {\n  constructor() {\n    this.#children = /* @__PURE__ */ new Set();\n    this.lastSourceGeneration = 0;\n    this.#rawListeners = /* @__PURE__ */ new Set();\n    this.#rawDispatchPending = false;\n    this.#freshListeners = /* @__PURE__ */ new Map();\n  }\n  canReuse(v1, v2) {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n  canReuseValue(_v1, _v2) {\n    return false;\n  }\n  debugGetChildren() {\n    return Array.from(this.#children.values());\n  }\n  #children;\n  addChild(child) {\n    this.#children.add(child);\n  }\n  removeChild(child) {\n    this.#children.delete(child);\n  }\n  markStale(sourceEvent) {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of this.#children) {\n      child.markStale(sourceEvent);\n    }\n    this.#scheduleRawDispatch();\n  }\n  #rawListeners;\n  addRawListener(listener, options) {\n    this.#rawListeners.add(listener);\n    if (options?.initial) {\n      listener();\n    }\n  }\n  removeRawListener(listener) {\n    this.#rawListeners.delete(listener);\n  }\n  #scheduleRawDispatch() {\n    if (!this.#rawDispatchPending) {\n      this.#rawDispatchPending = true;\n      setTimeout(() => this.#dispatchRawListeners(), 0);\n    }\n  }\n  #rawDispatchPending;\n  #dispatchRawListeners() {\n    if (!this.#rawDispatchPending) {\n      throw new Error(\"Invalid dispatch state!\");\n    }\n    for (const listener of this.#rawListeners) {\n      listener();\n    }\n    this.#rawDispatchPending = false;\n  }\n  #freshListeners;\n  addFreshListener(listener) {\n    const staleDropper = new StaleDropper();\n    let lastResult = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    this.#freshListeners.set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n  removeFreshListener(listener) {\n    this.removeRawListener(this.#freshListeners.get(listener));\n    this.#freshListeners.delete(listener);\n  }\n};\nvar TwistyPropSource = class extends TwistyPropParent {\n  #value;\n  constructor(initialValue) {\n    super();\n    this.#value = from(() => this.getDefaultValue());\n    if (initialValue) {\n      this.#value = this.deriveFromPromiseOrValue(initialValue, this.#value);\n    }\n  }\n  set(input) {\n    this.#value = this.deriveFromPromiseOrValue(input, this.#value);\n    const sourceEventDetail = {\n      sourceProp: this,\n      value: this.#value,\n      generation: ++globalSourceGeneration\n    };\n    this.markStale(\n      new CustomEvent(\"stale\", {\n        detail: sourceEventDetail\n      })\n    );\n  }\n  async get() {\n    return this.#value;\n  }\n  async deriveFromPromiseOrValue(input, oldValuePromise) {\n    return this.derive(await input, oldValuePromise);\n  }\n};\nvar SimpleTwistyPropSource = class extends TwistyPropSource {\n  derive(input) {\n    return input;\n  }\n};\nvar NO_VALUE = Symbol(\"no value\");\nvar TwistyPropDerived = class extends TwistyPropParent {\n  constructor(parents, userVisibleErrorTracker) {\n    super();\n    this.userVisibleErrorTracker = userVisibleErrorTracker;\n    this.#parents = parents;\n    for (const parent of Object.values(parents)) {\n      parent.addChild(this);\n    }\n  }\n  #parents;\n  #cachedLastSuccessfulCalculation = null;\n  #cachedLatestGenerationCalculation = null;\n  async get() {\n    const generation = this.lastSourceGeneration;\n    if (this.#cachedLatestGenerationCalculation?.generation === generation) {\n      return this.#cachedLatestGenerationCalculation.output;\n    }\n    const latestGenerationCalculation = {\n      generation,\n      output: this.#cacheDerive(\n        this.#getParents(),\n        generation,\n        this.#cachedLastSuccessfulCalculation\n      )\n    };\n    this.#cachedLatestGenerationCalculation = latestGenerationCalculation;\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n  async #getParents() {\n    const inputValuePromises = {};\n    for (const [key, parent] of Object.entries(this.#parents)) {\n      inputValuePromises[key] = parent.get();\n    }\n    const inputs = {};\n    for (const key in this.#parents) {\n      inputs[key] = await inputValuePromises[key];\n    }\n    return inputs;\n  }\n  async #cacheDerive(inputsPromise, generation, cachedLatestGenerationCalculation = null) {\n    const inputs = await inputsPromise;\n    const cache = (output) => {\n      this.#cachedLastSuccessfulCalculation = {\n        inputs,\n        output: Promise.resolve(output),\n        generation\n      };\n      return output;\n    };\n    if (!cachedLatestGenerationCalculation) {\n      return cache(await this.derive(inputs));\n    }\n    const cachedInputs = cachedLatestGenerationCalculation.inputs;\n    for (const key in this.#parents) {\n      const parent = this.#parents[key];\n      if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n        return cache(await this.derive(inputs));\n      }\n    }\n    return cachedLatestGenerationCalculation.output;\n  }\n};\nvar FreshListenerManager = class {\n  #disconnectionFunctions = [];\n  addListener(prop, listener) {\n    let disconnected = false;\n    const wrappedListener = (value) => {\n      if (disconnected) {\n        return;\n      }\n      listener(value);\n    };\n    prop.addFreshListener(wrappedListener);\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n  addMultiListener3(props, listener) {\n    this.addMultiListener(props, listener);\n  }\n  addMultiListener(props, listener) {\n    let disconnected = false;\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        return;\n      }\n      const promises = props.map(\n        (prop) => prop.get()\n      );\n      const values = await Promise.all(promises);\n      listener(values);\n    };\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n    this.#disconnectionFunctions.push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n  disconnect() {\n    for (const disconnectionFunction of this.#disconnectionFunctions) {\n      disconnectionFunction();\n    }\n  }\n};\n\n// src/cubing/twisty/controllers/RenderScheduler.ts\nvar RenderScheduler = class {\n  constructor(callback) {\n    this.callback = callback;\n    this.animFrameID = null;\n    this.animFrame = this.animFrameWrapper.bind(this);\n  }\n  requestIsPending() {\n    return !!this.animFrameID;\n  }\n  requestAnimFrame() {\n    if (!this.animFrameID) {\n      this.animFrameID = requestAnimationFrame(this.animFrame);\n    }\n  }\n  cancelAnimFrame() {\n    if (this.animFrameID) {\n      cancelAnimationFrame(this.animFrameID);\n      this.animFrameID = 0;\n    }\n  }\n  animFrameWrapper(timestamp) {\n    this.animFrameID = 0;\n    this.callback(timestamp);\n  }\n};\n\n// src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts\nvar hintFaceletStyles = {\n  floating: true,\n  none: true\n};\nvar HintFaceletProp = class extends SimpleTwistyPropSource {\n  getDefaultValue() {\n    return \"auto\";\n  }\n};\n\n// src/cubing/twisty/views/3D/TAU.ts\nvar TAU = Math.PI * 2;\nvar DEGREES_PER_RADIAN = 360 / TAU;\n\n// src/cubing/twisty/views/node-custom-element-shims.ts\nvar HTMLElementStub = class {\n};\nvar HTMLElementShim;\nif (globalThis.HTMLElement) {\n  HTMLElementShim = HTMLElement;\n} else {\n  HTMLElementShim = HTMLElementStub;\n}\nvar CustomElementsStub = class {\n  define() {\n  }\n};\nvar customElementsShim;\nif (globalThis.customElements) {\n  customElementsShim = customElements;\n} else {\n  customElementsShim = new CustomElementsStub();\n}\n\n// src/cubing/twisty/views/ManagedCustomElement.ts\nvar CSSSource = class {\n  constructor(sourceText) {\n    this.sourceText = sourceText;\n  }\n  getAsString() {\n    return this.sourceText;\n  }\n};\nvar ManagedCustomElement = class extends HTMLElementShim {\n  constructor(options) {\n    super();\n    this.#cssSourceMap = /* @__PURE__ */ new Map();\n    this.shadow = this.attachShadow({ mode: options?.mode ?? \"closed\" });\n    this.contentWrapper = document.createElement(\"div\");\n    this.contentWrapper.classList.add(\"wrapper\");\n    this.shadow.appendChild(this.contentWrapper);\n  }\n  #cssSourceMap;\n  addCSS(cssSource) {\n    const existing = this.#cssSourceMap.get(cssSource);\n    if (existing) {\n      return existing;\n    }\n    const cssElem = document.createElement(\"style\");\n    cssElem.textContent = cssSource.getAsString();\n    this.#cssSourceMap.set(cssSource, cssElem);\n    this.shadow.appendChild(cssElem);\n    return cssElem;\n  }\n  removeCSS(cssSource) {\n    const cssElem = this.#cssSourceMap.get(cssSource);\n    if (!cssElem) {\n      return;\n    }\n    this.shadow.removeChild(cssElem);\n    this.#cssSourceMap.delete(cssSource);\n  }\n  addElement(element) {\n    return this.contentWrapper.appendChild(element);\n  }\n  prependElement(element) {\n    this.contentWrapper.prepend(element);\n  }\n  removeElement(element) {\n    return this.contentWrapper.removeChild(element);\n  }\n};\ncustomElementsShim.define(\n  \"twisty-managed-custom-element\",\n  ManagedCustomElement\n);\n\n// src/cubing/vendor/mit/three/examples/jsm/libs/stats.modified.module.ts\nvar performance = globalThis.performance;\nvar Stats = class {\n  constructor() {\n    this.mode = 0;\n    this.dom = document.createElement(\"div\");\n    this.beginTime = (performance || Date).now();\n    this.prevTime = this.beginTime;\n    this.frames = 0;\n    this.fpsPanel = this.addPanel(new StatsPanel(\"FPS\", \"#0ff\", \"#002\"));\n    this.msPanel = this.addPanel(new StatsPanel(\"MS\", \"#0f0\", \"#020\"));\n    this.memPanel = performance?.memory ? this.addPanel(new StatsPanel(\"MB\", \"#f08\", \"#201\")) : null;\n    this.REVISION = 16;\n    this.dom.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n    this.dom.addEventListener(\n      \"click\",\n      (event) => {\n        event.preventDefault();\n        this.showPanel(++this.mode % this.dom.children.length);\n      },\n      false\n    );\n    this.showPanel(0);\n  }\n  addPanel(panel) {\n    this.dom.appendChild(panel.dom);\n    return panel;\n  }\n  showPanel(id) {\n    for (let i = 0; i < this.dom.children.length; i++) {\n      this.dom.children[i].style.display = i === id ? \"block\" : \"none\";\n    }\n    this.mode = id;\n  }\n  begin() {\n    this.beginTime = (performance || Date).now();\n  }\n  end() {\n    this.frames++;\n    const time = (performance || Date).now();\n    this.msPanel.update(time - this.beginTime, 200);\n    if (time >= this.prevTime + 1e3) {\n      this.fpsPanel.update(this.frames * 1e3 / (time - this.prevTime), 100);\n      this.prevTime = time;\n      this.frames = 0;\n      if (this.memPanel) {\n        const memory = performance.memory;\n        this.memPanel.update(\n          memory.usedJSHeapSize / 1048576,\n          memory.jsHeapSizeLimit / 1048576\n        );\n      }\n    }\n    return time;\n  }\n  update() {\n    this.beginTime = this.end();\n  }\n};\nvar PR = Math.round(globalThis?.window?.devicePixelRatio ?? 1);\nvar WIDTH = 80 * PR;\nvar HEIGHT = 48 * PR;\nvar TEXT_X = 3 * PR;\nvar TEXT_Y = 2 * PR;\nvar GRAPH_X = 3 * PR;\nvar GRAPH_Y = 15 * PR;\nvar GRAPH_WIDTH = 74 * PR;\nvar GRAPH_HEIGHT = 30 * PR;\nvar StatsPanel = class {\n  constructor(name, fg, bg) {\n    this.name = name;\n    this.fg = fg;\n    this.bg = bg;\n    this.min = Infinity;\n    this.max = 0;\n    this.dom = document.createElement(\"canvas\");\n    this.context = this.dom.getContext(\"2d\");\n    this.dom.width = WIDTH;\n    this.dom.height = HEIGHT;\n    this.dom.style.cssText = \"width:80px;height:48px\";\n    this.context.font = `bold ${9 * PR}px Helvetica,Arial,sans-serif`;\n    this.context.textBaseline = \"top\";\n    this.context.fillStyle = bg;\n    this.context.fillRect(0, 0, WIDTH, HEIGHT);\n    this.context.fillStyle = fg;\n    this.context.fillText(name, TEXT_X, TEXT_Y);\n    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    this.context.fillStyle = bg;\n    this.context.globalAlpha = 0.9;\n    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n  }\n  update(value, maxValue) {\n    this.min = Math.min(this.min, value);\n    this.max = Math.max(this.max, value);\n    this.context.fillStyle = this.bg;\n    this.context.globalAlpha = 1;\n    this.context.fillRect(0, 0, WIDTH, GRAPH_Y);\n    this.context.fillStyle = this.fg;\n    this.context.fillText(\n      `${Math.round(value)} ${this.name} (${Math.round(this.min)}-${Math.round(\n        this.max\n      )})`,\n      TEXT_X,\n      TEXT_Y\n    );\n    this.context.drawImage(\n      this.dom,\n      GRAPH_X + PR,\n      GRAPH_Y,\n      GRAPH_WIDTH - PR,\n      GRAPH_HEIGHT,\n      GRAPH_X,\n      GRAPH_Y,\n      GRAPH_WIDTH - PR,\n      GRAPH_HEIGHT\n    );\n    this.context.fillRect(\n      GRAPH_X + GRAPH_WIDTH - PR,\n      GRAPH_Y,\n      PR,\n      GRAPH_HEIGHT\n    );\n    this.context.fillStyle = this.bg;\n    this.context.globalAlpha = 0.9;\n    this.context.fillRect(\n      GRAPH_X + GRAPH_WIDTH - PR,\n      GRAPH_Y,\n      PR,\n      Math.round((1 - value / maxValue) * GRAPH_HEIGHT)\n    );\n  }\n};\n\n// src/cubing/twisty/heavy-code-imports/3d.ts\nvar cachedConstructorProxy = null;\nasync function proxy3D() {\n  return cachedConstructorProxy ?? (cachedConstructorProxy = import(\"./twisty-dynamic-3d-FXC3LBQE.js\"));\n}\nvar THREEJS = from(\n  async () => (await proxy3D()).T3I\n);\n\n// src/cubing/twisty/views/canvas.ts\nvar globalPixelRatioOverride = null;\nfunction pixelRatio() {\n  return globalPixelRatioOverride ?? (devicePixelRatio || 1);\n}\n\n// src/cubing/twisty/views/3D/Twisty3DVantage.css.ts\nvar twisty3DVantageCSS = new CSSSource(\n  `\n:host {\n  width: 384px;\n  height: 256px;\n  display: grid;\n}\n\n.wrapper {\n  width: 100%;\n  height: 100%;\n  display: grid;\n  overflow: hidden;\n  place-content: center;\n  contain: strict;\n}\n\n.loading {\n  width: 4em;\n  height: 4em;\n  border-radius: 2.5em;\n  border: 0.5em solid rgba(0, 0, 0, 0);\n  border-top: 0.5em solid rgba(0, 0, 0, 0.7);\n  border-right: 0.5em solid rgba(0, 0, 0, 0.7);\n  animation: fade-in-delayed 4s, rotate 1s linear infinite;\n}\n\n@keyframes fade-in-delayed {\n  0% { opacity: 0; }\n  25% {opacity: 0; }\n  100% { opacity: 1; }\n}\n\n@keyframes rotate {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n/* TODO: This is due to stats hack. Replace with \\`canvas\\`. */\n.wrapper > canvas {\n  max-width: 100%;\n  max-height: 100%;\n  animation: fade-in 0.25s ease-in;\n}\n\n@keyframes fade-in {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n.wrapper.invisible {\n  opacity: 0;\n}\n\n.wrapper.drag-input-enabled > canvas {\n  cursor: grab;\n}\n\n.wrapper.drag-input-enabled > canvas:active {\n  cursor: grabbing;\n}\n`\n);\n\n// src/cubing/twisty/views/3D/DragTracker.ts\nvar MOVEMENT_EPSILON = 0.1;\nvar DragTracker = class extends EventTarget {\n  constructor(target) {\n    super();\n    this.target = target;\n  }\n  #dragInfoMap = /* @__PURE__ */ new Map();\n  start() {\n    this.addTargetListener(\"pointerdown\", this.onPointerDown.bind(this));\n    this.addTargetListener(\"contextmenu\", (e) => {\n      e.preventDefault();\n    });\n    this.addTargetListener(\"touchmove\", (e) => e.preventDefault());\n    this.addTargetListener(\"dblclick\", (e) => e.preventDefault());\n  }\n  stop() {\n    for (const [eventType, listener] of this.#targetListeners.entries()) {\n      this.target.removeEventListener(eventType, listener);\n    }\n    this.#targetListeners.clear();\n    this.#lazyListenersRegistered = false;\n  }\n  #targetListeners = /* @__PURE__ */ new Map();\n  addTargetListener(eventType, listener) {\n    if (!this.#targetListeners.has(eventType)) {\n      this.target.addEventListener(eventType, listener);\n      this.#targetListeners.set(eventType, listener);\n    }\n  }\n  #lazyListenersRegistered = false;\n  #registerLazyListeners() {\n    if (this.#lazyListenersRegistered) {\n      return;\n    }\n    this.addTargetListener(\"pointermove\", this.onPointerMove.bind(this));\n    this.addTargetListener(\"pointerup\", this.onPointerUp.bind(this));\n    this.#lazyListenersRegistered = true;\n  }\n  #clear(e) {\n    this.#dragInfoMap.delete(e.pointerId);\n  }\n  #trackDrag(e) {\n    const existing = this.#dragInfoMap.get(e.pointerId);\n    if (!existing) {\n      return { movementInfo: null, hasMoved: false };\n    }\n    let movementInfo;\n    if ((e.movementX ?? 0) !== 0 || (e.movementY ?? 0) !== 0) {\n      movementInfo = {\n        attachedInfo: existing.attachedInfo,\n        movementX: e.movementX,\n        movementY: e.movementY,\n        elapsedMs: e.timeStamp - existing.lastTimeStamp\n      };\n    } else {\n      movementInfo = {\n        attachedInfo: existing.attachedInfo,\n        movementX: e.clientX - existing.lastClientX,\n        movementY: e.clientY - existing.lastClientY,\n        elapsedMs: e.timeStamp - existing.lastTimeStamp\n      };\n    }\n    existing.lastClientX = e.clientX;\n    existing.lastClientY = e.clientY;\n    existing.lastTimeStamp = e.timeStamp;\n    if (Math.abs(movementInfo.movementX) < MOVEMENT_EPSILON && Math.abs(movementInfo.movementY) < MOVEMENT_EPSILON) {\n      return { movementInfo: null, hasMoved: existing.hasMoved };\n    } else {\n      existing.hasMoved = true;\n      return { movementInfo, hasMoved: existing.hasMoved };\n    }\n  }\n  onPointerDown(e) {\n    this.#registerLazyListeners();\n    const newDragInfo = {\n      attachedInfo: {},\n      hasMoved: false,\n      lastClientX: e.clientX,\n      lastClientY: e.clientY,\n      lastTimeStamp: e.timeStamp\n    };\n    this.#dragInfoMap.set(e.pointerId, newDragInfo);\n    this.target.setPointerCapture(e.pointerId);\n  }\n  onPointerMove(e) {\n    const movementInfo = this.#trackDrag(e).movementInfo;\n    if (movementInfo) {\n      e.preventDefault();\n      this.dispatchEvent(\n        new CustomEvent(\"move\", {\n          detail: movementInfo\n        })\n      );\n    }\n  }\n  onPointerUp(e) {\n    const trackDragResult = this.#trackDrag(e);\n    const existing = this.#dragInfoMap.get(e.pointerId);\n    this.#clear(e);\n    this.target.releasePointerCapture(e.pointerId);\n    let event;\n    if (trackDragResult.hasMoved) {\n      event = new CustomEvent(\"up\", {\n        detail: { attachedInfo: existing.attachedInfo }\n      });\n    } else {\n      const { altKey, ctrlKey, metaKey, shiftKey } = e;\n      event = new CustomEvent(\"press\", {\n        detail: {\n          normalizedX: e.offsetX / this.target.offsetWidth * 2 - 1,\n          normalizedY: 1 - e.offsetY / this.target.offsetHeight * 2,\n          rightClick: !!(e.button & 2),\n          keys: {\n            altKey,\n            ctrlOrMetaKey: ctrlKey || metaKey,\n            shiftKey\n          }\n        }\n      });\n    }\n    this.dispatchEvent(event);\n  }\n};\n\n// src/cubing/twisty/views/3D/RendererPool.ts\nvar renderers = [];\nasync function rawRenderPooled(width, height, scene, camera) {\n  if (renderers.length === 0) {\n    renderers.push(newRenderer());\n  }\n  const renderer = await renderers[0];\n  renderer.setSize(width, height);\n  renderer.render(scene, camera);\n  return renderer.domElement;\n}\nasync function renderPooled(width, height, canvas, scene, camera) {\n  if (width === 0 || height === 0) {\n    return;\n  }\n  if (renderers.length === 0) {\n    renderers.push(newRenderer());\n  }\n  const rendererCanvas = await rawRenderPooled(width, height, scene, camera);\n  const context = canvas.getContext(\"2d\");\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.drawImage(rendererCanvas, 0, 0);\n}\nasync function newRenderer() {\n  const rendererConstructor = (await THREEJS).WebGLRenderer;\n  const renderer = new rendererConstructor({\n    antialias: true,\n    alpha: true\n  });\n  renderer.setPixelRatio(pixelRatio());\n  return renderer;\n}\n\n// src/cubing/twisty/views/3D/TwistyOrbitControls.ts\nvar INERTIA_DEFAULT = true;\nvar INERTIA_DURATION_MS = 500;\nvar INERTIA_TIMEOUT_MS = 50;\nvar VERTICAL_MOVEMENT_BASE_SCALE = 0.75;\nfunction momentumScale(progress) {\n  return (Math.exp(1 - progress) - (1 - progress)) / (1 - Math.E) + 1;\n}\nvar Inertia = class {\n  constructor(startTimestamp, momentumX, momentumY, callback) {\n    this.startTimestamp = startTimestamp;\n    this.momentumX = momentumX;\n    this.momentumY = momentumY;\n    this.callback = callback;\n    this.scheduler = new RenderScheduler(this.render.bind(this));\n    this.scheduler.requestAnimFrame();\n    this.lastTimestamp = startTimestamp;\n  }\n  render(now) {\n    const progressBefore = (this.lastTimestamp - this.startTimestamp) / INERTIA_DURATION_MS;\n    const progressAfter = Math.min(\n      1,\n      (now - this.startTimestamp) / INERTIA_DURATION_MS\n    );\n    if (progressBefore === 0 && progressAfter > INERTIA_TIMEOUT_MS / INERTIA_DURATION_MS) {\n      return;\n    }\n    const delta = momentumScale(progressAfter) - momentumScale(progressBefore);\n    this.callback(this.momentumX * delta * 1e3, this.momentumY * delta * 1e3);\n    if (progressAfter < 1) {\n      this.scheduler.requestAnimFrame();\n    }\n    this.lastTimestamp = now;\n  }\n};\nvar TwistyOrbitControls = class {\n  constructor(model, mirror, canvas, dragTracker) {\n    this.model = model;\n    this.mirror = mirror;\n    this.canvas = canvas;\n    this.dragTracker = dragTracker;\n    this.experimentalInertia = INERTIA_DEFAULT;\n    this.onMovementBound = this.onMovement.bind(this);\n    this.experimentalHasBeenMoved = false;\n    this.dragTracker.addEventListener(\"move\", this.onMove.bind(this));\n    this.dragTracker.addEventListener(\"up\", this.onUp.bind(this));\n  }\n  temperMovement(f) {\n    return Math.sign(f) * Math.log(Math.abs(f * 10) + 1) / 6;\n  }\n  onMove(e) {\n    var _a;\n    (_a = e.detail).attachedInfo ?? (_a.attachedInfo = {});\n    const { temperedX, temperedY } = this.onMovement(\n      e.detail.movementX,\n      e.detail.movementY\n    );\n    const attachedInfo = e.detail.attachedInfo;\n    attachedInfo.lastTemperedX = temperedX * 10;\n    attachedInfo.lastTemperedY = temperedY * 10;\n    attachedInfo.timestamp = e.timeStamp;\n  }\n  onMovement(movementX, movementY) {\n    const scale = this.mirror ? -1 : 1;\n    const minDim = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight);\n    const temperedX = this.temperMovement(movementX / minDim);\n    const temperedY = this.temperMovement(\n      movementY / minDim * VERTICAL_MOVEMENT_BASE_SCALE\n    );\n    this.model.twistySceneModel.orbitCoordinatesRequest.set(\n      (async () => {\n        const prevCoords = await this.model.twistySceneModel.orbitCoordinates.get();\n        const newCoords = {\n          latitude: prevCoords.latitude + 2 * temperedY * DEGREES_PER_RADIAN * scale,\n          longitude: prevCoords.longitude - 2 * temperedX * DEGREES_PER_RADIAN\n        };\n        return newCoords;\n      })()\n    );\n    return { temperedX, temperedY };\n  }\n  onUp(e) {\n    e.preventDefault();\n    if (\"lastTemperedX\" in e.detail.attachedInfo && \"lastTemperedY\" in e.detail.attachedInfo && \"timestamp\" in e.detail.attachedInfo && e.timeStamp - e.detail.attachedInfo.timestamp < 60) {\n      new Inertia(\n        e.timeStamp,\n        e.detail.attachedInfo.lastTemperedX,\n        e.detail.attachedInfo.lastTemperedY,\n        this.onMovementBound\n      );\n    }\n  }\n};\n\n// src/cubing/twisty/views/3D/Twisty3DVantage.ts\nasync function setCameraFromOrbitCoordinates(camera, orbitCoordinates, backView = false) {\n  const spherical = new (await THREEJS).Spherical(\n    orbitCoordinates.distance,\n    (90 - (backView ? -1 : 1) * orbitCoordinates.latitude) / DEGREES_PER_RADIAN,\n    ((backView ? 180 : 0) + orbitCoordinates.longitude) / DEGREES_PER_RADIAN\n  );\n  spherical.makeSafe();\n  camera.position.setFromSpherical(spherical);\n  camera.lookAt(0, 0, 0);\n}\nvar dedicatedRenderersSoFar = 0;\nvar DEFAULT_MAX_DEDICATED_RENDERERS = 2;\nvar sharingRenderers = false;\nfunction shareRenderer() {\n  if (twistyDebugGlobals.shareAllNewRenderers !== \"auto\") {\n    if (!twistyDebugGlobals.shareAllNewRenderers) {\n      dedicatedRenderersSoFar++;\n    }\n    return twistyDebugGlobals.shareAllNewRenderers !== \"never\";\n  }\n  if (dedicatedRenderersSoFar < DEFAULT_MAX_DEDICATED_RENDERERS) {\n    dedicatedRenderersSoFar++;\n    return false;\n  } else {\n    sharingRenderers = true;\n    return true;\n  }\n}\nfunction haveStartedSharingRenderers() {\n  return sharingRenderers;\n}\nvar Twisty3DVantage = class extends ManagedCustomElement {\n  constructor(model, scene, options) {\n    super();\n    this.model = model;\n    this.options = options;\n    this.scene = null;\n    this.stats = null;\n    this.rendererIsShared = shareRenderer();\n    this.loadingElement = null;\n    this.#onResizeStaleDropper = new StaleDropper();\n    this.#width = 0;\n    this.#height = 0;\n    this.#cachedRenderer = null;\n    this.#cachedCanvas = null;\n    this.#cachedDragTracker = null;\n    this.#cachedCamera = null;\n    this.#cachedOrbitControls = null;\n    this.#disconnectionFunctions = [];\n    this.#experimentalNextRenderFinishedCallback = null;\n    this.#scheduler = new RenderScheduler(this.render.bind(this));\n    this.scene = scene ?? null;\n    this.loadingElement = this.addElement(document.createElement(\"div\"));\n    this.loadingElement.classList.add(\"loading\");\n    if (twistyDebugGlobals.showRenderStats) {\n      this.stats = new Stats();\n      this.stats.dom.style.position = \"absolute\";\n      this.contentWrapper.appendChild(this.stats.dom);\n    }\n  }\n  async connectedCallback() {\n    this.addCSS(twisty3DVantageCSS);\n    this.addElement((await this.canvasInfo()).canvas);\n    this.#onResize();\n    const observer = new ResizeObserver(this.#onResize.bind(this));\n    observer.observe(this.contentWrapper);\n    this.orbitControls();\n    this.#setupBasicPresses();\n    this.scheduleRender();\n  }\n  async #setupBasicPresses() {\n    const dragTracker = await this.#dragTracker();\n    dragTracker.addEventListener(\"press\", async (e) => {\n      const movePressInput = await this.model.twistySceneModel.movePressInput.get();\n      if (movePressInput !== \"basic\") {\n        return;\n      }\n      this.dispatchEvent(\n        new CustomEvent(\"press\", {\n          detail: {\n            pressInfo: e.detail,\n            cameraPromise: this.camera()\n          }\n        })\n      );\n    });\n  }\n  #onResizeStaleDropper;\n  async clearCanvas() {\n    if (this.rendererIsShared) {\n      const canvasInfo = await this.canvasInfo();\n      canvasInfo.context.clearRect(\n        0,\n        0,\n        canvasInfo.canvas.width,\n        canvasInfo.canvas.height\n      );\n    } else {\n      const renderer = await this.renderer();\n      const context = renderer.getContext();\n      context.clear(context.COLOR_BUFFER_BIT);\n    }\n  }\n  #width;\n  #height;\n  async #onResize() {\n    const camera = await this.#onResizeStaleDropper.queue(this.camera());\n    const w = this.contentWrapper.clientWidth;\n    const h = this.contentWrapper.clientHeight;\n    this.#width = w;\n    this.#height = h;\n    const off = 0;\n    let yoff = 0;\n    let excess = 0;\n    if (h > w) {\n      excess = h - w;\n      yoff = -Math.floor(0.5 * excess);\n    }\n    camera.aspect = w / h;\n    camera.setViewOffset(w, h - excess, off, yoff, w, h);\n    camera.updateProjectionMatrix();\n    this.clearCanvas();\n    if (this.rendererIsShared) {\n      const canvasInfo = await this.canvasInfo();\n      canvasInfo.canvas.width = w * pixelRatio();\n      canvasInfo.canvas.height = h * pixelRatio();\n      canvasInfo.canvas.style.width = `${w.toString()}px`;\n      canvasInfo.canvas.style.height = `${h.toString()}px`;\n    } else {\n      const renderer = await this.renderer();\n      renderer.setSize(w, h, true);\n    }\n    this.scheduleRender();\n  }\n  #cachedRenderer;\n  async renderer() {\n    if (this.rendererIsShared) {\n      throw new Error(\"renderer expected to be shared.\");\n    }\n    return this.#cachedRenderer ?? (this.#cachedRenderer = newRenderer());\n  }\n  #cachedCanvas;\n  async canvasInfo() {\n    return this.#cachedCanvas ?? (this.#cachedCanvas = (async () => {\n      let canvas;\n      if (this.rendererIsShared) {\n        canvas = this.addElement(document.createElement(\"canvas\"));\n      } else {\n        const renderer = await this.renderer();\n        canvas = this.addElement(renderer.domElement);\n      }\n      this.loadingElement?.remove();\n      const context = canvas.getContext(\"2d\");\n      return { canvas, context };\n    })());\n  }\n  #cachedDragTracker;\n  async #dragTracker() {\n    return this.#cachedDragTracker ?? (this.#cachedDragTracker = (async () => {\n      const dragTracker = new DragTracker((await this.canvasInfo()).canvas);\n      this.model?.twistySceneModel.dragInput.addFreshListener(\n        (dragInputMode) => {\n          let dragInputEnabled = false;\n          switch (dragInputMode) {\n            case \"auto\": {\n              dragTracker.start();\n              dragInputEnabled = true;\n              break;\n            }\n            case \"none\": {\n              dragTracker.stop();\n              break;\n            }\n          }\n          this.contentWrapper.classList.toggle(\n            \"drag-input-enabled\",\n            dragInputEnabled\n          );\n        }\n      );\n      return dragTracker;\n    })());\n  }\n  #cachedCamera;\n  async camera() {\n    return this.#cachedCamera ?? (this.#cachedCamera = (async () => {\n      const camera = new (await THREEJS).PerspectiveCamera(\n        20,\n        1,\n        0.1,\n        20\n      );\n      camera.position.copy(\n        new (await THREEJS).Vector3(2, 4, 4).multiplyScalar(\n          this.options?.backView ? -1 : 1\n        )\n      );\n      camera.lookAt(0, 0, 0);\n      return camera;\n    })());\n  }\n  #cachedOrbitControls;\n  async orbitControls() {\n    return this.#cachedOrbitControls ?? (this.#cachedOrbitControls = (async () => {\n      const orbitControls = new TwistyOrbitControls(\n        this.model,\n        !!this.options?.backView,\n        (await this.canvasInfo()).canvas,\n        await this.#dragTracker()\n      );\n      if (this.model) {\n        this.addListener(\n          this.model.twistySceneModel.orbitCoordinates,\n          async (orbitCoordinates) => {\n            const camera = await this.camera();\n            setCameraFromOrbitCoordinates(\n              camera,\n              orbitCoordinates,\n              this.options?.backView\n            );\n            this.scheduleRender();\n          }\n        );\n      }\n      return orbitControls;\n    })());\n  }\n  addListener(prop, listener) {\n    prop.addFreshListener(listener);\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(listener);\n    });\n  }\n  #disconnectionFunctions;\n  disconnect() {\n    for (const fn of this.#disconnectionFunctions) {\n      fn();\n    }\n    this.#disconnectionFunctions = [];\n  }\n  #experimentalNextRenderFinishedCallback;\n  experimentalNextRenderFinishedCallback(callback) {\n    this.#experimentalNextRenderFinishedCallback = callback;\n  }\n  async render() {\n    if (!this.scene) {\n      throw new Error(\"Attempted to render without a scene\");\n    }\n    this.stats?.begin();\n    const [scene, camera, canvas] = await Promise.all([\n      this.scene.scene(),\n      this.camera(),\n      this.canvasInfo()\n    ]);\n    if (this.rendererIsShared) {\n      renderPooled(this.#width, this.#height, canvas.canvas, scene, camera);\n    } else {\n      (await this.renderer()).render(scene, camera);\n    }\n    this.stats?.end();\n    this.#experimentalNextRenderFinishedCallback?.();\n    this.#experimentalNextRenderFinishedCallback = null;\n  }\n  #scheduler;\n  scheduleRender() {\n    this.#scheduler.requestAnimFrame();\n  }\n};\ncustomElementsShim.define(\"twisty-3d-vantage\", Twisty3DVantage);\n\nexport {\n  setTwistyDebug,\n  RenderScheduler,\n  StaleDropper,\n  TwistyPropSource,\n  SimpleTwistyPropSource,\n  NO_VALUE,\n  TwistyPropDerived,\n  FreshListenerManager,\n  hintFaceletStyles,\n  HintFaceletProp,\n  TAU,\n  DEGREES_PER_RADIAN,\n  HTMLElementShim,\n  customElementsShim,\n  CSSSource,\n  ManagedCustomElement,\n  rawRenderPooled,\n  setCameraFromOrbitCoordinates,\n  haveStartedSharingRenderers,\n  Twisty3DVantage,\n  proxy3D,\n  THREEJS\n};\n//# sourceMappingURL=chunk-OFSJREI7.js.map\n","export const twistyDebugGlobals: {\n  // WARNING: The current shared renderer implementation has performance issues, especially in Safari.\n  // Avoid using for players that are likely to have dimensions approaching 1 megapixel or higher.\n  // TODO: use a dedicated renderer while fullscreen?\n  // - \"auto\": Default heuristics.\n  // - \"always\": Force all new (i.e. constructed in the future) renderers to be shared\n  // - \"never\": Force all new (i.e. constructed in the future) renderers to be dedicated\n  shareAllNewRenderers: \"auto\" | \"always\" | \"never\";\n  showRenderStats: boolean;\n} = {\n  shareAllNewRenderers: \"auto\",\n  showRenderStats: false,\n};\n\nexport function setTwistyDebug(\n  options: Partial<typeof twistyDebugGlobals>,\n): void {\n  for (const [key, value] of Object.entries(options)) {\n    if (key in twistyDebugGlobals) {\n      (twistyDebugGlobals as any)[key] = value;\n    }\n  }\n}\n","// TODO: Pick a much better name.\nexport class PromiseFreshener<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  // TODO: reject instead? Drop?\n  async queue(\n    p: Promise<T>,\n  ): Promise<{ fresh: false } | { fresh: true; result: T }> {\n    const idx = ++this.#latestAssignedIdx;\n    const result = await p;\n    if (idx > this.#latestResolvedIdx) {\n      this.#latestResolvedIdx = idx;\n      return {\n        fresh: true,\n        result: result,\n      };\n    } else {\n      return { fresh: false };\n    }\n  }\n}\n\n// This will silenty drop a queued Promise (i.e. not resolve it) if a\n// newer queued one already resolved first. This is useful for classes that want\n// to know the \"latest\" state of something without jumping back to an older\n// value by accident.\n// TODO: Remove this because it's too easy to misuse?\nexport class StaleDropper<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  queue(p: Promise<T>): Promise<T> {\n    // rome-ignore lint/suspicious/noAsyncPromiseExecutor: This is a very rare case where we *do* want to drop a Promise sometimes.\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++this.#latestAssignedIdx;\n        const result = await p;\n        if (idx > this.#latestResolvedIdx) {\n          this.#latestResolvedIdx = idx;\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n}\n","import { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\nimport { StaleDropper } from \"../PromiseFreshener\";\nimport type { UserVisibleErrorTracker } from \"../UserVisibleErrorTracker\";\n\n// rome-ignore lint/nursery/noBannedTypes: TODO: can we use `satisfies` below instead of using this?\ntype InputRecord = {};\n\nexport type InputProps<T extends InputRecord> = {\n  [s in keyof T]: TwistyPropParent<T[s]>;\n};\n\ntype InputPromises<T extends InputRecord> = {\n  [s in keyof T]: Promise<T[s]>;\n};\n\ninterface SourceEventDetail<OutputType> {\n  sourceProp: TwistyPropSource<OutputType, any>;\n  value: Promise<OutputType>; // TODO: remove?\n  generation: number;\n}\n\ntype SourceEvent<T> = CustomEvent<SourceEventDetail<T>>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\n// Values of T must be immutable.\nlet globalSourceGeneration = 0; // This is incremented before being used, so 1 will be the first active value.\nexport abstract class TwistyPropParent<T> {\n  public abstract get(): Promise<T>;\n\n  // Don't overwrite this. Overwrite `canReuseValue` instead.\n  public canReuse(v1: T, v2: T): boolean {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n\n  // Overwrite with a cheap semantic comparison when possible.\n  // Note that this is not called if `v1 === v2` (in which case the value is automatically reused).\n  protected canReuseValue(_v1: T, _v2: T): boolean {\n    return false;\n  }\n\n  debugGetChildren(): TwistyPropDerived<any, any>[] {\n    return Array.from(this.#children.values());\n  }\n\n  // Propagation\n\n  #children: Set<TwistyPropDerived<any, any>> = new Set();\n  protected addChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.add(child);\n  }\n\n  protected removeChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.delete(child);\n  }\n\n  protected lastSourceGeneration: number = 0;\n  // Synchronously marks all descendants as stale. This doesn't actually\n  // literally mark as stale, but it updates the last source generation, which\n  // is used to tell if a cahced result is stale.\n  protected markStale(sourceEvent: SourceEvent<any>): void {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      // The full stale propagation is synchronous, so there should not be a new one yet.\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      // Already propagated.\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of this.#children) {\n      child.markStale(sourceEvent);\n    }\n    // We schedule sending out events *after* the (synchronous) propagation has happened, in\n    // case one of the listeners updates a source again.\n    this.#scheduleRawDispatch();\n  }\n\n  #rawListeners: Set<() => void> = new Set();\n  /** @deprecated */\n  addRawListener(listener: () => void, options?: { initial: boolean }): void {\n    this.#rawListeners.add(listener);\n    if (options?.initial) {\n      listener(); // TODO: wrap in a try?\n    }\n  }\n\n  /** @deprecated */\n  removeRawListener(listener: () => void): void {\n    this.#rawListeners.delete(listener);\n  }\n\n  /** @deprecated */\n  #scheduleRawDispatch(): void {\n    if (!this.#rawDispatchPending) {\n      this.#rawDispatchPending = true;\n      setTimeout(() => this.#dispatchRawListeners(), 0);\n    }\n  }\n\n  #rawDispatchPending: boolean = false;\n  #dispatchRawListeners(): void {\n    if (!this.#rawDispatchPending) {\n      throw new Error(\"Invalid dispatch state!\");\n    }\n    for (const listener of this.#rawListeners) {\n      listener(); // TODO: wrap in a try?\n    }\n    this.#rawDispatchPending = false;\n  }\n\n  #freshListeners: Map<(value: T) => void, () => void> = new Map();\n  // TODO: Pick a better name.\n  public addFreshListener(listener: (value: T) => void): void {\n    const staleDropper: StaleDropper<T> = new StaleDropper<T>();\n    let lastResult: T | null = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    this.#freshListeners.set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n\n  public removeFreshListener(listener: (value: T) => void): void {\n    this.removeRawListener(this.#freshListeners.get(listener)!); // TODO: throw a custom error?\n    this.#freshListeners.delete(listener);\n  }\n}\n\nexport abstract class TwistyPropSource<\n  OutputType,\n  InputType = OutputType,\n> extends TwistyPropParent<OutputType> {\n  #value: Promise<OutputType>;\n\n  public abstract getDefaultValue(): PromiseOrValue<OutputType>;\n\n  constructor(initialValue?: PromiseOrValue<InputType>) {\n    super();\n    this.#value = from(() => this.getDefaultValue());\n    if (initialValue) {\n      this.#value = this.deriveFromPromiseOrValue(initialValue, this.#value);\n    }\n  }\n\n  set(input: PromiseOrValue<InputType>): void {\n    this.#value = this.deriveFromPromiseOrValue(input, this.#value);\n\n    const sourceEventDetail: SourceEventDetail<OutputType> = {\n      sourceProp: this,\n      value: this.#value,\n      generation: ++globalSourceGeneration,\n    };\n    this.markStale(\n      new CustomEvent<SourceEventDetail<OutputType>>(\"stale\", {\n        detail: sourceEventDetail,\n      }),\n    );\n  }\n\n  async get(): Promise<OutputType> {\n    return this.#value;\n  }\n\n  protected async deriveFromPromiseOrValue(\n    input: PromiseOrValue<InputType>,\n    oldValuePromise: Promise<OutputType>,\n  ): Promise<OutputType> {\n    return this.derive(await input, oldValuePromise);\n  }\n\n  // TODO: add an indirect layer to cache the derivation?\n  protected abstract derive(\n    input: InputType,\n    oldValuePromise: Promise<OutputType>,\n  ): PromiseOrValue<OutputType>;\n}\n\nexport abstract class SimpleTwistyPropSource<\n  SimpleType,\n> extends TwistyPropSource<SimpleType> {\n  protected override derive(input: SimpleType): PromiseOrValue<SimpleType> {\n    return input;\n  }\n}\n\n// TODO: Can we support `null` as a valid output value without loosening type\n// safety?\nexport const NO_VALUE = Symbol(\"no value\");\nexport type NoValueType = typeof NO_VALUE;\n\nexport abstract class TwistyPropDerived<\n  InputTypes extends InputRecord,\n  OutputType,\n> extends TwistyPropParent<OutputType> {\n  // cachedInputs:\n  #parents: InputProps<InputTypes>;\n\n  constructor(\n    parents: InputProps<InputTypes>,\n    protected userVisibleErrorTracker?: UserVisibleErrorTracker,\n  ) {\n    super();\n    this.#parents = parents;\n    for (const parent of Object.values(parents)) {\n      (\n        parent as TwistyPropDerived<InputProps<InputTypes>, OutputType>\n      ).addChild(this);\n    }\n  }\n\n  #cachedLastSuccessfulCalculation: {\n    inputs: InputTypes;\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  #cachedLatestGenerationCalculation: {\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  public async get(): Promise<OutputType> {\n    const generation = this.lastSourceGeneration;\n\n    if (this.#cachedLatestGenerationCalculation?.generation === generation) {\n      return this.#cachedLatestGenerationCalculation.output;\n    }\n\n    const latestGenerationCalculation = {\n      generation,\n      output: this.#cacheDerive(\n        this.#getParents(),\n        generation,\n        this.#cachedLastSuccessfulCalculation,\n      ),\n    };\n    this.#cachedLatestGenerationCalculation = latestGenerationCalculation;\n\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n\n  async #getParents(): Promise<InputTypes> {\n    const inputValuePromises: InputPromises<InputRecord> = {} as any; // TODO\n    for (const [key, parent] of Object.entries(this.#parents)) {\n      (inputValuePromises as Record<string, Promise<unknown>>)[key] = (\n        parent as TwistyPropParent<unknown>\n      ).get();\n    }\n\n    const inputs: InputTypes = {} as any; // TODO\n    for (const key in this.#parents) {\n      inputs[key] = (await (\n        inputValuePromises as Record<string, Promise<unknown>>\n      )[key]) as any;\n    }\n    return inputs;\n  }\n\n  async #cacheDerive(\n    inputsPromise: PromiseOrValue<InputTypes>,\n    generation: number,\n    cachedLatestGenerationCalculation: {\n      inputs: InputTypes;\n      output: Promise<OutputType>;\n      generation: number;\n    } | null = null,\n  ): Promise<OutputType> {\n    const inputs = await inputsPromise;\n\n    const cache = (output: OutputType): OutputType => {\n      this.#cachedLastSuccessfulCalculation = {\n        inputs,\n        output: Promise.resolve(output),\n        generation,\n      };\n      return output;\n    };\n\n    if (!cachedLatestGenerationCalculation) {\n      return cache(await this.derive(inputs));\n    }\n\n    const cachedInputs = cachedLatestGenerationCalculation.inputs;\n    for (const key in this.#parents) {\n      const parent = this.#parents[key];\n      if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n        return cache(await this.derive(inputs));\n      }\n    }\n\n    return cachedLatestGenerationCalculation.output;\n  }\n\n  protected abstract derive(input: InputTypes): PromiseOrValue<OutputType>;\n}\n\nexport class FreshListenerManager {\n  #disconnectionFunctions: (() => void)[] = [];\n\n  addListener<T>(\n    prop: TwistyPropParent<T>,\n    listener: (value: T) => void,\n  ): void {\n    let disconnected = false;\n    const wrappedListener = (value: T) => {\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      listener(value);\n    };\n\n    prop.addFreshListener(wrappedListener);\n\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n\n  // TODO: Figure out the signature to let us do overloads\n  /** @deprecated */\n  public addMultiListener3<U, V, W>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>, TwistyPropParent<W>],\n    listener: (values: [U, V, W]) => void,\n  ): void {\n    this.addMultiListener(props as any, listener as any); // TODO\n  }\n  public addMultiListener<U, V>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>],\n    listener: (values: [U, V]) => void,\n  ) {\n    let disconnected = false;\n\n    // We're going to get one initial call per prop. We'll ignore all but one.\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_: any) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      // We rely on `TwistyProp` caching to give us the full set of latest\n      // values efficiently.\n      const promises = (props as TwistyPropParent<any>[]).map((prop) =>\n        prop.get(),\n      );\n      const values = await Promise.all(promises);\n      listener(values as any); // TODO: fix up types\n    };\n\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n\n    this.#disconnectionFunctions.push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n\n  public disconnect(): void {\n    for (const disconnectionFunction of this.#disconnectionFunctions) {\n      disconnectionFunction();\n    }\n  }\n}\n","// Debounces `requestAnimationFrame()`.\nexport class RenderScheduler {\n  private animFrameID: number | null = null;\n  private animFrame = this.animFrameWrapper.bind(this);\n  constructor(private callback: (timestamp: DOMHighResTimeStamp) => void) {}\n\n  requestIsPending(): boolean {\n    return !!this.animFrameID;\n  }\n\n  requestAnimFrame(): void {\n    if (!this.animFrameID) {\n      this.animFrameID = requestAnimationFrame(this.animFrame);\n    }\n  }\n\n  cancelAnimFrame(): void {\n    if (this.animFrameID) {\n      cancelAnimationFrame(this.animFrameID);\n      this.animFrameID = 0;\n    }\n  }\n\n  private animFrameWrapper(timestamp: DOMHighResTimeStamp): void {\n    this.animFrameID = 0;\n    this.callback(timestamp);\n  }\n}\n\n// An interface for classes to use to expose their scheduling.\nexport interface Schedulable {\n  scheduleRender(): void;\n}\n","import { SimpleTwistyPropSource } from \"../../TwistyProp\";\n\n// TODO: turn these maps into lists?\nexport const hintFaceletStyles = {\n  floating: true, // default\n  none: true,\n};\nexport type HintFaceletStyle = keyof typeof hintFaceletStyles;\nexport type HintFaceletStyleWithAuto = HintFaceletStyle | \"auto\";\n\nexport class HintFaceletProp extends SimpleTwistyPropSource<HintFaceletStyleWithAuto> {\n  getDefaultValue(): HintFaceletStyleWithAuto {\n    return \"auto\";\n  }\n}\n","export const TAU = Math.PI * 2;\nexport const DEGREES_PER_RADIAN = 360 / TAU;\n","// Workarounds for `node`.\n// TODO: figure out how to remove this.\n\n// This stub does not need to be callable, just constructable to satisfy the `node` loader.\nclass HTMLElementStub {}\n\nlet HTMLElementShim: typeof HTMLElement;\nif (globalThis.HTMLElement) {\n  HTMLElementShim = HTMLElement;\n} else {\n  HTMLElementShim = HTMLElementStub as any;\n}\n\nexport { HTMLElementShim };\n\nclass CustomElementsStub {\n  define(): void {\n    // nothing\n  }\n}\n\nlet customElementsShim: typeof customElements;\n\nif (globalThis.customElements) {\n  customElementsShim = customElements;\n} else {\n  customElementsShim = new CustomElementsStub() as any;\n}\n\nexport { customElementsShim };\n","import {\n  HTMLElementShim,\n  customElementsShim,\n} from \"./node-custom-element-shims\";\n\nexport class CSSSource {\n  constructor(private sourceText: string) {\n    // TODO: Replace with adopted style sheets some day if we can.\n    // const blob = new Blob([sourceText], {\n    //   type: \"text/utf8\",\n    // });\n    // this.url = URL.createObjectURL(blob);\n  }\n\n  getAsString(): string {\n    return this.sourceText;\n  }\n}\n\n// - Wrapped element\n//   - Shadow root\n//     - Content wrapper\nexport class ManagedCustomElement extends HTMLElementShim {\n  public readonly shadow: ShadowRoot; // TODO: hide this\n  public readonly contentWrapper: HTMLDivElement; // TODO: can we get rid of this wrapper?\n\n  #cssSourceMap: Map<CSSSource, HTMLStyleElement> = new Map();\n  constructor(options?: { mode: \"open\" | \"closed\" }) {\n    super();\n    this.shadow = this.attachShadow({ mode: options?.mode ?? \"closed\" });\n\n    this.contentWrapper = document.createElement(\"div\");\n    this.contentWrapper.classList.add(\"wrapper\");\n    this.shadow.appendChild(this.contentWrapper);\n  }\n\n  // Add the source, if not already added.\n  // Returns the existing if it's already on the element.\n  public addCSS(cssSource: CSSSource): HTMLStyleElement {\n    const existing = this.#cssSourceMap.get(cssSource);\n    if (existing) {\n      return existing;\n    }\n\n    const cssElem: HTMLStyleElement = document.createElement(\"style\");\n    cssElem.textContent = cssSource.getAsString();\n\n    this.#cssSourceMap.set(cssSource, cssElem);\n    this.shadow.appendChild(cssElem);\n    return cssElem;\n  }\n\n  // Remove the source, if it's currently added.\n  public removeCSS(cssSource: CSSSource): void {\n    const cssElem = this.#cssSourceMap.get(cssSource);\n    if (!cssElem) {\n      return;\n    }\n    this.shadow.removeChild(cssElem);\n    this.#cssSourceMap.delete(cssSource);\n  }\n\n  public addElement<T extends Node>(element: T): T {\n    return this.contentWrapper.appendChild(element);\n  }\n\n  public prependElement<T extends Node>(element: T): void {\n    this.contentWrapper.prepend(element);\n  }\n\n  public removeElement<T extends Node>(element: T): T {\n    return this.contentWrapper.removeChild(element);\n  }\n}\n\ncustomElementsShim.define(\n  \"twisty-managed-custom-element\",\n  ManagedCustomElement,\n);\n","/**\n * @author mrdoob / http://mrdoob.com/\n * ESM conversion by Lucas Garron, 2021-12-21\n */\n\nconst performance:\n  | null\n  | (Performance & {\n      memory?: {\n        usedJSHeapSize: number;\n        jsHeapSizeLimit: number;\n      };\n    }) = globalThis.performance;\n\nexport class Stats {\n  mode = 0;\n\n  dom = document.createElement(\"div\");\n\n  constructor() {\n    this.dom.style.cssText =\n      \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n    this.dom.addEventListener(\n      \"click\",\n      (event) => {\n        event.preventDefault();\n        this.showPanel(++this.mode % this.dom.children.length);\n      },\n      false,\n    );\n\n    this.showPanel(0);\n  }\n\n  addPanel(panel: StatsPanel): StatsPanel {\n    this.dom.appendChild(panel.dom);\n    return panel;\n  }\n\n  showPanel(id: number): void {\n    for (let i = 0; i < this.dom.children.length; i++) {\n      (this.dom.children[i] as HTMLElement).style.display =\n        i === id ? \"block\" : \"none\";\n    }\n\n    this.mode = id;\n  }\n\n  beginTime = (performance || Date).now();\n  prevTime = this.beginTime;\n  frames = 0;\n\n  fpsPanel = this.addPanel(new StatsPanel(\"FPS\", \"#0ff\", \"#002\"));\n  msPanel = this.addPanel(new StatsPanel(\"MS\", \"#0f0\", \"#020\"));\n  memPanel = performance?.memory\n    ? this.addPanel(new StatsPanel(\"MB\", \"#f08\", \"#201\"))\n    : null;\n  REVISION = 16;\n\n  begin() {\n    this.beginTime = (performance || Date).now();\n  }\n\n  end() {\n    this.frames++;\n\n    const time = (performance || Date).now();\n\n    this.msPanel.update(time - this.beginTime, 200);\n\n    if (time >= this.prevTime + 1000) {\n      this.fpsPanel.update((this.frames * 1000) / (time - this.prevTime), 100);\n\n      this.prevTime = time;\n      this.frames = 0;\n\n      if (this.memPanel) {\n        const memory = performance!.memory!;\n        this.memPanel.update(\n          memory.usedJSHeapSize / 1048576,\n          memory.jsHeapSizeLimit / 1048576,\n        );\n      }\n    }\n\n    return time;\n  }\n\n  update() {\n    this.beginTime = this.end();\n  }\n}\n\nconst PR = Math.round(globalThis?.window?.devicePixelRatio ?? 1);\n\nconst WIDTH = 80 * PR;\nconst HEIGHT = 48 * PR;\nconst TEXT_X = 3 * PR;\nconst TEXT_Y = 2 * PR;\nconst GRAPH_X = 3 * PR;\nconst GRAPH_Y = 15 * PR;\nconst GRAPH_WIDTH = 74 * PR;\nconst GRAPH_HEIGHT = 30 * PR;\n\nexport class StatsPanel {\n  min = Infinity;\n  max = 0;\n  dom = document.createElement(\"canvas\");\n  context = this.dom.getContext(\"2d\")!;\n  constructor(private name: string, private fg: string, private bg: string) {\n    this.dom.width = WIDTH;\n    this.dom.height = HEIGHT;\n    this.dom.style.cssText = \"width:80px;height:48px\";\n\n    this.context.font = `bold ${9 * PR}px Helvetica,Arial,sans-serif`;\n    this.context.textBaseline = \"top\";\n\n    this.context.fillStyle = bg;\n    this.context.fillRect(0, 0, WIDTH, HEIGHT);\n\n    this.context.fillStyle = fg;\n    this.context.fillText(name, TEXT_X, TEXT_Y);\n    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\n    this.context.fillStyle = bg;\n    this.context.globalAlpha = 0.9;\n    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n  }\n\n  update(value: number, maxValue: number) {\n    this.min = Math.min(this.min, value);\n    this.max = Math.max(this.max, value);\n\n    this.context.fillStyle = this.bg;\n    this.context.globalAlpha = 1;\n    this.context.fillRect(0, 0, WIDTH, GRAPH_Y);\n    this.context.fillStyle = this.fg;\n    this.context.fillText(\n      `${Math.round(value)} ${this.name} (${Math.round(this.min)}-${Math.round(\n        this.max,\n      )})`,\n      TEXT_X,\n      TEXT_Y,\n    );\n\n    this.context.drawImage(\n      this.dom,\n      GRAPH_X + PR,\n      GRAPH_Y,\n      GRAPH_WIDTH - PR,\n      GRAPH_HEIGHT,\n      GRAPH_X,\n      GRAPH_Y,\n      GRAPH_WIDTH - PR,\n      GRAPH_HEIGHT,\n    );\n\n    this.context.fillRect(\n      GRAPH_X + GRAPH_WIDTH - PR,\n      GRAPH_Y,\n      PR,\n      GRAPH_HEIGHT,\n    );\n\n    this.context.fillStyle = this.bg;\n    this.context.globalAlpha = 0.9;\n    this.context.fillRect(\n      GRAPH_X + GRAPH_WIDTH - PR,\n      GRAPH_Y,\n      PR,\n      Math.round((1 - value / maxValue) * GRAPH_HEIGHT),\n    );\n  }\n}\n","import { from } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO can we remove the cached proxy?\n\n// In theory we can, but we've run into situations where imports are not properly cached.\nlet cachedConstructorProxy: Promise<\n  typeof import(\"./dynamic-entries/twisty-dynamic-3d\")\n> | null = null;\n\nexport async function proxy3D(): Promise<\n  typeof import(\"./dynamic-entries/twisty-dynamic-3d\")\n> {\n  return (cachedConstructorProxy ??= import(\n    \"./dynamic-entries/twisty-dynamic-3d\"\n  ));\n}\n\nexport const THREEJS: Promise<typeof import(\"three\")> = from(\n  async () => (await proxy3D()).T3I,\n);\n","let globalPixelRatioOverride: number | null = null;\nexport function setGlobalPixelRatioOverride(override: number | null): void {\n  globalPixelRatioOverride = override;\n}\n\n// TODO: Handle if you move across screens?\nexport function pixelRatio(): number {\n  return globalPixelRatioOverride ?? (devicePixelRatio || 1);\n}\n","import { CSSSource } from \"../ManagedCustomElement\";\n\n// The `position` values are a hack for a bug in Safari where the canvas either\n// grows infinitely, or takes up the full `fr` of any encompassing grid (making\n// the contents of that element e.g. over 100% of its height). `contain:\n// content` is a good fix for this, but there is no indication that Safari will\n// support it soon. https://developer.mozilla.org/en-US/docs/Web/CSS/contain\n\nexport const twisty3DVantageCSS = new CSSSource(\n  `\n:host {\n  width: 384px;\n  height: 256px;\n  display: grid;\n}\n\n.wrapper {\n  width: 100%;\n  height: 100%;\n  display: grid;\n  overflow: hidden;\n  place-content: center;\n  contain: strict;\n}\n\n.loading {\n  width: 4em;\n  height: 4em;\n  border-radius: 2.5em;\n  border: 0.5em solid rgba(0, 0, 0, 0);\n  border-top: 0.5em solid rgba(0, 0, 0, 0.7);\n  border-right: 0.5em solid rgba(0, 0, 0, 0.7);\n  animation: fade-in-delayed 4s, rotate 1s linear infinite;\n}\n\n@keyframes fade-in-delayed {\n  0% { opacity: 0; }\n  25% {opacity: 0; }\n  100% { opacity: 1; }\n}\n\n@keyframes rotate {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n/* TODO: This is due to stats hack. Replace with \\`canvas\\`. */\n.wrapper > canvas {\n  max-width: 100%;\n  max-height: 100%;\n  animation: fade-in 0.25s ease-in;\n}\n\n@keyframes fade-in {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n.wrapper.invisible {\n  opacity: 0;\n}\n\n.wrapper.drag-input-enabled > canvas {\n  cursor: grab;\n}\n\n.wrapper.drag-input-enabled > canvas:active {\n  cursor: grabbing;\n}\n`,\n);\n","// export class Drag() {\n\n// }\n\ninterface DragInfo {\n  attachedInfo: Record<any, any>;\n  hasMoved: boolean;\n  lastClientX: number;\n  lastClientY: number;\n  lastTimeStamp: number;\n}\n\ntype PointerID = number;\n\nexport interface DragMovementInfo {\n  attachedInfo: Record<any, any>;\n  movementX: number;\n  movementY: number;\n  elapsedMs: number;\n}\n\nexport interface UpInfo {\n  attachedInfo: Record<any, any>;\n}\n\nexport interface PressInfo {\n  normalizedX: number;\n  normalizedY: number;\n  rightClick: boolean;\n  keys: {\n    // TODO: group these\n    altKey: boolean;\n    ctrlOrMetaKey: boolean;\n    shiftKey: boolean;\n  };\n}\n\n// Chrome can report movements as low as `0.0000152587890625` even if the cursor did not move at all. So we need a treshold insteadl.\nconst MOVEMENT_EPSILON = 0.1; // px\n\nexport class DragTracker extends EventTarget {\n  #dragInfoMap: Map<PointerID, DragInfo> = new Map();\n\n  constructor(public readonly target: HTMLElement) {\n    super();\n  }\n\n  // Idempotent\n  start() {\n    this.addTargetListener(\"pointerdown\", this.onPointerDown.bind(this));\n    // Prevent right-click on desktop (only tested on macOS Chrome/Safari/Firefox) so we can detect right-click moves.\n    // TODO: Can we do this selectively, e.g. only on the puzzle? That way we could allow right-click to download the canvas. Unfortunately, it would probably require a sync calculation.\n    this.addTargetListener(\"contextmenu\", (e) => {\n      e.preventDefault();\n    });\n    // Prevent touch scrolling (preventing default on `pointermove` doesn't work).\n    this.addTargetListener(\"touchmove\", (e) => e.preventDefault());\n    // Prevent zooming on double-tap (iOS).\n    // This is because `dblclick` works to zoom in, but does *not* work to zoom out. So the user can get stuck zoomed into the player without a way to zoom out.\n    this.addTargetListener(\"dblclick\", (e) => e.preventDefault());\n  }\n\n  // Idempotent\n  stop(): void {\n    for (const [eventType, listener] of this.#targetListeners.entries()) {\n      this.target.removeEventListener(eventType, listener);\n    }\n    this.#targetListeners.clear();\n    this.#lazyListenersRegistered = false;\n  }\n\n  #targetListeners = new Map<string, (e: MouseEvent) => any>();\n  addTargetListener(eventType: string, listener: (e: MouseEvent) => any) {\n    if (!this.#targetListeners.has(eventType)) {\n      this.target.addEventListener(eventType, listener);\n      this.#targetListeners.set(eventType, listener);\n    }\n  }\n\n  // This allows us to avoid getting a callback every time the pointer moves over the canvas, until we have a down event.\n  // TODO: Ideally we'd also support unregistering when we're certain there are no more active touches. But this means we need to properly handle every way a pointer \"click\" can end, which is tricky across environments (due to e.g. mouse vs. touch vs. stylues, canvas/viewport/window/scroll boundaries, right-click and other ways of losing focus, etc.), so we conservatively leave the listeners on.\n  #lazyListenersRegistered: boolean = false;\n  #registerLazyListeners(): void {\n    if (this.#lazyListenersRegistered) {\n      return;\n    }\n    this.addTargetListener(\"pointermove\", this.onPointerMove.bind(this)); // TODO: only register this after pointer down.\n    this.addTargetListener(\"pointerup\", this.onPointerUp.bind(this));\n    this.#lazyListenersRegistered = true;\n  }\n\n  #clear(e: PointerEvent): void {\n    this.#dragInfoMap.delete(e.pointerId);\n  }\n\n  // `null`: means: ignore this result (no movement, or not\n  #trackDrag(e: PointerEvent): {\n    movementInfo: DragMovementInfo | null;\n    hasMoved: boolean;\n  } {\n    // TODO: Find a way to detect if this is an active press, in a way that works cross-platform.\n    // if (e.buttons === 0) {\n    //   return { movementInfo: null, hasMoved: false };\n    // }\n    const existing = this.#dragInfoMap.get(e.pointerId);\n    if (!existing) {\n      return { movementInfo: null, hasMoved: false };\n    }\n    // We would try to use `e.movementX`/`e.movementY`, except Safari:\n    // - Does not have those values on i[Pad]OS.\n    // - Will always report `0` for these values on macOS.\n    // https://bugs.webkit.org/show_bug.cgi?id=220194\n    //\n    // The following are all insufficiently powerful for detecting the Safari `0` bug:\n    // - `\"movementX\" in e`\n    // - `e.movementX !== \"undefined\"`\n    // - `e.hasOwnProperty(\"movementX\")`\n\n    let movementInfo: DragMovementInfo;\n    if ((e.movementX ?? 0) !== 0 || (e.movementY ?? 0) !== 0) {\n      // We optimistically try to catch sub-pixel movements in Chrome.\n      movementInfo = {\n        attachedInfo: existing.attachedInfo,\n        movementX: e.movementX,\n        movementY: e.movementY,\n        elapsedMs: e.timeStamp - existing.lastTimeStamp,\n      };\n    } else {\n      movementInfo = {\n        attachedInfo: existing.attachedInfo,\n        movementX: e.clientX - existing.lastClientX,\n        movementY: e.clientY - existing.lastClientY,\n        elapsedMs: e.timeStamp - existing.lastTimeStamp,\n      };\n    }\n    existing.lastClientX = e.clientX;\n    existing.lastClientY = e.clientY;\n    existing.lastTimeStamp = e.timeStamp;\n    if (\n      Math.abs(movementInfo.movementX) < MOVEMENT_EPSILON &&\n      Math.abs(movementInfo.movementY) < MOVEMENT_EPSILON\n    ) {\n      return { movementInfo: null, hasMoved: existing.hasMoved };\n    } else {\n      existing.hasMoved = true;\n      return { movementInfo, hasMoved: existing.hasMoved };\n    }\n  }\n\n  private onPointerDown(e: PointerEvent) {\n    this.#registerLazyListeners();\n    const newDragInfo: DragInfo = {\n      attachedInfo: {},\n      hasMoved: false,\n      lastClientX: e.clientX,\n      lastClientY: e.clientY,\n      lastTimeStamp: e.timeStamp,\n    };\n    this.#dragInfoMap.set(e.pointerId, newDragInfo);\n    this.target.setPointerCapture(e.pointerId);\n  }\n\n  private onPointerMove(e: PointerEvent) {\n    const movementInfo = this.#trackDrag(e).movementInfo;\n    if (movementInfo) {\n      e.preventDefault();\n      this.dispatchEvent(\n        new CustomEvent(\"move\", {\n          detail: movementInfo,\n        }),\n      );\n    }\n  }\n\n  private onPointerUp(e: PointerEvent) {\n    const trackDragResult = this.#trackDrag(e);\n    const existing = this.#dragInfoMap.get(e.pointerId)!; // TODO\n    this.#clear(e);\n    this.target.releasePointerCapture(e.pointerId); // TODO: unnecessary?\n    let event: CustomEvent;\n    if (trackDragResult.hasMoved) {\n      // TODO: send proper movement/momentum since last move event.\n      event = new CustomEvent<UpInfo>(\"up\", {\n        detail: { attachedInfo: existing.attachedInfo },\n      });\n    } else {\n      const { altKey, ctrlKey, metaKey, shiftKey } = e;\n      event = new CustomEvent<PressInfo>(\"press\", {\n        detail: {\n          normalizedX: (e.offsetX / this.target.offsetWidth) * 2 - 1,\n          normalizedY: 1 - (e.offsetY / this.target.offsetHeight) * 2,\n          rightClick: !!(e.button & 2),\n          keys: {\n            altKey,\n            ctrlOrMetaKey: ctrlKey || metaKey,\n            shiftKey,\n          },\n        },\n      });\n    }\n    this.dispatchEvent(event);\n  }\n}\n","// TODO: https://stackoverflow.com/a/40443642\n\n// let shareAllNewRenderers: boolean = false;\n\n// // WARNING: The current shared renderer implementation is not every efficient.\n// // Avoid using for players that are likely to have dimensions approaching 1 megapixel or higher.\n// // TODO: use a dedicated renderer while fullscreen?\n// export function experimentalSetShareAllNewRenderers(share: boolean): void {\n//   shareAllNewRenderers = share;\n// }\n\n// const sharedRenderer: WebGLRenderer | null = null;\n\nimport { THREEJS } from \"../../heavy-code-imports/3d\";\nimport type { Camera, Scene, WebGLRenderer } from \"three\";\nimport { pixelRatio } from \"../canvas\";\n\nconst renderers: Promise<WebGLRenderer>[] = [];\n\n// Render result is guaranteed to be available synchronously at resolution time.\nexport async function rawRenderPooled(\n  width: number,\n  height: number,\n  scene: Scene,\n  camera: Camera,\n): Promise<HTMLCanvasElement> {\n  // At most one in the pool for now.\n  if (renderers.length === 0) {\n    renderers.push(newRenderer());\n  }\n  const renderer = await renderers[0];\n  // TODO: scissoring\n  renderer.setSize(width, height); // TODO: is it faster if we cache values and only call this when necessary?\n  renderer.render(scene, camera);\n\n  return renderer.domElement;\n}\n\n// let haveSet = false;\nexport async function renderPooled(\n  width: number,\n  height: number,\n  canvas: HTMLCanvasElement,\n  scene: Scene,\n  camera: Camera,\n): Promise<void> {\n  if (width === 0 || height === 0) {\n    return;\n  }\n  // At most one in the pool for now.\n  if (renderers.length === 0) {\n    renderers.push(newRenderer());\n  }\n\n  const rendererCanvas = await rawRenderPooled(width, height, scene, camera);\n\n  // TODO: Should we cache this? Seems to take about 0.0001ms to get.\n  const context = canvas.getContext(\"2d\")!;\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.drawImage(rendererCanvas, 0, 0);\n}\n\nexport async function newRenderer(): Promise<WebGLRenderer> {\n  const rendererConstructor = (await THREEJS).WebGLRenderer;\n  const renderer = new rendererConstructor({\n    antialias: true,\n    alpha: true,\n  });\n  renderer.setPixelRatio(pixelRatio());\n  return renderer;\n}\n","import type { Vector3 } from \"three\";\nimport { RenderScheduler } from \"../../controllers/RenderScheduler\";\nimport { THREEJS } from \"../../heavy-code-imports/3d\";\nimport type { OrbitCoordinates } from \"../../model/props/viewer/OrbitCoordinatesRequestProp\";\nimport type { TwistyPlayerModel } from \"../../model/TwistyPlayerModel\";\nimport type { DragMovementInfo, DragTracker } from \"./DragTracker\";\nimport { DEGREES_PER_RADIAN } from \"./TAU\";\n\nconst INERTIA_DEFAULT: boolean = true;\n\nconst INERTIA_DURATION_MS = 500;\n// If the first inertial render is this long after the last move, we assume the\n// user has halted the cursor and we consider inertia to have \"timed out\". We\n// never begin animating the inertia.\nconst INERTIA_TIMEOUT_MS = 50;\n\nconst VERTICAL_MOVEMENT_BASE_SCALE = 0.75;\n\n// progress is from 0 to 1.\nfunction momentumScale(progress: number) {\n  // This is the exponential curve flipped so that\n  // - The slope at progress = 0 is 1 (this corresponds to \"x = 1\" on the normal\n  //   curve).\n  // - The scale exponentially \"decays\" until progress = 1.\n  // This means the scale at the end will be about 0.418\n  return (Math.exp(1 - progress) - (1 - progress)) / (1 - Math.E) + 1;\n}\n\nclass Inertia {\n  private scheduler = new RenderScheduler(this.render.bind(this));\n  private lastTimestamp: number;\n  constructor(\n    private startTimestamp: number,\n    private momentumX: number,\n    private momentumY: number,\n    private callback: (movementX: number, movementY: number) => void,\n  ) {\n    this.scheduler.requestAnimFrame();\n    this.lastTimestamp = startTimestamp;\n  }\n\n  private render(now: DOMHighResTimeStamp) {\n    const progressBefore =\n      (this.lastTimestamp - this.startTimestamp) / INERTIA_DURATION_MS;\n    const progressAfter = Math.min(\n      1,\n      (now - this.startTimestamp) / INERTIA_DURATION_MS,\n    );\n\n    if (\n      progressBefore === 0 &&\n      progressAfter > INERTIA_TIMEOUT_MS / INERTIA_DURATION_MS\n    ) {\n      // The user has already paused for a while. Don't start any inertia.\n      return;\n    }\n\n    const delta = momentumScale(progressAfter) - momentumScale(progressBefore);\n\n    // TODO: For now, we only carry horizontal momentum. If this should stay, we\n    // can remove the plumbing for the Y dimension.\n    this.callback(this.momentumX * delta * 1000, this.momentumY * delta * 1000);\n\n    if (progressAfter < 1) {\n      this.scheduler.requestAnimFrame();\n    }\n    this.lastTimestamp = now;\n  }\n}\n\nexport async function positionToOrbitCoordinates(\n  position: Vector3,\n): Promise<OrbitCoordinates> {\n  const spherical = new (await THREEJS).Spherical();\n  spherical.setFromVector3(position);\n  return {\n    latitude: 90 - spherical.phi * DEGREES_PER_RADIAN,\n    longitude: spherical.theta * DEGREES_PER_RADIAN,\n    distance: spherical.radius,\n  };\n}\n\ninterface TwistyOrbitControlsDragAttachedInfo {\n  lastTemperedX: number;\n  lastTemperedY: number;\n  timestamp: number;\n}\n\n// TODO: change mouse cursor while moving.\nexport class TwistyOrbitControls {\n  /** @deprecated */\n  experimentalInertia: boolean = INERTIA_DEFAULT;\n  private onMovementBound = this.onMovement.bind(this);\n  public experimentalHasBeenMoved: boolean = false;\n  constructor(\n    private model: TwistyPlayerModel,\n    private mirror: boolean,\n    private canvas: HTMLCanvasElement,\n    private dragTracker: DragTracker,\n  ) {\n    this.dragTracker.addEventListener(\"move\", this.onMove.bind(this));\n    this.dragTracker.addEventListener(\"up\", this.onUp.bind(this));\n  }\n\n  // f is the fraction of the canvas traversed per ms.\n  temperMovement(f: number): number {\n    // This is scaled to be linear for small values, but to reduce large values\n    // by a significant factor.\n    return (Math.sign(f) * Math.log(Math.abs(f * 10) + 1)) / 6;\n  }\n\n  onMove(e: CustomEvent<DragMovementInfo>): void {\n    e.detail.attachedInfo ??= {};\n\n    const { temperedX, temperedY } = this.onMovement(\n      e.detail.movementX,\n      e.detail.movementY,\n    );\n    const attachedInfo = e.detail\n      .attachedInfo as TwistyOrbitControlsDragAttachedInfo;\n    attachedInfo.lastTemperedX = temperedX * 10;\n    attachedInfo.lastTemperedY = temperedY * 10;\n    attachedInfo.timestamp = e.timeStamp; // TODO\n  }\n\n  onMovement(\n    movementX: number,\n    movementY: number,\n  ): {\n    temperedX: number;\n    temperedY: number;\n  } {\n    const scale = this.mirror ? -1 : 1;\n\n    // TODO: refactor\n    const minDim = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight);\n\n    const temperedX = this.temperMovement(movementX / minDim);\n    const temperedY = this.temperMovement(\n      (movementY / minDim) * VERTICAL_MOVEMENT_BASE_SCALE,\n    );\n    this.model.twistySceneModel.orbitCoordinatesRequest.set(\n      (async () => {\n        const prevCoords =\n          await this.model.twistySceneModel.orbitCoordinates.get();\n\n        const newCoords = {\n          latitude:\n            prevCoords.latitude + 2 * temperedY * DEGREES_PER_RADIAN * scale,\n          longitude: prevCoords.longitude - 2 * temperedX * DEGREES_PER_RADIAN,\n        };\n        return newCoords;\n      })(),\n    );\n    return { temperedX, temperedY };\n  }\n\n  onUp(e: CustomEvent<DragMovementInfo>): void {\n    e.preventDefault();\n    if (\n      \"lastTemperedX\" in e.detail.attachedInfo &&\n      \"lastTemperedY\" in e.detail.attachedInfo &&\n      \"timestamp\" in e.detail.attachedInfo &&\n      e.timeStamp - e.detail.attachedInfo.timestamp < 60 // TODO\n    ) {\n      new Inertia(\n        e.timeStamp, // TODO\n        (e.detail.attachedInfo as TwistyOrbitControlsDragAttachedInfo)\n          .lastTemperedX,\n        (e.detail.attachedInfo as TwistyOrbitControlsDragAttachedInfo)\n          .lastTemperedY,\n        this.onMovementBound,\n      ); // TODO: cancel inertia\n    }\n  }\n}\n","import type { PerspectiveCamera, WebGLRenderer } from \"three\";\nimport { Stats } from \"../../../vendor/mit/three/examples/jsm/libs/stats.modified.module\";\nimport { THREEJS } from \"../../heavy-code-imports/3d\";\nimport { StaleDropper } from \"../../model/PromiseFreshener\";\nimport type { TwistyPropParent } from \"../../model/props/TwistyProp\";\nimport type { OrbitCoordinates } from \"../../model/props/viewer/OrbitCoordinatesRequestProp\";\nimport type { TwistyPlayerModel } from \"../../model/TwistyPlayerModel\";\nimport { RenderScheduler } from \"../../controllers/RenderScheduler\";\nimport { ManagedCustomElement } from \"../ManagedCustomElement\";\nimport { customElementsShim } from \"../node-custom-element-shims\";\nimport { pixelRatio } from \"../canvas\";\nimport { twisty3DVantageCSS } from \"./Twisty3DVantage.css\";\nimport { DragTracker, PressInfo } from \"./DragTracker\";\nimport { newRenderer, renderPooled } from \"./RendererPool\";\nimport { DEGREES_PER_RADIAN } from \"./TAU\";\nimport type { Twisty3DSceneWrapper } from \"./Twisty3DSceneWrapper\";\nimport { TwistyOrbitControls } from \"./TwistyOrbitControls\";\nimport type { DragInputMode } from \"../../model/props/puzzle/state/DragInputProp\";\nimport { twistyDebugGlobals } from \"../../debug\";\n\nexport async function setCameraFromOrbitCoordinates(\n  camera: PerspectiveCamera,\n  orbitCoordinates: OrbitCoordinates,\n  backView: boolean = false,\n): Promise<void> {\n  const spherical = new (await THREEJS).Spherical(\n    orbitCoordinates.distance,\n    (90 - (backView ? -1 : 1) * orbitCoordinates.latitude) / DEGREES_PER_RADIAN,\n    ((backView ? 180 : 0) + orbitCoordinates.longitude) / DEGREES_PER_RADIAN,\n  );\n  spherical.makeSafe();\n  camera.position.setFromSpherical(spherical);\n  camera.lookAt(0, 0, 0);\n}\n\nlet dedicatedRenderersSoFar = 0;\nconst DEFAULT_MAX_DEDICATED_RENDERERS = 2; // This allows for a front view and a back view (or two separate front views).\nlet sharingRenderers = false;\nfunction shareRenderer(): boolean {\n  if (twistyDebugGlobals.shareAllNewRenderers !== \"auto\") {\n    if (!twistyDebugGlobals.shareAllNewRenderers) {\n      dedicatedRenderersSoFar++;\n    }\n    return twistyDebugGlobals.shareAllNewRenderers !== \"never\";\n  }\n  if (dedicatedRenderersSoFar < DEFAULT_MAX_DEDICATED_RENDERERS) {\n    dedicatedRenderersSoFar++;\n    return false;\n  } else {\n    sharingRenderers = true;\n    return true;\n  }\n}\n\nexport function haveStartedSharingRenderers(): boolean {\n  return sharingRenderers;\n}\n\nexport class Twisty3DVantage extends ManagedCustomElement {\n  scene: Twisty3DSceneWrapper | null = null;\n\n  stats: Stats | null = null;\n\n  private rendererIsShared: boolean = shareRenderer();\n\n  loadingElement: HTMLDivElement | null = null;\n  constructor(\n    private model?: TwistyPlayerModel,\n    scene?: Twisty3DSceneWrapper,\n    private options?: { backView?: boolean },\n  ) {\n    super();\n    this.scene = scene ?? null;\n\n    this.loadingElement = this.addElement(document.createElement(\"div\"));\n    this.loadingElement.classList.add(\"loading\");\n\n    if (twistyDebugGlobals.showRenderStats) {\n      this.stats = new Stats();\n      this.stats.dom.style.position = \"absolute\";\n      this.contentWrapper.appendChild(this.stats.dom);\n    }\n  }\n\n  async connectedCallback(): Promise<void> {\n    this.addCSS(twisty3DVantageCSS);\n    this.addElement((await this.canvasInfo()).canvas);\n\n    this.#onResize();\n    const observer = new ResizeObserver(this.#onResize.bind(this));\n    observer.observe(this.contentWrapper);\n    this.orbitControls(); // Instantiate orbit controls\n    this.#setupBasicPresses();\n\n    this.scheduleRender();\n  }\n\n  async #setupBasicPresses(): Promise<void> {\n    const dragTracker = await this.#dragTracker();\n    dragTracker.addEventListener(\"press\", async (e: CustomEvent<PressInfo>) => {\n      const movePressInput =\n        await this.model!.twistySceneModel.movePressInput.get();\n      if (movePressInput !== \"basic\") {\n        return;\n      }\n      this.dispatchEvent(\n        new CustomEvent(\"press\", {\n          detail: {\n            pressInfo: e.detail,\n            cameraPromise: this.camera(),\n          },\n        }),\n      );\n    });\n  }\n\n  #onResizeStaleDropper = new StaleDropper<PerspectiveCamera>();\n\n  async clearCanvas(): Promise<void> {\n    if (this.rendererIsShared) {\n      const canvasInfo = await this.canvasInfo();\n      canvasInfo.context.clearRect(\n        0,\n        0,\n        canvasInfo.canvas.width,\n        canvasInfo.canvas.height,\n      );\n    } else {\n      const renderer = await this.renderer();\n      const context = renderer.getContext();\n      context.clear(context.COLOR_BUFFER_BIT);\n    }\n  }\n\n  // TODO: Why doesn't this work for the top-right back view height?\n  #width: number = 0;\n  #height: number = 0;\n  async #onResize(): Promise<void> {\n    const camera = await this.#onResizeStaleDropper.queue(this.camera());\n\n    const w = this.contentWrapper.clientWidth;\n    const h = this.contentWrapper.clientHeight;\n    this.#width = w;\n    this.#height = h;\n    const off = 0;\n    let yoff = 0;\n    let excess = 0;\n    if (h > w) {\n      excess = h - w;\n      yoff = -Math.floor(0.5 * excess);\n    }\n    camera.aspect = w / h;\n    camera.setViewOffset(w, h - excess, off, yoff, w, h);\n    camera.updateProjectionMatrix(); // TODO\n\n    this.clearCanvas();\n    if (this.rendererIsShared) {\n      const canvasInfo = await this.canvasInfo();\n\n      canvasInfo.canvas.width = w * pixelRatio();\n      canvasInfo.canvas.height = h * pixelRatio();\n      canvasInfo.canvas.style.width = `${w.toString()}px`;\n      canvasInfo.canvas.style.height = `${h.toString()}px`;\n    } else {\n      const renderer = await this.renderer();\n      renderer.setSize(w, h, true);\n    }\n\n    this.scheduleRender();\n  }\n\n  #cachedRenderer: Promise<WebGLRenderer> | null = null;\n  async renderer(): Promise<WebGLRenderer> {\n    if (this.rendererIsShared) {\n      throw new Error(\"renderer expected to be shared.\");\n    }\n    return (this.#cachedRenderer ??= newRenderer());\n  }\n\n  #cachedCanvas: Promise<{\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D;\n  }> | null = null;\n  async canvasInfo(): Promise<{\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D;\n  }> {\n    return (this.#cachedCanvas ??= (async () => {\n      let canvas: HTMLCanvasElement;\n      if (this.rendererIsShared) {\n        canvas = this.addElement(document.createElement(\"canvas\"));\n      } else {\n        const renderer = await this.renderer();\n        canvas = this.addElement(renderer.domElement);\n      }\n      this.loadingElement?.remove();\n      const context = canvas.getContext(\"2d\")!;\n      return { canvas, context };\n    })());\n  }\n\n  #cachedDragTracker: Promise<DragTracker> | null = null;\n  async #dragTracker(): Promise<DragTracker> {\n    return (this.#cachedDragTracker ??= (async () => {\n      const dragTracker = new DragTracker((await this.canvasInfo()).canvas);\n      this.model?.twistySceneModel.dragInput.addFreshListener(\n        (dragInputMode: DragInputMode) => {\n          let dragInputEnabled = false;\n          switch (dragInputMode) {\n            case \"auto\": {\n              dragTracker.start();\n              dragInputEnabled = true;\n              break;\n            }\n            case \"none\": {\n              dragTracker.stop();\n              break;\n            }\n          }\n          this.contentWrapper.classList.toggle(\n            \"drag-input-enabled\",\n            dragInputEnabled,\n          );\n        },\n      );\n      return dragTracker;\n    })());\n  }\n\n  #cachedCamera: Promise<PerspectiveCamera> | null = null;\n  async camera(): Promise<PerspectiveCamera> {\n    return (this.#cachedCamera ??= (async () => {\n      const camera = new (await THREEJS).PerspectiveCamera(\n        20,\n        1, // We rely on the resize logic to handle this.\n        0.1,\n        20,\n      );\n      camera.position.copy(\n        new (await THREEJS).Vector3(2, 4, 4).multiplyScalar(\n          this.options?.backView ? -1 : 1,\n        ),\n      );\n      camera.lookAt(0, 0, 0);\n      // TODO: `TwistyOrbitControls` breaks isolateion\n      return camera;\n    })());\n  }\n\n  #cachedOrbitControls: Promise<TwistyOrbitControls> | null = null;\n  async orbitControls(): Promise<TwistyOrbitControls> {\n    return (this.#cachedOrbitControls ??= (async () => {\n      const orbitControls = new TwistyOrbitControls(\n        this.model!,\n        !!this.options?.backView,\n        (await this.canvasInfo()).canvas,\n        await this.#dragTracker(),\n      );\n\n      if (this.model) {\n        this.addListener(\n          this.model.twistySceneModel.orbitCoordinates,\n          async (orbitCoordinates: OrbitCoordinates) => {\n            const camera = await this.camera();\n            setCameraFromOrbitCoordinates(\n              camera,\n              orbitCoordinates,\n              this.options?.backView,\n            );\n            // TODO: Wrap in StaleDropper?\n\n            this.scheduleRender();\n          },\n        );\n      }\n\n      return orbitControls;\n    })());\n  }\n\n  addListener<T>(\n    prop: TwistyPropParent<T>,\n    listener: (value: T) => void,\n  ): void {\n    prop.addFreshListener(listener);\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(listener);\n      // disconnected = true; // TODO\n    });\n  }\n\n  #disconnectionFunctions: (() => void)[] = [];\n  disconnect(): void {\n    for (const fn of this.#disconnectionFunctions) {\n      fn();\n    }\n    this.#disconnectionFunctions = []; // TODO: Encapsulate this.\n  }\n\n  #experimentalNextRenderFinishedCallback: (() => void) | null = null;\n  experimentalNextRenderFinishedCallback(callback: () => void): void {\n    this.#experimentalNextRenderFinishedCallback = callback;\n  }\n\n  async render(): Promise<void> {\n    if (!this.scene) {\n      throw new Error(\"Attempted to render without a scene\");\n    }\n\n    this.stats?.begin();\n\n    const [scene, camera, canvas] = await Promise.all([\n      this.scene.scene(),\n      this.camera(),\n      this.canvasInfo(),\n    ]);\n    if (this.rendererIsShared) {\n      renderPooled(this.#width, this.#height, canvas.canvas, scene, camera);\n    } else {\n      (await this.renderer()).render(scene, camera);\n    }\n\n    this.stats?.end();\n    this.#experimentalNextRenderFinishedCallback?.();\n    this.#experimentalNextRenderFinishedCallback = null;\n  }\n\n  #scheduler = new RenderScheduler(this.render.bind(this));\n  scheduleRender(): void {\n    // console.log(\"scheduling\", this);\n    this.#scheduler.requestAnimFrame();\n  }\n}\n\ncustomElementsShim.define(\"twisty-3d-vantage\", Twisty3DVantage);\n","import {\n  KPuzzle,\n  KState\n} from \"./chunk-KLI2E737.js\";\nimport {\n  Alg,\n  Move\n} from \"./chunk-VZP3KFTU.js\";\n\n// src/cubing/puzzles/stickerings/mask.ts\nfunction getFaceletStickeringMask(stickeringMask, orbitName, pieceIdx, faceletIdx, hint) {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask = orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\nvar PieceAnnotation = class {\n  constructor(kpuzzle, defaultValue) {\n    this.stickerings = /* @__PURE__ */ new Map();\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue)\n      );\n    }\n  }\n};\nvar regular = \"regular\";\nvar ignored = \"ignored\";\nvar oriented = \"oriented\";\nvar invisible = \"invisible\";\nvar dim = \"dim\";\nvar pieceStickerings = {\n  [\"Regular\" /* Regular */]: {\n    facelets: [regular, regular, regular, regular, regular]\n  },\n  [\"Ignored\" /* Ignored */]: {\n    facelets: [ignored, ignored, ignored, ignored, ignored]\n  },\n  [\"OrientationStickers\" /* OrientationStickers */]: {\n    facelets: [oriented, oriented, oriented, oriented, oriented]\n  },\n  [\"IgnoreNonPrimary\" /* IgnoreNonPrimary */]: {\n    facelets: [regular, ignored, ignored, ignored, ignored]\n  },\n  [\"Invisible\" /* Invisible */]: {\n    facelets: [invisible, invisible, invisible, invisible, invisible]\n  },\n  [\"PermuteNonPrimary\" /* PermuteNonPrimary */]: {\n    facelets: [dim, regular, regular, regular, regular]\n  },\n  [\"Dim\" /* Dim */]: {\n    facelets: [dim, dim, dim, dim, dim]\n  },\n  [\"Ignoriented\" /* Ignoriented */]: {\n    facelets: [dim, ignored, ignored, ignored, ignored]\n  },\n  [\"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */]: {\n    facelets: [oriented, ignored, ignored, ignored, ignored]\n  }\n};\nfunction getPieceStickeringMask(pieceStickering) {\n  return pieceStickerings[pieceStickering];\n}\nvar PuzzleStickering = class extends PieceAnnotation {\n  constructor(kpuzzle) {\n    super(kpuzzle, \"Regular\" /* Regular */);\n  }\n  set(pieceSet, pieceStickering) {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)[i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n  toStickeringMask() {\n    const stickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings2] of this.stickerings.entries()) {\n      const pieces = [];\n      const orbitStickeringMask = {\n        pieces\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings2) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n};\nvar StickeringManager = class {\n  constructor(kpuzzle) {\n    this.kpuzzle = kpuzzle;\n  }\n  and(pieceSets) {\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits\n    )) {\n      pieceLoop:\n        for (let i = 0; i < orbitDef.numPieces; i++) {\n          newPieceSet.stickerings.get(orbitName)[i] = true;\n          for (const pieceSet of pieceSets) {\n            if (!pieceSet.stickerings.get(orbitName)[i]) {\n              newPieceSet.stickerings.get(orbitName)[i] = false;\n              continue pieceLoop;\n            }\n          }\n        }\n    }\n    return newPieceSet;\n  }\n  or(pieceSets) {\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits\n    )) {\n      pieceLoop:\n        for (let i = 0; i < orbitDef.numPieces; i++) {\n          newPieceSet.stickerings.get(orbitName)[i] = false;\n          for (const pieceSet of pieceSets) {\n            if (pieceSet.stickerings.get(orbitName)[i]) {\n              newPieceSet.stickerings.get(orbitName)[i] = true;\n              continue pieceLoop;\n            }\n          }\n        }\n    }\n    return newPieceSet;\n  }\n  not(pieceSet) {\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)[i] = !pieceSet.stickerings.get(orbitName)[i];\n      }\n    }\n    return newPieceSet;\n  }\n  all() {\n    return this.and(this.moves([]));\n  }\n  move(moveSource) {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (transformation.transformationData[orbitName].permutation[i] !== i || transformation.transformationData[orbitName].orientation[i] !== 0) {\n          newPieceSet.stickerings.get(orbitName)[i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n  moves(moveSources) {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n  orbits(orbitNames) {\n    const pieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName).fill(true);\n    }\n    return pieceSet;\n  }\n  orbitPrefix(orbitPrefix) {\n    const pieceSet = new PieceAnnotation(this.kpuzzle, false);\n    for (const orbitName in this.kpuzzle.definition.orbits) {\n      if (orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitName).fill(true);\n      }\n    }\n    return pieceSet;\n  }\n};\n\n// src/cubing/puzzles/stickerings/puzzle-stickerings.ts\nvar experimentalStickerings = {\n  full: { groups: { \"3x3x3\": \"Stickering\" } },\n  OLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  PLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  LL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  EOLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  COLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  OCLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  CPLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  CLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  ELL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  ZBLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  LS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  ELS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  CLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  ZBLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  VLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  WVLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\"\n    }\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\"\n    }\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } }\n};\n\n// src/cubing/puzzles/stickerings/cube-like-stickerings.ts\nasync function cubeLikeStickeringMask(puzzleLoader, stickering) {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n  const LL = () => m.move(\"U\");\n  const orUD = () => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = () => m.or(m.moves([\"L\", \"R\"]));\n  const M = () => m.not(orLR());\n  const F2L = () => m.not(LL());\n  const CENTERS = () => m.orbitPrefix(\"CENTER\");\n  const EDGES = () => m.orbitPrefix(\"EDGE\");\n  const CORNERS = () => m.or([\n    m.orbitPrefix(\"CORNER\"),\n    m.orbitPrefix(\"C4RNER\"),\n    m.orbitPrefix(\"C5RNER\")\n  ]);\n  const L6E = () => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = () => m.and([LL(), CENTERS()]);\n  const edgeFR = () => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = () => m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = () => m.or([cornerDFR(), edgeFR()]);\n  function dimF2L() {\n    puzzleStickering.set(F2L(), \"Dim\" /* Dim */);\n  }\n  function setPLL() {\n    puzzleStickering.set(LL(), \"PermuteNonPrimary\" /* PermuteNonPrimary */);\n    puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n  }\n  function setOLL() {\n    puzzleStickering.set(LL(), \"IgnoreNonPrimary\" /* IgnoreNonPrimary */);\n    puzzleStickering.set(centerLL(), \"Regular\" /* Regular */);\n  }\n  function dimOLL() {\n    puzzleStickering.set(LL(), \"Ignoriented\" /* Ignoriented */);\n    puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n  }\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(LL(), \"Ignoriented\" /* Ignoriented */);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        \"IgnoreNonPrimary\" /* IgnoreNonPrimary */\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Ignored\" /* Ignored */);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), \"Ignoriented\" /* Ignoriented */);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Regular\" /* Regular */);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        \"IgnoreNonPrimary\" /* IgnoreNonPrimary */\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        \"Ignoriented\" /* Ignoriented */\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        \"Dim\" /* Dim */\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), EDGES()]), \"Regular\" /* Regular */);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(edgeFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(cornerDFR(), \"Ignored\" /* Ignored */);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), \"Ignored\" /* Ignored */);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), \"PermuteNonPrimary\" /* PermuteNonPrimary */);\n      puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Regular\" /* Regular */);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Ignored\" /* Ignored */);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(m.and([LL(), EDGES()]), \"Ignoriented\" /* Ignoriented */);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), \"Dim\" /* Dim */);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        \"IgnoreNonPrimary\" /* IgnoreNonPrimary */\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), \"Regular\" /* Regular */);\n      puzzleStickering.set(LL(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(centerLL(), \"Dim\" /* Dim */);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(\n        EDGES(),\n        \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(\n        EDGES(),\n        \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), \"Regular\" /* Regular */);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */\n      );\n      puzzleStickering.set(m.move(\"D\"), \"Regular\" /* Regular */);\n      puzzleStickering.set(CORNERS(), \"Ignored\" /* Ignored */);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), \"Dim\" /* Dim */);\n      puzzleStickering.set(L6E(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), \"Regular\" /* Regular */);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), \"Dim\" /* Dim */);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), \"Regular\" /* Regular */);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), \"Dim\" /* Dim */);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), \"Dim\" /* Dim */);\n      puzzleStickering.set(\n        L6E(),\n        \"OrientationWithoutPermutation\" /* OrientationWithoutPermutation */\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        \"OrientationStickers\" /* OrientationStickers */\n      );\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(CENTERS(), \"Dim\" /* Dim */);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        \"Regular\" /* Regular */\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        \"IgnoreNonPrimary\" /* IgnoreNonPrimary */\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(CENTERS(), \"Dim\" /* Dim */);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        \"Regular\" /* Regular */\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        \"Regular\" /* Regular */\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        \"Ignored\" /* Ignored */\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        \"Dim\" /* Dim */\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), \"Dim\" /* Dim */);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        \"Ignored\" /* Ignored */\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        \"Dim\" /* Dim */\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        \"Regular\" /* Regular */\n      );\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        \"Dim\" /* Dim */\n      );\n      puzzleStickering.set(m.not(CENTERS()), \"Ignored\" /* Ignored */);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), \"Ignored\" /* Ignored */);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        \"PermuteNonPrimary\" /* PermuteNonPrimary */\n      );\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), \"Invisible\" /* Invisible */);\n      break;\n    }\n    case \"picture\":\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), \"Invisible\" /* Invisible */);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), \"Ignored\" /* Ignored */);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`\n      );\n      puzzleStickering.set(m.and(m.moves([])), \"Dim\" /* Dim */);\n  }\n  return puzzleStickering.toStickeringMask();\n}\nasync function cubeStickerings(puzzleID) {\n  const stickerings = [];\n  const stickeringsFallback = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (\"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n\n// src/cubing/puzzles/async/lazy-cached.ts\nfunction getCached(getValue) {\n  let cachedPromise = null;\n  return () => {\n    return cachedPromise ?? (cachedPromise = getValue());\n  };\n}\n\n// src/cubing/vendor/mit/p-lazy/p-lazy.ts\nvar PLazy = class extends Promise {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n    this._executor = executor;\n  }\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n    return this._promise.then(onFulfilled, onRejected);\n  }\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n    return this._promise.catch(onRejected);\n  }\n};\nfunction from(function_) {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n\n// src/cubing/puzzles/async/async-pg3d.ts\nasync function asyncGetPuzzleGeometry(puzzleName) {\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true\n  });\n}\nasync function asyncGetKPuzzle(pgPromise, puzzleName) {\n  const pg = await pgPromise;\n  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true)\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation\n  });\n}\nvar PGPuzzleLoader = class {\n  constructor(info) {\n    this.puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n      this.kpuzzle.bind(this)\n    );\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n  #cachedPG;\n  pg() {\n    return this.#cachedPG ?? (this.#cachedPG = asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n  #cachedKPuzzle;\n  kpuzzle() {\n    return this.#cachedKPuzzle ?? (this.#cachedKPuzzle = asyncGetKPuzzle(this.pg(), this.id));\n  }\n  #cachedSVG;\n  svg() {\n    return this.#cachedSVG ?? (this.#cachedSVG = (async () => (await this.pg()).generatesvg())());\n  }\n};\nvar CubePGPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super(...arguments);\n    this.stickerings = () => cubeStickerings(this.id);\n  }\n  stickeringMask(stickering) {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n};\nfunction puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn) {\n  return new PLazy(\n    async (resolve) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      console.log(kpuzzle);\n      resolve({\n        quantumMoveOrder: (m) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        }\n      });\n    }\n  );\n}\n\n// src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts\nvar cube3x3x3KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 }\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0]\n    }\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0]\n      }\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3]\n      }\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2]\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2]\n      }\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0]\n      }\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0]\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0]\n      }\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0]\n      }\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0]\n      }\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1]\n      }\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1]\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1]\n      }\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0]\n      }\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0]\n      }\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1]\n      }\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0]\n      }\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0]\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0]\n      }\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0]\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1]\n      }\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2]\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2]\n      }\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1]\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3]\n      }\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0]\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1]\n      }\n    }\n  }\n};\ncube3x3x3KPuzzleDefinition.experimentalDerivedMoves = {\n  Uw: \"u\",\n  Lw: \"l\",\n  Fw: \"f\",\n  Rw: \"r\",\n  Bw: \"b\",\n  Dw: \"d\",\n  Uv: \"y\",\n  Lv: \"x'\",\n  Fv: \"z\",\n  Rv: \"x\",\n  Bv: \"z'\",\n  Dv: \"y'\",\n  \"2U\": \"u U'\",\n  \"2L\": \"l L'\",\n  \"2F\": \"f F'\",\n  \"2R\": \"r R'\",\n  \"2B\": \"b B'\",\n  \"2D\": \"d D'\"\n};\n\n// src/cubing/puzzles/PuzzleLoader.ts\nasync function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(puzzleLoader) {\n  const puzzleSpecificSimplifyOptions = await (puzzleLoader.puzzleSpecificSimplifyOptions ?? puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n\n// src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts\nfunction puzzleOrientation2x2x2Idx(state) {\n  const inverse = state.experimentalToTransformation().invert();\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientation[6];\n}\nvar puzzleOrientationCacheRaw = new Array(24);\nvar puzzleOrientationCacheInitialized = false;\nfunction puzzleOrientation2x2x2Cache(kpuzzle) {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map(\n        (s) => Alg.fromString(s)\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKState());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg)\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\nfunction normalize2x2x2Orientation(state) {\n  const idx = puzzleOrientation2x2x2Idx(state);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(state.kpuzzle)[idx];\n  return {\n    normalizedState: state.applyTransformation(transformation),\n    normalizationAlg: alg.invert()\n  };\n}\n\n// src/cubing/puzzles/customPGPuzzleLoader.ts\nasync function descAsyncGetPuzzleGeometry(desc) {\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true\n  });\n}\nasync function asyncGetKPuzzle2(desc) {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true)\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation\n  });\n}\nvar nextCustomID = 1;\nfunction customPGPuzzleLoader(desc, info) {\n  const customID = nextCustomID++;\n  let cachedKPuzzle = null;\n  const kpuzzlePromiseFn = async () => {\n    return cachedKPuzzle ?? (cachedKPuzzle = asyncGetKPuzzle2(desc));\n  };\n  const puzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    puzzleSpecificSimplifyOptionsPromise: puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn)\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n\n// src/cubing/puzzles/cubing-private/index.ts\nvar experimental3x3x3KPuzzle = new KPuzzle(\n  cube3x3x3KPuzzleDefinition\n);\ncube3x3x3KPuzzleDefinition.experimentalIsStateSolved = experimentalIs3x3x3Solved;\n\n// src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts\nfunction puzzleOrientation3x3x3Idx(state) {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\nvar puzzleOrientationCacheRaw2 = new Array(6).fill(0).map(() => {\n  return new Array(6);\n});\nvar puzzleOrientationCacheInitialized2 = false;\nfunction puzzleOrientation3x3x3Cache() {\n  if (!puzzleOrientationCacheInitialized2) {\n    {\n      const uAlgs = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map(\n        (s) => Alg.fromString(s)\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKState()\n          );\n          puzzleOrientationCacheRaw2[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw2;\n}\nfunction normalize3x3x3Orientation(state) {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\nfunction experimentalIs3x3x3Solved(state, options) {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0)\n      }\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation();\n}\n\nexport {\n  getFaceletStickeringMask,\n  getPieceStickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n  cubeLikeStickeringMask,\n  cubeStickerings,\n  getCached,\n  from,\n  asyncGetPuzzleGeometry,\n  PGPuzzleLoader,\n  CubePGPuzzleLoader,\n  puzzleOrientation3x3x3Idx,\n  puzzleOrientation3x3x3Cache,\n  normalize3x3x3Orientation,\n  getPartialAppendOptionsForPuzzleSpecificSimplifyOptions,\n  normalize2x2x2Orientation,\n  customPGPuzzleLoader,\n  experimental3x3x3KPuzzle\n};\n//# sourceMappingURL=chunk-4F4IORIH.js.map\n","// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// We specify 5 facelets, because that's the maximum we need for any built-in puzzles (e.g. Megaminx centers or icosa vertices).\n// TODO: use \"primary\" and \"non-primary\" fields instead of listing all non-primary facelets.\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible, invisible],\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName in this.kpuzzle.definition.orbits) {\n      if (orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n","import type { PuzzleID } from \"../../twisty\";\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\" } }, // default\n  OLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  PLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  LL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  EOLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  COLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  OCLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  CPLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  CLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  ELL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  ZBLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  LS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  ELS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  CLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  ZBLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  VLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  WVLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\",\n    },\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\",\n    },\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n","import type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PieceSet,\n  PieceStickering,\n  StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\n// TODO: cache calculations?\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        PieceStickering.Ignoriented,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // For PG\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function cubeStickerings(\n  puzzleID: PuzzleID,\n): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  const stickeringsFallback: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (\"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n","export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n","// @ts-nocheck\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n","import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport {\n  cubeLikeStickeringMask,\n  cubeStickerings,\n} from \"../stickerings/cube-like-stickerings\";\nimport { getCached } from \"./lazy-cached\";\nimport { Move, PuzzleSpecificSimplifyOptions, QuantumMove } from \"../../alg\";\nimport { PLazy } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = () => cubeStickerings(this.id as PuzzleID);\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      console.log(kpuzzle);\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n","import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.experimentalDerivedMoves = {\n  Uw: \"u\",\n  Lw: \"l\",\n  Fw: \"f\",\n  Rw: \"r\",\n  Bw: \"b\",\n  Dw: \"d\",\n\n  Uv: \"y\",\n  Lv: \"x'\",\n  Fv: \"z\",\n  Rv: \"x\",\n  Bv: \"z'\",\n  Dv: \"y'\",\n\n  \"2U\": \"u U'\",\n  \"2L\": \"l L'\",\n  \"2F\": \"f F'\",\n  \"2R\": \"r R'\",\n  \"2B\": \"b B'\",\n  \"2D\": \"d D'\",\n};\n","import type { PuzzleSpecificSimplifyOptions } from \"../alg\";\nimport type { AppendOptions } from \"../alg/simplify\";\nimport type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../twisty\";\nimport type { StickeringMask } from \"./stickerings/mask\";\n\nexport interface PuzzleLoader {\n  id: string;\n  // shortName?: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number; // TODO: date?\n  /** @deprecated */\n  def?: never;\n  kpuzzle: () => Promise<KPuzzle>; // TODO\n  svg: () => Promise<string>;\n  llSVG?: () => Promise<string>;\n  pg?: () => Promise<PuzzleGeometry>;\n  stickeringMask?: (\n    stickering: ExperimentalStickering,\n  ) => Promise<StickeringMask>;\n  stickerings?: () => Promise<ExperimentalStickering[]>;\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  puzzleSpecificSimplifyOptionsPromise?: Promise<PuzzleSpecificSimplifyOptions>; // TODO\n}\n\n// TODO: consolidate the `puzzleSpecificSimplifyOptionsPromise` with `puzzleSpecificSimplifyOptions` somehow, so that we don't have to do this.\nexport async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(\n  puzzleLoader: PuzzleLoader,\n): Promise<AppendOptions> {\n  const puzzleSpecificSimplifyOptions =\n    await (puzzleLoader.puzzleSpecificSimplifyOptions ??\n      puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n","import { Alg } from \"../../../../alg\";\nimport type { KPuzzle, KState, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(state: KState): number {\n  const inverse = state.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientation[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKState());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(state: KState): {\n  normalizedState: KState;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(state);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(state.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedState: state.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize2x2x2Orientation(state).normalizedState;\n  }\n  return !!state.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n","import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport { puzzleSpecificSimplifyOptionsPromise } from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n","import { KPuzzle } from \"../../kpuzzle\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { getPartialAppendOptionsForPuzzleSpecificSimplifyOptions } from \"../PuzzleLoader\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsStateSolved =\n  experimentalIs3x3x3Solved;\n\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\n\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport { getFaceletStickeringMask as experimentalGetFaceletStickeringMask } from \"../stickerings/mask\";\nexport type {\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\n","import { Alg } from \"../../../../alg\";\nimport { KState, KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(state: KState): [number, number] {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKState(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(state: KState): KState {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n","import {\n  Alg,\n  Move,\n  TraversalDownUp,\n  functionFromTraversal\n} from \"./chunk-VZP3KFTU.js\";\n\n// src/cubing/kpuzzle/combine.ts\nfunction combineTransformationData(definition, transformationData1, transformationData2) {\n  const newTransformationData = {};\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (isOrbitTransformationDataIdentityUncached(\n      orbitDefinition.numOrientations,\n      orbit2\n    )) {\n      newTransformationData[orbitName] = orbit1;\n    } else if (isOrbitTransformationDataIdentityUncached(\n      orbitDefinition.numOrientations,\n      orbit1\n    )) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\nfunction applyTransformationDataToStateData(definition, stateData, transformationData) {\n  const newStateData = {};\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (isOrbitTransformationDataIdentityUncached(\n      orbitDefinition.numOrientations,\n      orbit2\n    )) {\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n\n// src/cubing/kpuzzle/construct.ts\nvar FREEZE = false;\nvar identityOrbitCache = /* @__PURE__ */ new Map();\nfunction constructIdentityOrbitTransformation(numPieces) {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation);\n    Object.freeze(newOrientation);\n    Object.freeze(orbitTransformation);\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\nfunction constructIdentityTransformationDataUncached(definition) {\n  const transformation = {};\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation);\n  }\n  return transformation;\n}\nfunction moveToTransformationUncached(kpuzzle, move) {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey];\n  if (!quantumMoveDefinition) {\n    const derivedFrom = kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n    if (derivedFrom) {\n      quantumMoveDefinition = kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount\n    );\n  }\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n  const inverseMoveDefinition = kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n\n// src/cubing/kpuzzle/KState.ts\nvar KState = class {\n  constructor(kpuzzle, stateData) {\n    this.kpuzzle = kpuzzle;\n    this.stateData = stateData;\n  }\n  toJSON() {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData\n    };\n  }\n  static fromTransformation(transformation) {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n  apply(source) {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n  applyTransformation(transformation) {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n  applyMove(move) {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n  applyAlg(alg) {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n  experimentalToTransformation() {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n  experimentalIsSolved(options) {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\n        \"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\"\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n};\n\n// src/cubing/kpuzzle/KTransformation.ts\nvar KTransformation = class {\n  constructor(kpuzzle, transformationData) {\n    this.kpuzzle = kpuzzle;\n    this.transformationData = transformationData;\n  }\n  toJSON() {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData\n    };\n  }\n  invert() {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData)\n    );\n  }\n  #cachedIsIdentity;\n  isIdentityTransformation() {\n    return this.#cachedIsIdentity ?? (this.#cachedIsIdentity = this.isIdentical(\n      this.kpuzzle.identityTransformation()\n    ));\n  }\n  static experimentalConstructIdentity(kpuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition)\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n  isIdentical(t2) {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData\n    );\n  }\n  apply(source) {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n  applyTransformation(t2) {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`\n      );\n    }\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData\n      )\n    );\n  }\n  applyMove(move) {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n  applyAlg(alg) {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n  toKState() {\n    return KState.fromTransformation(this);\n  }\n  repetitionOrder() {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n  selfMultiply(amount) {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount\n      )\n    );\n  }\n};\n\n// src/cubing/kpuzzle/calculate.ts\nfunction isOrbitTransformationDataIdentityUncached(numOrientations, orbitTransformationData) {\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction isOrbitTransformationDataIdentical(orbitDefinition, orbitTransformationData1, orbitTransformationData2, options = {}) {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (!options?.ignoreOrientation && orbitTransformationData1.orientation[idx] !== orbitTransformationData2.orientation[idx]) {\n      return false;\n    }\n    if (!options?.ignorePermutation && orbitTransformationData1.permutation[idx] !== orbitTransformationData2.permutation[idx]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isTransformationDataIdentical(kpuzzle, transformationData1, transformationData2) {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits\n  )) {\n    if (!isOrbitTransformationDataIdentical(\n      orbitDefinition,\n      transformationData1[orbitName],\n      transformationData2[orbitName]\n    )) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction invertTransformation(kpuzzle, transformationData) {\n  const newTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition = kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (isOrbitTransformationDataIdentityUncached(\n      orbitDefinition.numOrientations,\n      orbitTransformationData\n    )) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] = (orbitDefinition.numOrientations - orbitTransformationData.orientation[idx] + orbitDefinition.numOrientations) % orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri\n      };\n    }\n  }\n  return newTransformationData;\n}\nfunction repeatTransformationUncached(kpuzzle, transformationData, amount) {\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount\n    );\n  }\n  if (amount === 0) {\n    const { transformationData: transformationData2 } = kpuzzle.identityTransformation();\n    return transformationData2;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2)\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish\n    );\n  }\n}\nvar AlgToTransformationTraversal = class extends TraversalDownUp {\n  traverseAlg(alg, kpuzzle) {\n    let transformation = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle)\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping, kpuzzle) {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount\n      )\n    );\n  }\n  traverseMove(move, kpuzzle) {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(commutator, kpuzzle) {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert()).applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate, kpuzzle) {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert());\n  }\n  traversePause(_, kpuzzle) {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_, kpuzzle) {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_, kpuzzle) {\n    return kpuzzle.identityTransformation();\n  }\n};\nvar algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal\n);\nfunction gcd(a, b) {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\nfunction transformationRepetitionOrder(definition, transformation) {\n  let order = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (; ; ) {\n          orbitPieces[currentIdx] = true;\n          orientationSum = orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength = cycleLength * orbitDefinition.numOrientations / gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = order * cycleLength / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n\n// src/cubing/kpuzzle/KPuzzle.ts\nvar KPuzzle = class {\n  constructor(definition, options) {\n    this.definition = definition;\n    this.#moveToTransformationDataCache = /* @__PURE__ */ new Map();\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n  name() {\n    return this.definition.name;\n  }\n  identityTransformation() {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n  #moveToTransformationDataCache;\n  moveToTransformation(move) {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData = this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n    if (this.experimentalPGNotation) {\n      const transformationData2 = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData2) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData2);\n      return new KTransformation(this, transformationData2);\n    }\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n  algToTransformation(alg) {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n  toTransformation(source) {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if (source?.is?.(Alg)) {\n      return this.algToTransformation(source);\n    } else if (source?.is?.(Move)) {\n      return this.moveToTransformation(source);\n    } else {\n      return source;\n    }\n  }\n  startState() {\n    return new KState(this, this.definition.startStateData);\n  }\n  #cachedCanConvertStateToUniqueTransformation;\n  canConvertStateToUniqueTransformation() {\n    return this.#cachedCanConvertStateToUniqueTransformation ?? (this.#cachedCanConvertStateToUniqueTransformation = (() => {\n      for (const [orbitName, orbitDefinition] of Object.entries(\n        this.definition.orbits\n      )) {\n        const pieces = new Array(orbitDefinition.numPieces).fill(false);\n        for (const piece of this.definition.startStateData[orbitName].pieces) {\n          pieces[piece] = true;\n        }\n        for (const piece of pieces) {\n          if (!piece) {\n            return false;\n          }\n        }\n      }\n      return true;\n    })());\n  }\n};\n\nexport {\n  KState,\n  KTransformation,\n  KPuzzle\n};\n//# sourceMappingURL=chunk-KLI2E737.js.map\n","import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n","import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n","import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KStateData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\n        \"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n}\n","import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n","import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n","import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n","// src/cubing/alg/common.ts\nvar writeAlgDebugField = false;\nvar Comparable = class {\n  is(c) {\n    return this instanceof c;\n  }\n  as(c) {\n    return this instanceof c ? this : null;\n  }\n};\nvar AlgCommon = class extends Comparable {\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        }\n      });\n    }\n  }\n  get log() {\n    return console.log.bind(console, this, this.toString());\n  }\n};\n\n// src/cubing/alg/iteration.ts\nfunction toggleDirection(iterationDirection, flip = true) {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case 1 /* Forwards */:\n      return -1 /* Backwards */;\n    case -1 /* Backwards */:\n      return 1 /* Forwards */;\n  }\n}\nfunction direct(g, iterDir) {\n  return iterDir === -1 /* Backwards */ ? Array.from(g).reverse() : g;\n}\nfunction reverse(g) {\n  return Array.from(g).reverse();\n}\nfunction* directedGenerator(g, direction) {\n  direction === -1 /* Backwards */ ? yield* reverseGenerator(g) : yield* g;\n}\nfunction* reverseGenerator(g) {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n\n// src/cubing/alg/limits.ts\nvar MAX_INT = 2147483647;\nvar MAX_INT_DESCRIPTION = \"2^31 - 1\";\nvar MIN_INT = -2147483648;\n\n// src/cubing/alg/AlgBuilder.ts\nvar AlgBuilder = class {\n  #algNode = [];\n  push(u) {\n    this.#algNode.push(u);\n  }\n  experimentalPushAlg(alg) {\n    for (const u of alg.childAlgNodes()) {\n      this.push(u);\n    }\n  }\n  experimentalNumAlgNodes() {\n    return this.#algNode.length;\n  }\n  toAlg() {\n    return new Alg(this.#algNode);\n  }\n  reset() {\n    this.#algNode = [];\n  }\n};\n\n// src/cubing/alg/debug.ts\nvar algDebugGlobals = {\n  caretNISSNotationEnabled: true\n};\nfunction setAlgDebug(options) {\n  if (\"caretNISSNotationEnabled\" in options) {\n    algDebugGlobals.caretNISSNotationEnabled = !!options.caretNISSNotationEnabled;\n  }\n}\n\n// src/cubing/alg/alg-nodes/containers/Commutator.ts\nvar Commutator = class extends AlgCommon {\n  #A;\n  #B;\n  constructor(aSource, bSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n  get A() {\n    return this.#A;\n  }\n  get B() {\n    return this.#B;\n  }\n  isIdentical(other) {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(otherAsCommutator?.A.isIdentical(this.A) && otherAsCommutator?.B.isIdentical(this.B));\n  }\n  invert() {\n    return new Commutator(this.#B, this.#A);\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {\n    depth ?? (depth = Infinity);\n    if (depth === 0) {\n      yield iterDir === 1 /* Forwards */ ? this : this.invert();\n    } else {\n      if (iterDir === 1 /* Forwards */) {\n        yield* this.A.experimentalExpand(\n          1 /* Forwards */,\n          depth - 1\n        );\n        yield* this.B.experimentalExpand(\n          1 /* Forwards */,\n          depth - 1\n        );\n        yield* this.A.experimentalExpand(\n          -1 /* Backwards */,\n          depth - 1\n        );\n        yield* this.B.experimentalExpand(\n          -1 /* Backwards */,\n          depth - 1\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          1 /* Forwards */,\n          depth - 1\n        );\n        yield* this.A.experimentalExpand(\n          1 /* Forwards */,\n          depth - 1\n        );\n        yield* this.B.experimentalExpand(\n          -1 /* Backwards */,\n          depth - 1\n        );\n        yield* this.A.experimentalExpand(\n          -1 /* Backwards */,\n          depth - 1\n        );\n      }\n    }\n  }\n  toString() {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n};\n\n// src/cubing/alg/alg-nodes/containers/Conjugate.ts\nvar Conjugate = class extends AlgCommon {\n  #A;\n  #B;\n  constructor(aSource, bSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n  get A() {\n    return this.#A;\n  }\n  get B() {\n    return this.#B;\n  }\n  isIdentical(other) {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(otherAsConjugate?.A.isIdentical(this.A) && otherAsConjugate?.B.isIdentical(this.B));\n  }\n  invert() {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n  *experimentalExpand(iterDir, depth) {\n    depth ?? (depth = Infinity);\n    if (depth === 0) {\n      yield iterDir === 1 /* Forwards */ ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);\n    }\n  }\n  toString() {\n    return `[${this.A}: ${this.B}]`;\n  }\n};\n\n// src/cubing/alg/alg-nodes/leaves/LineComment.ts\nvar LineComment = class extends AlgCommon {\n  #text;\n  constructor(commentText) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n  get text() {\n    return this.#text;\n  }\n  isIdentical(other) {\n    const otherAsLineComment = other;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n  invert() {\n    return this;\n  }\n  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {\n    yield this;\n  }\n  toString() {\n    return `//${this.#text}`;\n  }\n};\n\n// src/cubing/alg/alg-nodes/leaves/Newline.ts\nvar Newline = class extends AlgCommon {\n  toString() {\n    return \"\\n\";\n  }\n  isIdentical(other) {\n    return other.is(Newline);\n  }\n  invert() {\n    return this;\n  }\n  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {\n    yield this;\n  }\n};\n\n// src/cubing/alg/alg-nodes/leaves/Pause.ts\nvar Pause = class extends AlgCommon {\n  toString() {\n    return \".\";\n  }\n  isIdentical(other) {\n    return other.is(Pause);\n  }\n  invert() {\n    return this;\n  }\n  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {\n    yield this;\n  }\n};\n\n// src/cubing/alg/parseAlg.ts\nfunction parseIntWithEmptyFallback(n, emptyFallback) {\n  return n ? parseInt(n) : emptyFallback;\n}\nvar AMOUNT_REGEX = /^(\\d+)?('?)/;\nvar MOVE_START_REGEX = /^[_\\dA-Za-z]/;\nvar QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nvar COMMENT_TEXT_REGEX = /^[^\\n]*/;\nvar SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/;\nvar SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/;\nfunction parseAlg(s) {\n  return new AlgParser().parseAlg(s);\n}\nfunction parseMove(s) {\n  return new AlgParser().parseMove(s);\n}\nfunction parseQuantumMove(s) {\n  return new AlgParser().parseQuantumMove(s);\n}\nfunction addCharIndices(t, startCharIndex, endCharIndex) {\n  const parsedT = t;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\nfunction transferCharIndex(from, to) {\n  if (\"startCharIndex\" in from) {\n    to.startCharIndex = from.startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    to.endCharIndex = from.endCharIndex;\n  }\n  return to;\n}\nvar AlgParser = class {\n  #input = \"\";\n  #idx = 0;\n  #nissQueue = [];\n  parseAlg(input) {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const algNodes = Array.from(alg.childAlgNodes());\n    if (this.#nissQueue.length > 0) {\n      for (const nissGrouping of this.#nissQueue.reverse()) {\n        algNodes.push(nissGrouping);\n      }\n    }\n    const newAlg = new Alg(algNodes);\n    const { startCharIndex, endCharIndex } = alg;\n    addCharIndices(newAlg, startCharIndex, endCharIndex);\n    return newAlg;\n  }\n  parseMove(input) {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n  parseQuantumMove(input) {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n  mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n  parseAlgWithStopping(stopBefore) {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n    let crowded = false;\n    const mustNotBeCrowded = (idx) => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`\n        );\n      }\n    };\n    mainLoop:\n      while (this.#idx < this.#input.length) {\n        const savedCharIndex = this.#idx;\n        if (stopBefore.includes(this.#input[this.#idx])) {\n          return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n        }\n        if (this.tryConsumeNext(\" \")) {\n          crowded = false;\n          if (algBuilder.experimentalNumAlgNodes() === 0) {\n            algStartIdx = this.#idx;\n          }\n          continue mainLoop;\n        } else if (MOVE_START_REGEX.test(this.#input[this.#idx])) {\n          mustNotBeCrowded(savedCharIndex);\n          const move = this.parseMoveImpl();\n          algBuilder.push(move);\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else if (this.tryConsumeNext(\"(\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n          if (sq1PairStartMatch) {\n            const topAmountString = sq1PairStartMatch[1];\n            const savedCharIndexD = this.#idx;\n            const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n            const uMove = addCharIndices(\n              new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n              savedCharIndex + 1,\n              savedCharIndex + 1 + topAmountString.length\n            );\n            const dMove = addCharIndices(\n              new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n              savedCharIndexD,\n              this.#idx - 1\n            );\n            const alg = addCharIndices(\n              new Alg([uMove, dMove]),\n              savedCharIndex + 1,\n              this.#idx - 1\n            );\n            algBuilder.push(\n              addCharIndices(new Grouping(alg), savedCharIndex, this.#idx)\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          } else {\n            const alg = this.parseAlgWithStopping([\")\"]);\n            this.mustConsumeNext(\")\");\n            const amount = this.parseAmount();\n            algBuilder.push(\n              addCharIndices(\n                new Grouping(alg, amount),\n                savedCharIndex,\n                this.#idx\n              )\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          }\n        } else if (this.tryConsumeNext(\"^\")) {\n          if (!algDebugGlobals.caretNISSNotationEnabled) {\n            throw new Error(\n              \"Alg contained a caret but caret NISS notation is not enabled.\"\n            );\n          }\n          this.mustConsumeNext(\"(\");\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.popNext();\n          const grouping = new Grouping(alg, -1);\n          const placeholder = new Pause();\n          grouping.experimentalNISSPlaceholder = placeholder;\n          placeholder.experimentalNISSGrouping = grouping;\n          this.#nissQueue.push(grouping);\n          algBuilder.push(placeholder);\n        } else if (this.tryConsumeNext(\"[\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const A = this.parseAlgWithStopping([\",\", \":\"]);\n          const separator = this.popNext();\n          const B = this.parseAlgWithStopping([\"]\"]);\n          this.mustConsumeNext(\"]\");\n          switch (separator) {\n            case \":\": {\n              algBuilder.push(\n                addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx)\n              );\n              crowded = true;\n              algEndIdx = this.#idx;\n              continue mainLoop;\n            }\n            case \",\": {\n              algBuilder.push(\n                addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx)\n              );\n              crowded = true;\n              algEndIdx = this.#idx;\n              continue mainLoop;\n            }\n            default:\n              throw new Error(\"unexpected parsing error\");\n          }\n        } else if (this.tryConsumeNext(\"\\n\")) {\n          algBuilder.push(\n            addCharIndices(new Newline(), savedCharIndex, this.#idx)\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else if (this.tryConsumeNext(\"/\")) {\n          if (this.tryConsumeNext(\"/\")) {\n            mustNotBeCrowded(savedCharIndex);\n            const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n            algBuilder.push(\n              addCharIndices(new LineComment(text), savedCharIndex, this.#idx)\n            );\n            crowded = false;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          } else {\n            algBuilder.push(\n              addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx)\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          }\n        } else if (this.tryConsumeNext(\".\")) {\n          mustNotBeCrowded(savedCharIndex);\n          algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          throw new Error(`Unexpected character: ${this.popNext()}`);\n        }\n      }\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n  parseQuantumMoveImpl() {\n    const [, , , outerLayerStr, innerLayerStr, family] = this.parseRegex(QUANTUM_MOVE_REGEX);\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, void 0),\n      parseIntWithEmptyFallback(outerLayerStr, void 0)\n    );\n  }\n  parseMoveImpl() {\n    const savedCharIndex = this.#idx;\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n    let quantumMove = this.parseQuantumMoveImpl();\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\"\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\"\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\"\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"}_`\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"}_`\n        });\n        amount *= -1;\n      }\n    }\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx\n    );\n    return move;\n  }\n  parseMoveSuffix() {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n  parseAmountAndTrackEmptyAbsAmount() {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr\n    ];\n  }\n  parseAmount() {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`\n      );\n    }\n    return parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1);\n  }\n  parseRegex(regex) {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\");\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n  tryRegex(regex) {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n  remaining() {\n    return this.#input.slice(this.#idx);\n  }\n  popNext() {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n  tryConsumeNext(expected) {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n  mustConsumeNext(expected) {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`\n      );\n    }\n    return next;\n  }\n};\n\n// src/cubing/alg/warnOnce.ts\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(s) {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n\n// src/cubing/alg/alg-nodes/QuantumWithAmount.ts\nvar QuantumWithAmount = class {\n  constructor(quantum, amount = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n    if (!Number.isInteger(this.amount) || this.amount < MIN_INT || this.amount > MAX_INT) {\n      throw new Error(\n        `AlgNode amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`\n      );\n    }\n  }\n  suffix() {\n    let s = \"\";\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n  isIdentical(other) {\n    return this.quantum.isIdentical(other.quantum) && this.amount === other.amount;\n  }\n  *experimentalExpand(iterDir, depth) {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n};\n\n// src/cubing/alg/alg-nodes/leaves/Move.ts\nvar QuantumMove = class extends Comparable {\n  #family;\n  #innerLayer;\n  #outerLayer;\n  constructor(family, innerLayer, outerLayer) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n    if (this.#innerLayer !== null && (!Number.isInteger(this.#innerLayer) || this.#innerLayer < 1 || this.#innerLayer > MAX_INT)) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`\n      );\n    }\n    if (this.#outerLayer !== null && (!Number.isInteger(this.#outerLayer) || this.#outerLayer < 1 || this.#outerLayer > MAX_INT)) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`\n      );\n    }\n    if (this.#outerLayer !== null && this.#innerLayer !== null && this.#innerLayer <= this.#outerLayer) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\"\n      );\n    }\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\"\n      );\n    }\n  }\n  static fromString(s) {\n    return parseQuantumMove(s);\n  }\n  modified(modifications) {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer\n    );\n  }\n  isIdentical(other) {\n    const otherAsQuantumMove = other;\n    return other.is(QuantumMove) && this.#family === otherAsQuantumMove.#family && this.#innerLayer === otherAsQuantumMove.#innerLayer && this.#outerLayer === otherAsQuantumMove.#outerLayer;\n  }\n  get family() {\n    return this.#family;\n  }\n  get outerLayer() {\n    return this.#outerLayer;\n  }\n  get innerLayer() {\n    return this.#innerLayer;\n  }\n  experimentalExpand() {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\"\n    );\n  }\n  toString() {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = `${String(this.#outerLayer)}-${s}`;\n      }\n    }\n    return s;\n  }\n};\nvar Move = class extends AlgCommon {\n  #quantumWithAmount;\n  constructor(...args) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1]\n        );\n        return;\n      } else {\n        return Move.fromString(args[0]);\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount(\n      args[0],\n      args[1]\n    );\n  }\n  isIdentical(other) {\n    const otherAsMove = other.as(Move);\n    return !!otherAsMove && this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount);\n  }\n  invert() {\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount)\n    );\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */) {\n    if (iterDir === 1 /* Forwards */) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount\n      });\n    }\n  }\n  get quantum() {\n    return this.#quantumWithAmount.quantum;\n  }\n  modified(modifications) {\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount\n    );\n  }\n  static fromString(s) {\n    return parseMove(s);\n  }\n  get amount() {\n    return this.#quantumWithAmount.amount;\n  }\n  get type() {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n  get family() {\n    return this.#quantumWithAmount.quantum.family ?? void 0;\n  }\n  get outerLayer() {\n    return this.#quantumWithAmount.quantum.outerLayer ?? void 0;\n  }\n  get innerLayer() {\n    return this.#quantumWithAmount.quantum.innerLayer ?? void 0;\n  }\n  toString() {\n    if (this.family === \"_SLASH_\") {\n      return \"/\";\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return this.#quantumWithAmount.quantum.toString().slice(0, -6) + Math.abs(this.amount) + (this.amount < 0 ? \"-\" : \"+\");\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return this.#quantumWithAmount.quantum.toString().slice(0, -10) + (absAmount === 1 ? \"\" : absAmount) + (this.amount < 0 ? \"--\" : \"++\");\n    }\n    return this.#quantumWithAmount.quantum.toString() + this.#quantumWithAmount.suffix();\n  }\n};\n\n// src/cubing/alg/alg-nodes/containers/Grouping.ts\nvar Square1TupleFormatter = class {\n  constructor() {\n    this.quantumU_SQ_ = null;\n    this.quantumD_SQ_ = null;\n  }\n  format(grouping) {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n  tuple(grouping) {\n    this.quantumU_SQ_ || (this.quantumU_SQ_ = new QuantumMove(\"U_SQ_\"));\n    this.quantumD_SQ_ || (this.quantumD_SQ_ = new QuantumMove(\"D_SQ_\"));\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumChildAlgNodes() === 2) {\n      const [U, D] = quantumAlg.childAlgNodes();\n      if (U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) && D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\"\n          );\n        }\n        return [U, D];\n      }\n    }\n    return null;\n  }\n};\nvar square1TupleFormatterInstance = new Square1TupleFormatter();\nvar Grouping = class extends AlgCommon {\n  constructor(algSource, amount) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n  #quantumWithAmount;\n  isIdentical(other) {\n    const otherAsGrouping = other;\n    return other.is(Grouping) && this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount);\n  }\n  get alg() {\n    return this.#quantumWithAmount.quantum;\n  }\n  get amount() {\n    return this.#quantumWithAmount.amount;\n  }\n  get experimentalRepetitionSuffix() {\n    return this.#quantumWithAmount.suffix();\n  }\n  invert() {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount\n    );\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {\n    depth ?? (depth = Infinity);\n    if (depth === 0) {\n      yield iterDir === 1 /* Forwards */ ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n  static fromString() {\n    throw new Error(\"unimplemented\");\n  }\n  toString() {\n    return square1TupleFormatterInstance.format(this) ?? `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`;\n  }\n  experimentalAsSquare1Tuple() {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n};\n\n// src/cubing/alg/is.ts\nfunction experimentalIs(v, c) {\n  return v instanceof c;\n}\nfunction experimentalIsAlgNode(v) {\n  return experimentalIs(v, Grouping) || experimentalIs(v, LineComment) || experimentalIs(v, Commutator) || experimentalIs(v, Conjugate) || experimentalIs(v, Move) || experimentalIs(v, Newline) || experimentalIs(v, Pause);\n}\n\n// src/cubing/alg/traversal.ts\nfunction dispatch(t, algNode, dataDown) {\n  if (algNode.is(Grouping)) {\n    return t.traverseGrouping(algNode, dataDown);\n  }\n  if (algNode.is(Move)) {\n    return t.traverseMove(algNode, dataDown);\n  }\n  if (algNode.is(Commutator)) {\n    return t.traverseCommutator(algNode, dataDown);\n  }\n  if (algNode.is(Conjugate)) {\n    return t.traverseConjugate(algNode, dataDown);\n  }\n  if (algNode.is(Pause)) {\n    return t.traversePause(algNode, dataDown);\n  }\n  if (algNode.is(Newline)) {\n    return t.traverseNewline(algNode, dataDown);\n  }\n  if (algNode.is(LineComment)) {\n    return t.traverseLineComment(algNode, dataDown);\n  }\n  throw new Error(\"unknown AlgNode\");\n}\nfunction mustBeAlgNode(t) {\n  if (t.is(Grouping) || t.is(Move) || t.is(Commutator) || t.is(Conjugate) || t.is(Pause) || t.is(Newline) || t.is(LineComment)) {\n    return t;\n  }\n  throw new Error(\"internal error: expected AlgNode\");\n}\nvar TraversalDownUp = class {\n  traverseAlgNode(algNode, dataDown) {\n    return dispatch(this, algNode, dataDown);\n  }\n  traverseIntoAlgNode(algNode, dataDown) {\n    return mustBeAlgNode(this.traverseAlgNode(algNode, dataDown));\n  }\n};\nvar TraversalUp = class extends TraversalDownUp {\n  traverseAlgNode(algNode) {\n    return dispatch(\n      this,\n      algNode,\n      void 0\n    );\n  }\n  traverseIntoAlgNode(algNode) {\n    return mustBeAlgNode(this.traverseAlgNode(algNode));\n  }\n};\nfunction functionFromTraversal(traversalConstructor, constructorArgs) {\n  const instance = new traversalConstructor(\n    ...constructorArgs ?? []\n  );\n  return instance.traverseAlg.bind(instance);\n}\n\n// src/cubing/alg/simplify/options.ts\nvar DEFAULT_DIRECTIONAL = \"any-direction\";\nvar AppendOptionsHelper = class {\n  constructor(config = {}) {\n    this.config = config;\n  }\n  cancelQuantum() {\n    const { cancel } = this.config;\n    if (cancel === true) {\n      return DEFAULT_DIRECTIONAL;\n    }\n    if (cancel === false) {\n      return \"none\";\n    }\n    return cancel?.directional ?? \"none\";\n  }\n  cancelAny() {\n    return this.config.cancel && this.cancelQuantum() !== \"none\";\n  }\n  cancelPuzzleSpecificModWrap() {\n    const { cancel } = this.config;\n    if (cancel === true || cancel === false) {\n      return \"canonical-centered\";\n    }\n    if (cancel?.puzzleSpecificModWrap) {\n      return cancel?.puzzleSpecificModWrap;\n    }\n    return cancel?.directional === \"same-direction\" ? \"preserve-sign\" : \"canonical-centered\";\n  }\n  puzzleSpecificSimplifyOptions() {\n    return this.config.puzzleLoader?.puzzleSpecificSimplifyOptions ?? this.config.puzzleSpecificSimplifyOptions;\n  }\n};\n\n// src/cubing/alg/simplify/append.ts\nfunction areSameDirection(direction, move2) {\n  return direction * Math.sign(move2.amount) >= 0;\n}\nfunction offsetMod(x, positiveMod, offset) {\n  return ((x - offset) % positiveMod + positiveMod) % positiveMod + offset;\n}\nfunction experimentalAppendMove(alg, addedMove, options) {\n  const optionsHelper = new AppendOptionsHelper(options);\n  const outputPrefix = Array.from(alg.childAlgNodes());\n  let outputSuffix = [addedMove];\n  function output() {\n    return new Alg([...outputPrefix, ...outputSuffix]);\n  }\n  function modMove(move) {\n    if (optionsHelper.cancelPuzzleSpecificModWrap() === \"none\") {\n      return move;\n    }\n    const quantumMoveOrder = optionsHelper.puzzleSpecificSimplifyOptions()?.quantumMoveOrder;\n    if (!quantumMoveOrder) {\n      return move;\n    }\n    const mod = quantumMoveOrder(addedMove.quantum);\n    let offset;\n    switch (optionsHelper.cancelPuzzleSpecificModWrap()) {\n      case \"gravity\": {\n        offset = -Math.floor((mod - (move.amount < 0 ? 0 : 1)) / 2);\n        break;\n      }\n      case \"canonical-centered\": {\n        offset = -Math.floor((mod - 1) / 2);\n        break;\n      }\n      case \"canonical-positive\": {\n        offset = 0;\n        break;\n      }\n      case \"preserve-sign\": {\n        offset = move.amount < 0 ? 1 - mod : 0;\n        break;\n      }\n      default: {\n        throw new Error(\"Unknown mod wrap\");\n      }\n    }\n    const offsetAmount = offsetMod(move.amount, mod, offset);\n    return move.modified({ amount: offsetAmount });\n  }\n  if (optionsHelper.cancelAny()) {\n    let canCancelMoveBasedOnQuantum;\n    const axis = optionsHelper.puzzleSpecificSimplifyOptions()?.axis;\n    if (axis) {\n      canCancelMoveBasedOnQuantum = (move) => axis.areQuantumMovesSameAxis(addedMove.quantum, move.quantum);\n    } else {\n      const newMoveQuantumString = addedMove.quantum.toString();\n      canCancelMoveBasedOnQuantum = (move) => move.quantum.toString() === newMoveQuantumString;\n    }\n    const sameDirectionOnly = optionsHelper.cancelQuantum() === \"same-direction\";\n    const quantumDirections = /* @__PURE__ */ new Map();\n    quantumDirections.set(\n      addedMove.quantum.toString(),\n      Math.sign(addedMove.amount)\n    );\n    let i;\n    for (i = outputPrefix.length - 1; i >= 0; i--) {\n      const move = outputPrefix[i].as(Move);\n      if (!move) {\n        break;\n      }\n      if (!canCancelMoveBasedOnQuantum(move)) {\n        break;\n      }\n      const quantumKey = move.quantum.toString();\n      if (sameDirectionOnly) {\n        const existingQuantumDirectionOnAxis = quantumDirections.get(quantumKey);\n        if (existingQuantumDirectionOnAxis && !areSameDirection(existingQuantumDirectionOnAxis, move)) {\n          break;\n        }\n        quantumDirections.set(quantumKey, Math.sign(move.amount));\n      }\n    }\n    const suffix = [...outputPrefix.splice(i + 1), addedMove];\n    if (axis) {\n      outputSuffix = axis.simplifySameAxisMoves(\n        suffix,\n        optionsHelper.cancelPuzzleSpecificModWrap() !== \"none\"\n      );\n    } else {\n      const amount = suffix.reduce(\n        (sum, move) => sum + move.amount,\n        0\n      );\n      if (quantumDirections.size !== 1) {\n        throw new Error(\n          \"Internal error: multiple quantums when one was expected\"\n        );\n      }\n      outputSuffix = [new Move(addedMove.quantum, amount)];\n    }\n  }\n  outputSuffix = outputSuffix.map((m) => modMove(m)).filter((move) => move.amount !== 0);\n  return output();\n}\nfunction experimentalAppendNode(alg, leaf, options) {\n  const maybeMove = leaf.as(Move);\n  if (maybeMove) {\n    return experimentalAppendMove(alg, maybeMove, options);\n  } else {\n    return new Alg([...alg.childAlgNodes(), leaf]);\n  }\n}\n\n// src/cubing/alg/simplify/simplify.ts\nvar Simplify = class extends TraversalDownUp {\n  #newPlaceholderAssociationsMap;\n  #newPlaceholderAssociations() {\n    return this.#newPlaceholderAssociationsMap ?? (this.#newPlaceholderAssociationsMap = /* @__PURE__ */ new Map());\n  }\n  #descendOptions(options) {\n    return {\n      ...options,\n      depth: options.depth ? options.depth - 1 : null\n    };\n  }\n  *traverseAlg(alg, options) {\n    if (options.depth === 0) {\n      yield* alg.childAlgNodes();\n      return;\n    }\n    let output = [];\n    const newOptions = this.#descendOptions(options);\n    for (const algNode of alg.childAlgNodes()) {\n      for (const traversedNode of this.traverseAlgNode(algNode, newOptions)) {\n        output = Array.from(\n          experimentalAppendNode(\n            new Alg(output),\n            traversedNode,\n            newOptions\n          ).childAlgNodes()\n        );\n      }\n    }\n    for (const newAlgNode of output) {\n      yield newAlgNode;\n    }\n  }\n  *traverseGrouping(grouping, options) {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    if (grouping.amount === 0) {\n      return;\n    }\n    const newGrouping = new Grouping(\n      this.traverseAlg(grouping.alg, this.#descendOptions(options)),\n      grouping.amount\n    );\n    if (newGrouping.alg.experimentalIsEmpty()) {\n      return;\n    }\n    const newPlaceholder = this.#newPlaceholderAssociations().get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n    yield newGrouping;\n  }\n  *traverseMove(move, _options) {\n    yield move;\n  }\n  #doChildrenCommute(A, B, options) {\n    if (A.experimentalNumChildAlgNodes() === 1 && B.experimentalNumChildAlgNodes() === 1) {\n      const aMove = Array.from(A.childAlgNodes())[0]?.as(Move);\n      const bMove = Array.from(B.childAlgNodes())[0]?.as(Move);\n      if (!(aMove && bMove)) {\n        return false;\n      }\n      if (bMove.quantum.isIdentical(aMove.quantum)) {\n        return true;\n      }\n      const appendOptionsHelper = new AppendOptionsHelper(options);\n      if (appendOptionsHelper.puzzleSpecificSimplifyOptions()?.axis?.areQuantumMovesSameAxis(aMove.quantum, bMove.quantum)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  *traverseCommutator(commutator, options) {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newCommutator = new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions)\n    );\n    if (newCommutator.A.experimentalIsEmpty() || newCommutator.B.experimentalIsEmpty() || newCommutator.A.isIdentical(newCommutator.B) || newCommutator.A.isIdentical(newCommutator.B.invert()) || this.#doChildrenCommute(newCommutator.A, newCommutator.B, options)) {\n      return;\n    }\n    yield newCommutator;\n  }\n  *traverseConjugate(conjugate, options) {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newConjugate = new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions)\n    );\n    if (newConjugate.B.experimentalIsEmpty()) {\n      return;\n    }\n    if (newConjugate.A.experimentalIsEmpty() || newConjugate.A.isIdentical(newConjugate.B) || newConjugate.A.isIdentical(newConjugate.B.invert()) || this.#doChildrenCommute(newConjugate.A, newConjugate.B, options)) {\n      yield* conjugate.B.childAlgNodes();\n      return;\n    }\n    yield newConjugate;\n  }\n  *traversePause(pause, _options) {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      this.#newPlaceholderAssociations().set(\n        pause.experimentalNISSGrouping,\n        newPause\n      );\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n  *traverseNewline(newline, _options) {\n    yield newline;\n  }\n  *traverseLineComment(comment, _options) {\n    yield comment;\n  }\n};\nvar simplify = functionFromTraversal(Simplify);\n\n// src/cubing/alg/Alg.ts\nfunction toIterable(input) {\n  if (!input) {\n    return [];\n  }\n  if (experimentalIs(input, Alg)) {\n    return input.childAlgNodes();\n  }\n  if (typeof input === \"string\") {\n    return parseAlg(input).childAlgNodes();\n  }\n  const iter = input;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter;\n  }\n  throw new Error(\"Invalid AlgNode\");\n}\nfunction experimentalEnsureAlg(alg) {\n  if (experimentalIs(alg, Alg)) {\n    return alg;\n  }\n  return new Alg(alg);\n}\nvar Alg = class extends AlgCommon {\n  #algNodes;\n  constructor(alg) {\n    super();\n    this.#algNodes = Array.from(toIterable(alg));\n    for (const algNode of this.#algNodes) {\n      if (!experimentalIsAlgNode(algNode)) {\n        throw new Error(\"An alg can only contain alg nodes.\");\n      }\n    }\n  }\n  isIdentical(other) {\n    const otherAsAlg = other;\n    if (!other.is(Alg)) {\n      return false;\n    }\n    const l1 = Array.from(this.#algNodes);\n    const l2 = Array.from(otherAsAlg.#algNodes);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invert() {\n    return new Alg(reverse(Array.from(this.#algNodes).map((u) => u.invert())));\n  }\n  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {\n    depth ?? (depth = Infinity);\n    for (const algNode of direct(this.#algNodes, iterDir)) {\n      yield* algNode.experimentalExpand(iterDir, depth);\n    }\n  }\n  expand(options) {\n    return new Alg(\n      this.experimentalExpand(\n        1 /* Forwards */,\n        options?.depth ?? Infinity\n      )\n    );\n  }\n  *experimentalLeafMoves() {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf;\n      }\n    }\n  }\n  concat(input) {\n    return new Alg(\n      Array.from(this.#algNodes).concat(Array.from(toIterable(input)))\n    );\n  }\n  experimentalIsEmpty() {\n    for (const _ of this.#algNodes) {\n      return false;\n    }\n    return true;\n  }\n  static fromString(s) {\n    return parseAlg(s);\n  }\n  units() {\n    return this.childAlgNodes();\n  }\n  *childAlgNodes() {\n    for (const algNode of this.#algNodes) {\n      yield algNode;\n    }\n  }\n  experimentalNumUnits() {\n    return this.experimentalNumChildAlgNodes();\n  }\n  experimentalNumChildAlgNodes() {\n    return Array.from(this.#algNodes).length;\n  }\n  get type() {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n  toString() {\n    let output = \"\";\n    let previousVisibleAlgNode = null;\n    for (const algNode of this.#algNodes) {\n      if (previousVisibleAlgNode) {\n        output += spaceBetween(previousVisibleAlgNode, algNode);\n      }\n      const nissGrouping = algNode.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString()})`;\n      } else if (algNode.as(Grouping)?.experimentalNISSPlaceholder) {\n      } else {\n        output += algNode.toString();\n      }\n      previousVisibleAlgNode = algNode;\n    }\n    return output;\n  }\n  experimentalSimplify(options) {\n    return new Alg(simplify(this, options ?? {}));\n  }\n  simplify(options) {\n    return this.experimentalSimplify(options);\n  }\n};\nfunction spaceBetween(u1, u2) {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\";\n  }\n  return \" \";\n}\n\n// src/cubing/alg/example.ts\nvar Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1)\n  ]),\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1)\n  ]),\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)]))\n      ])\n    )\n  ]),\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1)\n  ]),\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)])\n        )\n      ]),\n      new Alg([new Move(\"D\", 1)])\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)]))\n      ]),\n      new Alg([new Move(\"D\", 1)])\n    ),\n    new Move(\"x\", 1)\n  ]),\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)])\n        )\n      ])\n    )\n  ]),\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)])\n        )\n      ])\n    )\n  ]),\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1)\n  ]),\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1)\n  ]),\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)])\n            )\n          ]),\n          3\n        )\n      ])\n    )\n  ]),\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()])\n};\n\n// src/cubing/alg/keyboard.ts\nvar cubeKeyMapping = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"),\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n  192: new Pause()\n};\nfunction keyToMove(e) {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n  return cubeKeyMapping[e.keyCode] || null;\n}\n\n// src/cubing/alg/url.ts\nfunction serializeURLParam(a) {\n  let escaped = a.toString();\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\nfunction experimentalAlgCubingNetLink(options) {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error(\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if (![\n      \"1x1x1\",\n      \"2x2x2\",\n      \"3x3x3\",\n      \"4x4x4\",\n      \"5x5x5\",\n      \"6x6x6\",\n      \"7x7x7\",\n      \"8x8x8\",\n      \"9x9x9\",\n      \"10x10x10\",\n      \"11x11x11\",\n      \"12x12x12\",\n      \"13x13x13\",\n      \"14x14x14\",\n      \"16x16x16\",\n      \"17x17x17\"\n    ].includes(options.puzzle)) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if (![\n      \"full\",\n      \"cross\",\n      \"F2L\",\n      \"LL\",\n      \"OLL\",\n      \"PLL\",\n      \"CLS\",\n      \"ELS\",\n      \"L6E\",\n      \"CMLL\",\n      \"WV\",\n      \"ZBLL\",\n      \"void\"\n    ].includes(options.stage)) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if (![\"editor\", \"playback\", \"fullscreen\"].includes(options.view)) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if (![\n      \"moves\",\n      \"reconstruction\",\n      \"alg\",\n      \"reconstruction-end-with-setup\"\n    ].includes(options.type)) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n\nexport {\n  direct,\n  directedGenerator,\n  AlgBuilder,\n  setAlgDebug,\n  Commutator,\n  Conjugate,\n  LineComment,\n  Newline,\n  Pause,\n  QuantumMove,\n  Move,\n  Grouping,\n  experimentalIs,\n  TraversalDownUp,\n  TraversalUp,\n  functionFromTraversal,\n  experimentalAppendMove,\n  Alg,\n  Example,\n  keyToMove,\n  experimentalAlgCubingNetLink\n};\n//# sourceMappingURL=chunk-VZP3KFTU.js.map\n","import type { Alg } from \"./Alg\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { AlgLeaf, AlgNode } from \"./alg-nodes/AlgNode\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeaf>;\n}\n\n// Common to `Alg` or `AlgNode` classes.\nexport abstract class AlgCommon<T extends Alg | AlgNode>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract override toString(): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(iterDir: IterationDirection): Generator<AlgLeaf>;\n}\n","export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n","export const MAX_INT = 0x7fffffff; // 2^31-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MIN_INT_DESCRIPTION = \"-2^31\";\n","import { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\n\n/** @category Alg */\nexport class AlgBuilder {\n  #algNode: AlgNode[] = [];\n\n  push(u: AlgNode): void {\n    this.#algNode.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.childAlgNodes()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumAlgNodes(): number {\n    return this.#algNode.length;\n  }\n\n  // can be called multiple times, even if you push alg nodes inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#algNode);\n  }\n\n  reset(): void {\n    this.#algNode = [];\n  }\n}\n","type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\": {\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n    }\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(\n  level: ReportingLevel,\n): void {\n  currentReportingLevel = level;\n}\n\nexport const algDebugGlobals: { caretNISSNotationEnabled: boolean } = {\n  caretNISSNotationEnabled: true,\n};\n\nexport function setAlgDebug(options: {\n  caretNISSNotationEnabled?: boolean;\n}): void {\n  if (\"caretNISSNotationEnabled\" in options) {\n    algDebugGlobals.caretNISSNotationEnabled =\n      !!options.caretNISSNotationEnabled;\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(): string {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(): string {\n    return `[${this.A}: ${this.B}]`;\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\n/** @category Alg Nodes */\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n\n  toString(): string {\n    return `//${this.#text}`;\n  }\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Newline extends AlgCommon<Newline> {\n  toString(): string {\n    return \"\\n\";\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n}\n","import type { Grouping } from \"..\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Pause extends AlgCommon<Pause> {\n  experimentalNISSGrouping?: Grouping; // TODO: tie this to the alg\n\n  toString(): string {\n    return \".\";\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n}\n","import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport { algDebugGlobals } from \"./debug\";\nimport type { AlgNode } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst AMOUNT_REGEX = /^(\\d+)?('?)/;\nconst MOVE_START_REGEX = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nconst COMMENT_TEXT_REGEX = /^[^\\n]*/;\nconst SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport interface ParserIndexed {\n  startCharIndex: number;\n  endCharIndex: number;\n}\n\nexport type Parsed<T extends Alg | AlgNode> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | AlgNode>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | AlgNode>(from: T, to: T): T {\n  if (\"startCharIndex\" in from) {\n    (to as Parsed<T>).startCharIndex = (from as Parsed<T>).startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    (to as Parsed<T>).endCharIndex = (from as Parsed<T>).endCharIndex;\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n  #nissQueue: Grouping[] = [];\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const algNodes = Array.from(alg.childAlgNodes());\n    if (this.#nissQueue.length > 0) {\n      for (const nissGrouping of this.#nissQueue.reverse()) {\n        algNodes.push(nissGrouping);\n      }\n    }\n    const newAlg = new Alg(algNodes) as Parsed<Alg>;\n    const { startCharIndex, endCharIndex } = alg;\n    addCharIndices(newAlg, startCharIndex, endCharIndex);\n    return newAlg;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last alg node.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    mainLoop: while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumAlgNodes() === 0) {\n          algStartIdx = this.#idx;\n        }\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else if (MOVE_START_REGEX.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\"^\")) {\n        if (!algDebugGlobals.caretNISSNotationEnabled) {\n          throw new Error(\n            \"Alg contained a caret but caret NISS notation is not enabled.\",\n          );\n        }\n\n        this.mustConsumeNext(\"(\");\n        const alg = this.parseAlgWithStopping([\")\"]);\n        this.popNext();\n\n        const grouping = new Grouping(alg, -1);\n        const placeholder = new Pause();\n\n        grouping.experimentalNISSPlaceholder = placeholder;\n        placeholder.experimentalNISSGrouping = grouping;\n\n        this.#nissQueue.push(grouping);\n        algBuilder.push(placeholder);\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        switch (separator) {\n          case \":\": {\n            algBuilder.push(\n              addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n\n            // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n            continue mainLoop;\n          }\n          case \",\": {\n            algBuilder.push(\n              addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n\n            // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n            continue mainLoop;\n          }\n          default:\n            throw new Error(\"unexpected parsing error\");\n        }\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n\n          // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n\n        // rome-ignore lint/correctness/noUnnecessaryContinue: This line allows for more robust refactoring.\n        continue mainLoop;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(QUANTUM_MOVE_REGEX);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n","const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n","import type { Repeatable } from \"../common\";\nimport { IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { AlgLeaf } from \"./AlgNode\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `AlgNode amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<AlgLeaf> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parseAlg\";\nimport { warnOnce } from \"../../warnOnce\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<AlgLeaf> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  override toString(): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = `${String(this.#outerLayer)}-${s}`;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\n/** @category Alg Nodes */\nexport class Move extends AlgCommon<Move> {\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        // rome-ignore lint/nursery/noConstructorReturn: https://github.com/rome/tools/issues/4005\n        return Move.fromString(args[0]);\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among alg nodes.\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<AlgLeaf> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  toString(): string {\n    if (this.family === \"_SLASH_\") {\n      return \"/\"; // TODO: validate no amount\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n        Math.abs(this.amount) +\n        (this.amount < 0 ? \"-\" : \"+\")\n      ); // TODO\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n        (absAmount === 1 ? \"\" : absAmount) +\n        (this.amount < 0 ? \"--\" : \"++\")\n      ); // TODO\n    }\n\n    return (\n      this.#quantumWithAmount.quantum.toString() +\n      this.#quantumWithAmount.suffix()\n    );\n  }\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport type { Pause } from \"../leaves/Pause\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(grouping: Grouping): string | null {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumChildAlgNodes() === 2) {\n      const [U, D] = quantumAlg.childAlgNodes();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\",\n          );\n        }\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\n/** @category Alg Nodes */\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n  experimentalNISSPlaceholder?: Pause; // TODO: tie this to the alg\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  toString(): string {\n    return (\n      square1TupleFormatterInstance.format(this) ??\n      `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n","import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./alg-nodes\";\n\nexport function experimentalIs(\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\nexport function experimentalIsAlgNode(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n","import type { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\nimport type { Comparable } from \"./common\";\n\nfunction dispatch<DataDown, DataAlgUp, DataAlgNodeUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataAlgNodeUp>,\n  algNode: AlgNode,\n  dataDown: DataDown,\n): DataAlgNodeUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (algNode.is(Grouping)) {\n    return t.traverseGrouping(algNode as Grouping, dataDown);\n  }\n  if (algNode.is(Move)) {\n    return t.traverseMove(algNode as Move, dataDown);\n  }\n  if (algNode.is(Commutator)) {\n    return t.traverseCommutator(algNode as Commutator, dataDown);\n  }\n  if (algNode.is(Conjugate)) {\n    return t.traverseConjugate(algNode as Conjugate, dataDown);\n  }\n  if (algNode.is(Pause)) {\n    return t.traversePause(algNode as Pause, dataDown);\n  }\n  if (algNode.is(Newline)) {\n    return t.traverseNewline(algNode as Newline, dataDown);\n  }\n  if (algNode.is(LineComment)) {\n    return t.traverseLineComment(algNode as LineComment, dataDown);\n  }\n  throw new Error(\"unknown AlgNode\");\n}\n\nfunction mustBeAlgNode(t: Comparable): AlgNode {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as AlgNode;\n  }\n  throw new Error(\"internal error: expected AlgNode\"); // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseAlgNode(algNode: AlgNode, dataDown: DataDown): DataAlgNodeUp {\n    return dispatch(this, algNode, dataDown);\n  }\n\n  public traverseIntoAlgNode(algNode: AlgNode, dataDown: DataDown): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataAlgNodeUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traversePause(\n    pause: Pause,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataAlgNodeUp> {\n  public override traverseAlgNode(algNode: AlgNode): DataAlgNodeUp {\n    return dispatch<unknown, DataAlgUp, DataAlgNodeUp>(\n      this,\n      algNode,\n      undefined,\n    );\n  }\n\n  public override traverseIntoAlgNode(algNode: AlgNode): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode) as any);\n  }\n\n  public abstract override traverseAlg(alg: Alg): DataAlgUp;\n  public abstract override traverseGrouping(grouping: Grouping): DataAlgNodeUp;\n  public abstract override traverseMove(move: Move): DataAlgNodeUp;\n  public abstract override traverseCommutator(\n    commutator: Commutator,\n  ): DataAlgNodeUp;\n  public abstract override traverseConjugate(\n    conjugate: Conjugate,\n  ): DataAlgNodeUp;\n  public abstract override traversePause(pause: Pause): DataAlgNodeUp;\n  public abstract override traverseNewline(newline: Newline): DataAlgNodeUp;\n  public abstract override traverseLineComment(\n    comment: LineComment,\n  ): DataAlgNodeUp;\n}\n\nexport function functionFromTraversal<\n  DataDown,\n  DataAlgUp,\n  ConstructorArgs extends unknown[],\n>(\n  traversalConstructor: {\n    new (...args: ConstructorArgs): TraversalDownUp<DataDown, DataAlgUp, any>;\n  },\n  constructorArgs?: ConstructorArgs,\n): undefined extends DataDown\n  ? (alg: Alg) => DataAlgUp\n  : (alg: Alg, v: DataDown) => DataAlgUp {\n  const instance = new traversalConstructor(\n    ...(constructorArgs ?? ([] as any)),\n  );\n  return instance.traverseAlg.bind(instance);\n}\n","import type { Move, QuantumMove } from \"../alg-nodes\";\n\n// TODO: enums?\nconst DEFAULT_DIRECTIONAL = \"any-direction\";\nDEFAULT_DIRECTIONAL;\nexport type QuantumDirectionalCancellation =\n  | typeof DEFAULT_DIRECTIONAL // Cancel any moves with the same quantum.\n  | \"same-direction\" // Cancel two quantums when have non-zero amounts of the same sign (positive/negative). An amount of 0 always counts as the same direction as any other amount.\n  | \"none\";\n\n// Example input: `R7' . R6' . R5' . R6` on a cube.\nexport type ModWrap =\n  | \"none\" // R7' . R6' . R5' . R6\n  | \"gravity\" // R . R2' . R' . R2\n  | \"canonical-centered\" // R . R2 . R' . R2\n  | \"canonical-positive\" // R . R2 . R3 . R2\n  | \"preserve-sign\"; // R3' . R2' . R' . R2\n\nexport interface AppendCancelOptions {\n  directional?: QuantumDirectionalCancellation;\n  puzzleSpecificModWrap?: ModWrap; // Default depends on `directional`\n}\n\n// TODO: preserve single moves even when amount is 0?\nexport interface AppendOptions {\n  cancel?: boolean | AppendCancelOptions; // Set to `true` to use future-proof defaults.\n  // Takes precedence over the direct `puzzleSpecificSimplifyOptions` field.\n  puzzleLoader?: {\n    puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  };\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n}\n\nexport class AppendOptionsHelper {\n  constructor(private config: AppendOptions = {}) {}\n\n  cancelQuantum(): QuantumDirectionalCancellation {\n    const { cancel } = this.config;\n    if (cancel === true) {\n      return DEFAULT_DIRECTIONAL;\n    }\n    if (cancel === false) {\n      return \"none\";\n    }\n    return cancel?.directional ?? \"none\";\n  }\n\n  cancelAny() {\n    return this.config.cancel && this.cancelQuantum() !== \"none\";\n  }\n\n  cancelPuzzleSpecificModWrap(): ModWrap {\n    const { cancel } = this.config;\n    if (cancel === true || cancel === false) {\n      return \"canonical-centered\";\n    }\n    if (cancel?.puzzleSpecificModWrap) {\n      return cancel?.puzzleSpecificModWrap;\n    }\n    return cancel?.directional === \"same-direction\"\n      ? \"preserve-sign\"\n      : \"canonical-centered\";\n  }\n\n  puzzleSpecificSimplifyOptions(): PuzzleSpecificSimplifyOptions | undefined {\n    return (\n      this.config.puzzleLoader?.puzzleSpecificSimplifyOptions ??\n      this.config.puzzleSpecificSimplifyOptions\n    );\n  }\n}\n\nexport interface SimplifyOptions extends AppendOptions {\n  depth?: number | null; // TODO: test\n}\n\nexport interface PuzzleSpecificAxisSimplifyInfo {\n  // All moves on the same axis *must* commute.\n  areQuantumMovesSameAxis: (\n    quantumMove1: QuantumMove,\n    quantumMove2: QuantumMove,\n  ) => boolean;\n  simplifySameAxisMoves: (moves: Move[], quantumMod: boolean) => Move[];\n}\n\n// TOOD: allow \"normal\" \"twisty\" puzzles to hardcode axis concepts without hardcoding too much in `Alg` that's not relevant to all puzzles.\nexport interface PuzzleSpecificSimplifyOptions {\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  // TODO: implement cancellation for non-axis commuting moves (e.g. Megaminx: `BL R BL'`  `R`)\n  // // Commutation is not transitive. For example, on Megaminx: BR and BL both commute with F, but not with each other.\n  // doQuantumMovesCommute?: (\n  //   quantumMove1: QuantumMove,\n  //   quantumMove2: QuantumMove,\n  // ) => boolean;\n  axis?: PuzzleSpecificAxisSimplifyInfo;\n}\n","import { Alg } from \"../Alg\";\nimport type { AlgNode } from \"../alg-nodes\";\nimport type { AlgLeaf } from \"../alg-nodes/AlgNode\";\nimport { Move } from \"../alg-nodes/leaves/Move\";\nimport { AppendOptions, AppendOptionsHelper } from \"./options\";\n\nfunction areSameDirection(direction: -1 | 1, move2: Move): boolean {\n  // This multiplication has two properties:\n  // - If either amount is 0, returns true.\n  // - Otherwise, the signs have to match.\n  return direction * Math.sign(move2.amount) >= 0;\n}\n\nfunction offsetMod(x: number, positiveMod: number, offset: number): number {\n  return ((((x - offset) % positiveMod) + positiveMod) % positiveMod) + offset;\n}\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  addedMove: Move,\n  options?: AppendOptions,\n): Alg {\n  const optionsHelper = new AppendOptionsHelper(options);\n\n  const outputPrefix: AlgNode[] = Array.from(alg.childAlgNodes());\n  let outputSuffix: Move[] = [addedMove];\n  function output() {\n    return new Alg([...outputPrefix, ...outputSuffix]); // TODO: What's the most efficient way to do this?\n  }\n\n  function modMove(move: Move): Move {\n    if (optionsHelper.cancelPuzzleSpecificModWrap() === \"none\") {\n      return move;\n    }\n    const quantumMoveOrder =\n      optionsHelper.puzzleSpecificSimplifyOptions()?.quantumMoveOrder;\n    if (!quantumMoveOrder) {\n      return move;\n    }\n    const mod = quantumMoveOrder(addedMove.quantum)!; // TODO: throw if `undefined`?\n    let offset: number;\n    switch (optionsHelper.cancelPuzzleSpecificModWrap()) {\n      case \"gravity\": {\n        offset = -Math.floor((mod - (move.amount < 0 ? 0 : 1)) / 2); // TODO: dedup this calculation for the most common path?\n        break;\n      }\n      case \"canonical-centered\": {\n        offset = -Math.floor((mod - 1) / 2); // TODO: dedup this calculation for the most common path?\n        break;\n      }\n      case \"canonical-positive\": {\n        offset = 0;\n        break;\n      }\n      case \"preserve-sign\": {\n        offset = move.amount < 0 ? 1 - mod : 0;\n        break;\n      }\n      default: {\n        throw new Error(\"Unknown mod wrap\");\n      }\n    }\n    const offsetAmount = offsetMod(move.amount, mod, offset);\n    return move.modified({ amount: offsetAmount });\n  }\n\n  if (optionsHelper.cancelAny()) {\n    let canCancelMoveBasedOnQuantum: (move: Move) => boolean;\n    const axis = optionsHelper.puzzleSpecificSimplifyOptions()?.axis;\n    if (axis) {\n      canCancelMoveBasedOnQuantum = (move: Move): boolean =>\n        axis.areQuantumMovesSameAxis(addedMove.quantum, move.quantum);\n    } else {\n      const newMoveQuantumString = addedMove.quantum.toString();\n      canCancelMoveBasedOnQuantum = (move: Move): boolean =>\n        move.quantum.toString() === newMoveQuantumString;\n    }\n\n    const sameDirectionOnly =\n      optionsHelper.cancelQuantum() === \"same-direction\";\n\n    const quantumDirections = new Map<string, 1 | 0 | -1>();\n    quantumDirections.set(\n      addedMove.quantum.toString(),\n      Math.sign(addedMove.amount) as -1 | 0 | 1,\n    );\n    let i: number;\n    for (i = outputPrefix.length - 1; i >= 0; i--) {\n      const move = outputPrefix[i].as(Move);\n      if (!move) {\n        break;\n      }\n      if (!canCancelMoveBasedOnQuantum(move)) {\n        break;\n      }\n      const quantumKey = move.quantum.toString();\n      if (sameDirectionOnly) {\n        const existingQuantumDirectionOnAxis =\n          quantumDirections.get(quantumKey);\n        if (\n          existingQuantumDirectionOnAxis && // Short-circuits, but that's actually okay here.\n          !areSameDirection(existingQuantumDirectionOnAxis, move)\n        ) {\n          break;\n        }\n        quantumDirections.set(quantumKey, Math.sign(move.amount) as -1 | 0 | 1);\n      }\n    }\n    const suffix = [...(outputPrefix.splice(i + 1) as Move[]), addedMove];\n\n    if (axis) {\n      // TODO: pass down quantum mod\n      outputSuffix = axis.simplifySameAxisMoves(\n        suffix,\n        optionsHelper.cancelPuzzleSpecificModWrap() !== \"none\",\n      );\n    } else {\n      const amount = suffix.reduce(\n        (sum: number, move: Move) => sum + move.amount,\n        0,\n      );\n      if (quantumDirections.size !== 1) {\n        throw new Error(\n          \"Internal error: multiple quantums when one was expected\",\n        );\n      }\n      outputSuffix = [new Move(addedMove.quantum, amount)];\n    }\n  }\n  outputSuffix = outputSuffix\n    .map((m) => modMove(m))\n    .filter((move: Move) => move.amount !== 0);\n  return output();\n}\n\nexport function experimentalAppendNode(\n  alg: Alg,\n  leaf: AlgLeaf,\n  options: AppendOptions,\n): Alg {\n  const maybeMove = leaf.as(Move);\n  if (maybeMove) {\n    return experimentalAppendMove(alg, maybeMove, options);\n  } else {\n    return new Alg([...alg.childAlgNodes(), leaf]);\n  }\n}\n","import { Alg } from \"../Alg\";\nimport type { AlgNode } from \"../alg-nodes/AlgNode\";\nimport { Commutator } from \"../alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"../alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"../alg-nodes/containers/Grouping\";\nimport type { LineComment } from \"../alg-nodes/leaves/LineComment\";\nimport { Move } from \"../alg-nodes/leaves/Move\";\nimport type { Newline } from \"../alg-nodes/leaves/Newline\";\nimport { Pause } from \"../alg-nodes/leaves/Pause\";\nimport { functionFromTraversal, TraversalDownUp } from \"../traversal\";\nimport { experimentalAppendNode } from \"./append\";\nimport { AppendOptionsHelper, SimplifyOptions } from \"./options\";\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<AlgNode>> {\n  #newPlaceholderAssociationsMap?: Map<Grouping, Pause>;\n  #newPlaceholderAssociations(): Map<Grouping, Pause> {\n    return (this.#newPlaceholderAssociationsMap ??= new Map<Grouping, Pause>());\n  }\n\n  // TODO: avoid allocations?\n  #descendOptions(options: SimplifyOptions): SimplifyOptions {\n    return {\n      ...options,\n      depth: options.depth ? options.depth - 1 : null,\n    };\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield* alg.childAlgNodes();\n      return;\n    }\n\n    let output: AlgNode[] = [];\n\n    const newOptions: SimplifyOptions = this.#descendOptions(options); // TODO: avoid allocations?\n    for (const algNode of alg.childAlgNodes()) {\n      for (const traversedNode of this.traverseAlgNode(algNode, newOptions)) {\n        output = Array.from(\n          experimentalAppendNode(\n            new Alg(output),\n            traversedNode,\n            newOptions,\n          ).childAlgNodes(),\n        );\n      }\n    }\n\n    // TODO: try to use `yield* output[Symbol.iterator]();`?\n    for (const newAlgNode of output) {\n      yield newAlgNode;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    if (grouping.amount === 0) {\n      // TODO: Are we okay with throwing away nested comments?\n      return;\n    }\n    const newGrouping = new Grouping(\n      this.traverseAlg(grouping.alg, this.#descendOptions(options)),\n      grouping.amount,\n    );\n    if (newGrouping.alg.experimentalIsEmpty()) {\n      return;\n    }\n\n    const newPlaceholder = this.#newPlaceholderAssociations().get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n\n    yield newGrouping;\n  }\n\n  public *traverseMove(\n    move: Move,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield move;\n  }\n\n  #doChildrenCommute(A: Alg, B: Alg, options: SimplifyOptions): boolean {\n    if (\n      A.experimentalNumChildAlgNodes() === 1 &&\n      B.experimentalNumChildAlgNodes() === 1\n    ) {\n      // Handle the special case where each side has been reduced to a single move.\n      const aMove = Array.from(A.childAlgNodes())[0]?.as(Move);\n      const bMove = Array.from(B.childAlgNodes())[0]?.as(Move);\n      if (!(aMove && bMove)) {\n        return false;\n      }\n      if (bMove.quantum.isIdentical(aMove.quantum)) {\n        return true;\n      }\n      const appendOptionsHelper = new AppendOptionsHelper(options); // TODO: avoid re-allocating every time.\n      if (\n        appendOptionsHelper\n          .puzzleSpecificSimplifyOptions()\n          ?.axis?.areQuantumMovesSameAxis(aMove.quantum, bMove.quantum)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newCommutator = new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n    if (\n      newCommutator.A.experimentalIsEmpty() ||\n      newCommutator.B.experimentalIsEmpty() ||\n      newCommutator.A.isIdentical(newCommutator.B) ||\n      newCommutator.A.isIdentical(newCommutator.B.invert()) ||\n      this.#doChildrenCommute(newCommutator.A, newCommutator.B, options)\n    ) {\n      return;\n    }\n    yield newCommutator;\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newConjugate = new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n    if (newConjugate.B.experimentalIsEmpty()) {\n      return;\n    }\n    if (\n      newConjugate.A.experimentalIsEmpty() ||\n      newConjugate.A.isIdentical(newConjugate.B) ||\n      newConjugate.A.isIdentical(newConjugate.B.invert()) ||\n      this.#doChildrenCommute(newConjugate.A, newConjugate.B, options)\n    ) {\n      yield* conjugate.B.childAlgNodes();\n      return;\n    }\n    yield newConjugate;\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      this.#newPlaceholderAssociations().set(\n        pause.experimentalNISSGrouping,\n        newPause,\n      );\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield comment;\n  }\n}\n\nexport const simplify = functionFromTraversal(Simplify);\n","// https://js.cubing.net/cubing/alg/\n\nimport { AlgCommon, Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsAlgNode } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parseAlg\";\nimport { simplify, SimplifyOptions } from \"./simplify\";\nimport { Grouping, Pause } from \"./alg-nodes\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport type { AlgLeaf, AlgNode } from \"./alg-nodes/AlgNode\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<AlgNode> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<AlgNode> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).childAlgNodes();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).childAlgNodes(); // TODO: something more direct?\n  }\n\n  const iter = input as Iterable<AlgNode>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw new Error(\"Invalid AlgNode\");\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * `Alg` is a class that encapsulates a structured alg. To create an `Alg` from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when the string input is user-provided.\n *\n * Once you have an `Alg`, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().experimentalSimplify({cancel: true}).invert().log()\n *\n * To convert an `Alg` to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n * @category Alg\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #algNodes: Iterable<AlgNode>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#algNodes = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const algNode of this.#algNodes) {\n      if (!experimentalIsAlgNode(algNode)) {\n        throw new Error(\"An alg can only contain alg nodes.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not taken into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#algNodes);\n    const l2 = Array.from(otherAsAlg.#algNodes);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#algNodes).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    for (const algNode of direct(this.#algNodes, iterDir)) {\n      yield* algNode.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#algNodes).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    for (const _ of this.#algNodes) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  /** @deprecated */\n  units(): Generator<AlgNode> {\n    return this.childAlgNodes();\n  }\n\n  *childAlgNodes(): Generator<AlgNode> {\n    for (const algNode of this.#algNodes) {\n      yield algNode;\n    }\n  }\n\n  /** @deprecated */\n  experimentalNumUnits(): number {\n    return this.experimentalNumChildAlgNodes();\n  }\n\n  experimentalNumChildAlgNodes(): number {\n    return Array.from(this.#algNodes).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(): string {\n    let output = \"\";\n    let previousVisibleAlgNode: AlgNode | null = null;\n    for (const algNode of this.#algNodes) {\n      if (previousVisibleAlgNode) {\n        output += spaceBetween(previousVisibleAlgNode, algNode);\n      }\n      const nissGrouping = algNode.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString()})`;\n      } else if (algNode.as(Grouping)?.experimentalNISSPlaceholder) {\n        // do not serialize (rely on the placeholder instead)\n      } else {\n        output += algNode.toString();\n      }\n      previousVisibleAlgNode = algNode;\n    }\n    return output;\n  }\n\n  /**\n   * `experimentalSimplify` can perform several mostly-syntactic simplifications on an alg:\n   *\n   *     // Logs: R' U3\n   *     import { Alg } from \"cubing/alg\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({ cancel: true }).log()\n   *\n   * You can pass in a `PuzzleLoader` (currently only for 3x3x3) for puzzle-specific simplifications:\n   *\n   *     // Logs: R' U'\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({ cancel: true, puzzleLoader: cube3x3x3 }).log()\n   *\n   * You can also cancel only moves that are in the same direction:\n   *\n   *     // Logs: R R2' U'\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({\n   *       cancel: { directional: \"same-direction\" },\n   *       puzzleLoader: cube3x3x3\n   *     }).log()\n   *\n   * Additionally, you can specify how moves are \"wrapped\":\n   *\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *\n   *     function example(puzzleSpecificModWrap) {\n   *       alg.experimentalSimplify({\n   *         cancel: { puzzleSpecificModWrap },\n   *         puzzleLoader: cube3x3x3\n   *       }).log()\n   *     }\n   *\n   *     const alg = new Alg(\"R7' . R6' . R5' . R6\")\n   *     example(\"none\")               // R7' . R6' . R5' . R6\n   *     example(\"gravity\")            // R . R2' . R' . R2\n   *     example(\"canonical-centered\") // R . R2 . R' . R2\n   *     example(\"canonical-positive\") // R . R2 . R3 . R2\n   *     example(\"preserve-sign\")      // R3' . R2' . R' . R2\n   *\n   * Same-axis and simultaneous move canonicalization is not implemented yet:\n   *\n   *     // Logs: R L R\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R L R\").experimentalSimplify({ cancel: true, puzzleLoader: cube3x3x3 }).log()\n   */\n  experimentalSimplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n\n  /** @deprecated See {@link experimentalSimplify} */\n  simplify(options?: SimplifyOptions): Alg {\n    return this.experimentalSimplify(options);\n  }\n}\n\nfunction spaceBetween(u1: AlgNode, u2: AlgNode): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n","// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n","import { Pause } from \"./alg-nodes\";\nimport type { AlgLeaf } from \"./alg-nodes/AlgNode\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\n\nconst cubeKeyMapping: { [key: number]: AlgLeaf } = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n\n  192: new Pause(),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): AlgLeaf | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import type { Alg } from \"./Alg\";\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nfunction serializeURLParam(a: Alg): string {\n  let escaped = a.toString();\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport interface AlgCubingNetOptions {\n  alg?: Alg;\n  setup?: Alg;\n  title?: string;\n  puzzle?:\n    | \"1x1x1\"\n    | \"2x2x2\"\n    | \"3x3x3\"\n    | \"4x4x4\"\n    | \"5x5x5\"\n    | \"6x6x6\"\n    | \"7x7x7\"\n    | \"8x8x8\"\n    | \"9x9x9\"\n    | \"10x10x10\"\n    | \"11x11x11\"\n    | \"12x12x12\"\n    | \"13x13x13\"\n    | \"14x14x14\"\n    | \"16x16x16\"\n    | \"17x17x17\";\n  stage?:\n    | \"full\"\n    | \"cross\"\n    | \"F2L\"\n    | \"LL\"\n    | \"OLL\"\n    | \"PLL\"\n    | \"CLS\"\n    | \"ELS\"\n    | \"L6E\"\n    | \"CMLL\"\n    | \"WV\"\n    | \"ZBLL\"\n    | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\";\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\";\n}\n\n// TODO: runtime validation?\n/** @deprecated */\nexport function experimentalAlgCubingNetLink(\n  options: AlgCubingNetOptions,\n): string {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error(\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if (\n      ![\n        \"1x1x1\",\n        \"2x2x2\",\n        \"3x3x3\",\n        \"4x4x4\",\n        \"5x5x5\",\n        \"6x6x6\",\n        \"7x7x7\",\n        \"8x8x8\",\n        \"9x9x9\",\n        \"10x10x10\",\n        \"11x11x11\",\n        \"12x12x12\",\n        \"13x13x13\",\n        \"14x14x14\",\n        \"16x16x16\",\n        \"17x17x17\",\n      ].includes(options.puzzle)\n    ) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if (\n      ![\n        \"full\",\n        \"cross\",\n        \"F2L\",\n        \"LL\",\n        \"OLL\",\n        \"PLL\",\n        \"CLS\",\n        \"ELS\",\n        \"L6E\",\n        \"CMLL\",\n        \"WV\",\n        \"ZBLL\",\n        \"void\",\n      ].includes(options.stage)\n    ) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if (![\"editor\", \"playback\", \"fullscreen\"].includes(options.view)) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if (\n      ![\n        \"moves\",\n        \"reconstruction\",\n        \"alg\",\n        \"reconstruction-end-with-setup\",\n      ].includes(options.type)\n    ) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"eXwSi\"))).then(() => parcelRequire('bYa3M'));","module.exports = Promise.all([__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"1eRHv\")), __parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"98R2k\"))]).then(() => parcelRequire('hJwM3'));","import {\n  CubePGPuzzleLoader,\n  PGPuzzleLoader,\n  PuzzleStickering,\n  StickeringManager,\n  asyncGetPuzzleGeometry,\n  cubeLikeStickeringMask,\n  cubeStickerings,\n  experimental3x3x3KPuzzle,\n  getCached\n} from \"./chunk-4F4IORIH.js\";\nimport {\n  KPuzzle\n} from \"./chunk-KLI2E737.js\";\nimport {\n  Move,\n  QuantumMove\n} from \"./chunk-VZP3KFTU.js\";\n\n// src/cubing/puzzles/events.ts\nvar wcaEvents = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  clock: { puzzleID: \"clock\", eventName: \"Clock\" },\n  minx: { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  pyram: { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  skewb: { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  sq1: { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" }\n};\nfunction wcaEventInfo(event) {\n  return wcaEvents[event] ?? null;\n}\nvar twizzleEvents = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\"\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\"\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\"\n  }\n};\nfunction eventInfo(event) {\n  return twizzleEvents[event] ?? null;\n}\n\n// src/cubing/puzzles/implementations/2x2x2/index.ts\nvar cube2x2x2 = {\n  id: \"2x2x2\",\n  fullName: \"2\\xD72\\xD72 Cube\",\n  kpuzzle: getCached(\n    async () => new KPuzzle(\n      (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).cube2x2x2JSON\n    )\n  ),\n  svg: async () => (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).cube2x2x2SVG,\n  llSVG: getCached(\n    async () => (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).cube2x2x2LLSVG\n  ),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  stickeringMask: (stickering) => cubeLikeStickeringMask(cube2x2x2, stickering),\n  stickerings: () => cubeStickerings(\"2x2x2\")\n};\n\n// src/cubing/puzzles/implementations/3x3x3/puzzle-specific-simplifications.ts\nfunction makeSourceInfo(moveStrings, type, from, to) {\n  const output = [];\n  for (const moveString of moveStrings) {\n    const move = Move.fromString(moveString);\n    const { family, amount: direction } = move;\n    if (![-1, 1].includes(direction)) {\n      throw new Error(\"Invalid config move\");\n    }\n    output.push({ family, direction, type, from, to });\n  }\n  return output;\n}\nvar axisInfos = {\n  [\"x axis\" /* X */]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"R\"], 0 /* INDEXABLE_SLICE_NEAR */, 0, 3),\n      ...makeSourceInfo([\"L'\"], 1 /* INDEXABLE_SLICE_FAR */, 0, 3),\n      ...makeSourceInfo([\"r\", \"Rw\"], 2 /* INDEXABLE_WIDE_NEAR */, 0, 2),\n      ...makeSourceInfo([\"l'\", \"Lw'\"], 3 /* INDEXABLE_WIDE_FAR */, 0, 2),\n      ...makeSourceInfo([\"M'\"], 4 /* SPECIFIC_SLICE */, 1, 2),\n      ...makeSourceInfo([\"x\", \"Uv\", \"Dv'\"], 5 /* ROTATION */, 0, 3)\n    ]\n  },\n  [\"y axis\" /* Y */]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"U\"], 0 /* INDEXABLE_SLICE_NEAR */, 0, 3),\n      ...makeSourceInfo([\"D'\"], 1 /* INDEXABLE_SLICE_FAR */, 0, 3),\n      ...makeSourceInfo([\"u\", \"Uw\"], 2 /* INDEXABLE_WIDE_NEAR */, 0, 2),\n      ...makeSourceInfo([\"d'\", \"Dw'\"], 3 /* INDEXABLE_WIDE_FAR */, 0, 2),\n      ...makeSourceInfo([\"E'\"], 4 /* SPECIFIC_SLICE */, 1, 2),\n      ...makeSourceInfo([\"y\", \"Uv\", \"Dv'\"], 5 /* ROTATION */, 0, 3)\n    ]\n  },\n  [\"z axis\" /* Z */]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"F\"], 0 /* INDEXABLE_SLICE_NEAR */, 0, 3),\n      ...makeSourceInfo([\"B'\"], 1 /* INDEXABLE_SLICE_FAR */, 0, 3),\n      ...makeSourceInfo([\"f\", \"Fw\"], 2 /* INDEXABLE_WIDE_NEAR */, 0, 3),\n      ...makeSourceInfo([\"b'\", \"Bw'\"], 3 /* INDEXABLE_WIDE_FAR */, 0, 3),\n      ...makeSourceInfo([\"S\"], 4 /* SPECIFIC_SLICE */, 1, 2),\n      ...makeSourceInfo([\"z\", \"Fv\", \"Bv'\"], 5 /* ROTATION */, 0, 3)\n    ]\n  }\n};\nvar byFamily = {};\nfor (const [axis, info] of Object.entries(axisInfos)) {\n  for (const moveSourceInfo of info.moveSourceInfos) {\n    byFamily[moveSourceInfo.family] = { axis, moveSourceInfo };\n  }\n}\nvar byAxisThenType = {};\nvar _a;\nfor (const axis of Object.keys(axisInfos)) {\n  const entry = {};\n  byAxisThenType[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    (entry[_a = moveSourceInfo.type] ?? (entry[_a] = [])).push(moveSourceInfo);\n  }\n}\nvar byAxisThenSpecificSlices = {};\nfor (const axis of Object.keys(axisInfos)) {\n  const entry = /* @__PURE__ */ new Map();\n  byAxisThenSpecificSlices[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    if (!entry.get(moveSourceInfo.from)) {\n      entry.set(moveSourceInfo.from, moveSourceInfo);\n    }\n  }\n}\nfunction firstOfType(axis, moveSourceType) {\n  const entry = byAxisThenType[axis][moveSourceType]?.[0];\n  if (!entry) {\n    throw new Error(\n      `Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`\n    );\n  }\n  return entry;\n}\nvar areQuantumMovesSameAxis = (quantumMove1, quantumMove2) => {\n  return byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis;\n};\nfunction simplestMove(axis, from, to, directedAmount) {\n  if (from + 1 === to) {\n    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from);\n    if (sliceSpecificInfo) {\n      return new Move(\n        new QuantumMove(sliceSpecificInfo.family),\n        directedAmount * sliceSpecificInfo.direction\n      );\n    }\n  }\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  if (from === 0 && to === sliceDiameter) {\n    const moveSourceInfo2 = firstOfType(axis, 5 /* ROTATION */);\n    return new Move(\n      new QuantumMove(moveSourceInfo2.family),\n      directedAmount * moveSourceInfo2.direction\n    );\n  }\n  const far = from + to > sliceDiameter;\n  if (far) {\n    [from, to] = [sliceDiameter - to, sliceDiameter - from];\n  }\n  let outerLayer = from + 1;\n  let innerLayer = to;\n  const slice = outerLayer === innerLayer;\n  if (slice) {\n    innerLayer = null;\n  }\n  if (outerLayer === 1) {\n    outerLayer = null;\n  }\n  if (slice && outerLayer === 1) {\n    innerLayer = null;\n  }\n  if (!slice && innerLayer === 2) {\n    innerLayer = null;\n  }\n  const moveSourceType = slice ? far ? 1 /* INDEXABLE_SLICE_FAR */ : 0 /* INDEXABLE_SLICE_NEAR */ : far ? 3 /* INDEXABLE_WIDE_FAR */ : 2 /* INDEXABLE_WIDE_NEAR */;\n  const moveSourceInfo = firstOfType(axis, moveSourceType);\n  return new Move(\n    new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer),\n    directedAmount * moveSourceInfo.direction\n  );\n}\nfunction simplifySameAxisMoves(moves, quantumMod = true) {\n  if (moves.length === 0) {\n    return [];\n  }\n  const axis = byFamily[moves[0].family].axis;\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  const sliceDeltas = /* @__PURE__ */ new Map();\n  let lastCandidateRange = null;\n  function adjustValue(idx, relativeDelta) {\n    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;\n    if (quantumMod) {\n      newDelta = newDelta % 4 + 5 % 4 - 1;\n    }\n    if (newDelta === 0) {\n      sliceDeltas.delete(idx);\n    } else {\n      sliceDeltas.set(idx, newDelta);\n    }\n  }\n  let suffixLength = 0;\n  for (const move of Array.from(moves).reverse()) {\n    suffixLength++;\n    const { moveSourceInfo } = byFamily[move.family];\n    const directedAmount2 = move.amount * moveSourceInfo.direction;\n    switch (moveSourceInfo.type) {\n      case 0 /* INDEXABLE_SLICE_NEAR */: {\n        const idx = (move.innerLayer ?? 1) - 1;\n        adjustValue(idx, directedAmount2);\n        adjustValue(idx + 1, -directedAmount2);\n        break;\n      }\n      case 1 /* INDEXABLE_SLICE_FAR */: {\n        const idx = sliceDiameter - (move.innerLayer ?? 1);\n        adjustValue(idx, directedAmount2);\n        adjustValue(idx + 1, -directedAmount2);\n        break;\n      }\n      case 2 /* INDEXABLE_WIDE_NEAR */: {\n        adjustValue((move.outerLayer ?? 1) - 1, directedAmount2);\n        adjustValue(move.innerLayer ?? 2, -directedAmount2);\n        break;\n      }\n      case 3 /* INDEXABLE_WIDE_FAR */: {\n        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount2);\n        adjustValue(\n          sliceDiameter - ((move.outerLayer ?? 1) - 1),\n          -directedAmount2\n        );\n        break;\n      }\n      case 4 /* SPECIFIC_SLICE */: {\n        adjustValue(moveSourceInfo.from, directedAmount2);\n        adjustValue(moveSourceInfo.to, -directedAmount2);\n        break;\n      }\n      case 5 /* ROTATION */: {\n        adjustValue(0, directedAmount2);\n        adjustValue(sliceDiameter, -directedAmount2);\n        break;\n      }\n    }\n    if ([0, 2].includes(sliceDeltas.size)) {\n      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };\n    }\n  }\n  if (sliceDeltas.size === 0) {\n    return [];\n  }\n  if (!lastCandidateRange) {\n    return moves;\n  }\n  let [from, to] = lastCandidateRange.sliceDeltas.keys();\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n  const directedAmount = lastCandidateRange.sliceDeltas.get(from);\n  return [\n    ...moves.slice(0, -lastCandidateRange.suffixLength),\n    ...directedAmount !== 0 ? [simplestMove(axis, from, to, directedAmount)] : []\n  ];\n}\nvar puzzleSpecificSimplifyOptions333 = {\n  quantumMoveOrder: () => 4,\n  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves }\n};\n\n// src/cubing/puzzles/implementations/3x3x3/index.ts\nvar cube3x3x3 = {\n  id: \"3x3x3\",\n  fullName: \"3\\xD73\\xD73 Cube\",\n  inventedBy: [\"Ern\\u0151 Rubik\"],\n  inventionYear: 1974,\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-3x3x3-QN5DUJUA.js\")).cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-3x3x3-QN5DUJUA.js\")).cube3x3x3LLSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  stickeringMask: (stickering) => cubeLikeStickeringMask(cube3x3x3, stickering),\n  stickerings: () => cubeStickerings(\"3x3x3\"),\n  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333\n};\n\n// src/cubing/puzzles/implementations/clock/index.ts\nvar clock = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988,\n  kpuzzle: getCached(\n    async () => new KPuzzle(\n      (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).clockJSON\n    )\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).clockSVG;\n  })\n};\n\n// src/cubing/puzzles/stickerings/fto-stickerings.ts\nasync function ftoStickering(puzzleLoader, stickering) {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n  const experimentalFTO_FC = () => m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = () => m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = () => m.or([\n    experimentalFTO_F2T(),\n    m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))])\n  ]);\n  const experimentalFTO_L2C = () => m.not(\n    m.or([\n      m.and([m.move(\"U\"), m.move(\"F\")]),\n      m.and([m.move(\"F\"), m.move(\"BL\")]),\n      m.and([m.move(\"F\"), m.move(\"BR\")]),\n      m.and([m.move(\"BL\"), m.move(\"BR\")])\n    ])\n  );\n  const experimentalFTO_LBT = () => m.not(\n    m.or([\n      m.and([m.move(\"F\"), m.move(\"BL\")]),\n      m.and([m.move(\"F\"), m.move(\"BR\")]),\n      m.and([m.move(\"BL\"), m.move(\"BR\")])\n    ])\n  );\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        \"Ignored\" /* Ignored */\n      );\n      break;\n    }\n    case \"experimental-fto-f2t\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        \"Ignored\" /* Ignored */\n      );\n      puzzleStickering.set(experimentalFTO_FC(), \"Dim\" /* Dim */);\n      break;\n    }\n    case \"experimental-fto-sc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        \"Ignored\" /* Ignored */\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), \"Dim\" /* Dim */);\n      break;\n    }\n    case \"experimental-fto-l2c\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        \"Ignored\" /* Ignored */\n      );\n      puzzleStickering.set(experimentalFTO_SC(), \"Dim\" /* Dim */);\n      break;\n    }\n    case \"experimental-fto-lbt\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        \"Ignored\" /* Ignored */\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), \"Dim\" /* Dim */);\n      break;\n    }\n    case \"experimental-fto-l3t\": {\n      puzzleStickering.set(experimentalFTO_LBT(), \"Dim\" /* Dim */);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`\n      );\n      puzzleStickering.set(m.and(m.moves([])), \"Dim\" /* Dim */);\n  }\n  return puzzleStickering.toStickeringMask();\n}\nasync function ftoStickerings() {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\"\n  ];\n}\n\n// src/cubing/puzzles/implementations/fto/index.ts\nvar FTOPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"],\n      inventionYear: 1983\n    });\n    this.stickerings = ftoStickerings;\n    this.svg = getCached(async () => {\n      return (await import(\"./puzzles-dynamic-unofficial-QXSDLTK5.js\")).ftoSVG;\n    });\n  }\n  stickeringMask(stickering) {\n    return ftoStickering(this, stickering);\n  }\n};\nvar fto = new FTOPuzzleLoader();\n\n// src/cubing/puzzles/stickerings/megaminx-stickerings.ts\nasync function megaminxStickeringMask(puzzleLoader, stickering) {\n  switch (stickering) {\n    case \"full\":\n    case \"F2L\":\n    case \"LL\":\n    case \"OLL\":\n    case \"EOLL\":\n    case \"OCLL\":\n    case \"CPLL\":\n    case \"PLL\":\n    case \"ELS\":\n    case \"CLS\":\n      return cubeLikeStickeringMask(puzzleLoader, stickering);\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`\n      );\n  }\n  return cubeLikeStickeringMask(puzzleLoader, \"full\");\n}\nasync function megaminxStickerings() {\n  return [\n    \"full\",\n    \"F2L\",\n    \"LL\",\n    \"OLL\",\n    \"EOLL\",\n    \"OCLL\",\n    \"PLL\",\n    \"CPLL\",\n    \"ELS\",\n    \"CLS\"\n  ];\n}\n\n// src/cubing/puzzles/implementations/megaminx/index.ts\nvar MegaminxPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      inventionYear: 1981\n    });\n    this.stickerings = megaminxStickerings;\n    this.llSVG = getCached(async () => {\n      return (await import(\"./puzzles-dynamic-megaminx-QPQBRZVY.js\")).megaminxLLSVG;\n    });\n  }\n  stickeringMask(stickering) {\n    return megaminxStickeringMask(this, stickering);\n  }\n};\nvar megaminx = new MegaminxPuzzleLoader();\n\n// src/cubing/puzzles/implementations/pyraminx/index.ts\nvar PyraminxPuzzleLoader = class extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"]\n    });\n    this.svg = getCached(async () => {\n      return (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).pyraminxSVG;\n    });\n  }\n};\nvar pyraminx = new PyraminxPuzzleLoader();\n\n// src/cubing/puzzles/implementations/square1/index.ts\nvar square1 = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hr\\u0161el\", \"Vojtech Kopsk\\xFD\"],\n  inventionYear: 1990,\n  kpuzzle: getCached(\n    async () => new KPuzzle(\n      (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).sq1HyperOrbitJSON\n    )\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).sq1HyperOrbitSVG;\n  })\n};\n\n// src/cubing/puzzles/implementations/kilominx/index.ts\nvar kilominx = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(\n      JSON.stringify(pg.getKPuzzleDefinition(true))\n    );\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete moveDefinition.CENTERS;\n      delete moveDefinition.CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"./puzzle-geometry/index.js\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n      pg,\n      pg.getOrbitsDef(true)\n    );\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move) => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        }\n      }\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-unofficial-QXSDLTK5.js\")).kilominxSVG;\n  })\n};\n\n// src/cubing/puzzles/implementations/redi-cube/index.ts\nvar rediCube = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () => new KPuzzle(\n      (await import(\"./puzzles-dynamic-unofficial-QXSDLTK5.js\")).rediCubeJSON\n    )\n  ),\n  svg: async () => {\n    return (await import(\"./puzzles-dynamic-unofficial-QXSDLTK5.js\")).rediCubeSVG;\n  }\n};\n\n// src/cubing/puzzles/implementations/4x4x4/index.ts\nvar cube4x4x4 = new CubePGPuzzleLoader({\n  id: \"4x4x4\",\n  fullName: \"4\\xD74\\xD74 Cube\"\n});\ncube4x4x4.llSVG = getCached(async () => {\n  return (await import(\"./puzzles-dynamic-4x4x4-DT42HVIY.js\")).cube4x4x4LLSVG;\n});\n\n// src/cubing/puzzles/implementations/melindas2x2x2x2/index.ts\nvar melindas2x2x2x2 = {\n  id: \"melindas2x2x2x2\",\n  fullName: \"Melinda's 2\\xD72\\xD72\\xD72\",\n  inventedBy: [\"Melinda Green\"],\n  kpuzzle: getCached(\n    async () => new KPuzzle(\n      (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).melindas2x2x2x2OrbitJSON\n    )\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./puzzles-dynamic-side-events-D2VNVUXH.js\")).melindas2x2x2x2OrbitSVG;\n  })\n};\n\n// src/cubing/puzzles/index.ts\nvar puzzles = {\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": cube4x4x4,\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"5\\xD75\\xD75 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"6\\xD76\\xD76 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"7\\xD77\\xD77 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"40\\xD740\\xD740 Cube\"\n  }),\n  clock,\n  megaminx,\n  pyraminx,\n  skewb: new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"]\n  }),\n  square1,\n  fto,\n  gigaminx: new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006\n  }),\n  master_tetraminx: new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"],\n    inventionYear: 2002\n  }),\n  kilominx,\n  redi_cube: rediCube,\n  melindas2x2x2x2\n};\n\nexport {\n  wcaEvents,\n  wcaEventInfo,\n  twizzleEvents,\n  eventInfo,\n  cube2x2x2,\n  cube3x3x3,\n  puzzles\n};\n//# sourceMappingURL=chunk-VJBQAZ63.js.map\n","import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n}\n\nexport const wcaEvents: Record<string, EventInfo> = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  clock: { puzzleID: \"clock\", eventName: \"Clock\" },\n  minx: { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  pyram: { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  skewb: { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  sq1: { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" },\n};\n\n/** @category Event Info */\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nexport const twizzleEvents: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n  },\n};\n\n/** @category Event Info */\nexport function eventInfo(event: string): EventInfo | null {\n  return twizzleEvents[event] ?? null;\n}\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  cubeLikeStickeringMask,\n  cubeStickerings,\n} from \"../../stickerings/cube-like-stickerings\";\n\n/** @category Specific Puzzles */\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"222 Cube\",\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .cube2x2x2JSON,\n      ),\n  ),\n  svg: async () =>\n    (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .cube2x2x2SVG,\n  llSVG: getCached(\n    async () =>\n      (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n        .cube2x2x2LLSVG,\n  ),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube2x2x2, stickering),\n  stickerings: () => cubeStickerings(\"2x2x2\"),\n};\n","import type { PuzzleSpecificSimplifyOptions } from \"../../../alg\";\nimport { Move, QuantumMove } from \"../../../alg\";\n\nenum Axis {\n  X = \"x axis\",\n  Y = \"y axis\",\n  Z = \"z axis\",\n}\n\nenum MoveSourceType {\n  INDEXABLE_SLICE_NEAR,\n  INDEXABLE_SLICE_FAR,\n  INDEXABLE_WIDE_NEAR,\n  INDEXABLE_WIDE_FAR,\n  SPECIFIC_SLICE,\n  ROTATION,\n}\n\ninterface MoveSourceInfo {\n  family: string;\n  direction: -1 | 1;\n  type: MoveSourceType;\n  from: number;\n  to: number;\n}\n\nfunction makeSourceInfo(\n  moveStrings: string[],\n  type: MoveSourceType,\n  from: number,\n  to: number,\n): MoveSourceInfo[] {\n  const output: MoveSourceInfo[] = [];\n  for (const moveString of moveStrings) {\n    const move = Move.fromString(moveString);\n    const { family, amount: direction } = move;\n    if (![-1, 1].includes(direction)) {\n      // TODO: test iner/outer\n      // TODO: Can we move this to a test file?\n      throw new Error(\"Invalid config move\");\n    }\n    output.push({ family, direction: direction as -1 | 1, type, from, to });\n  }\n  return output;\n}\n\ninterface AxisInfo {\n  sliceDiameter: number;\n  extendsThroughEntirePuzzle: boolean;\n  moveSourceInfos: MoveSourceInfo[];\n}\n\n// TODO: wide slices\nconst axisInfos: Record<Axis, AxisInfo> = {\n  [Axis.X]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"R\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"L'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"r\", \"Rw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"l'\", \"Lw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"M'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"x\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Y]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"U\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"D'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"u\", \"Uw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"d'\", \"Dw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"E'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"y\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Z]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"F\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"B'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"f\", \"Fw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 3),\n      ...makeSourceInfo([\"b'\", \"Bw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 3),\n      ...makeSourceInfo([\"S\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"z\", \"Fv\", \"Bv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n};\n\nconst byFamily: Record<string, { axis: Axis; moveSourceInfo: MoveSourceInfo }> =\n  {};\nfor (const [axis, info] of Object.entries(axisInfos)) {\n  for (const moveSourceInfo of info.moveSourceInfos) {\n    byFamily[moveSourceInfo.family] = { axis: axis as Axis, moveSourceInfo };\n  }\n}\n\n// TODO: lazy initialization?\nconst byAxisThenType: Record<\n  Axis,\n  Partial<Record<MoveSourceType, MoveSourceInfo[]>>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Partial<Record<MoveSourceType, MoveSourceInfo[]>> = {};\n  byAxisThenType[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    (entry[moveSourceInfo.type] ??= []).push(moveSourceInfo);\n  }\n}\n\n// TODO: consolidate lookup tables?\nconst byAxisThenSpecificSlices: Record<\n  Axis,\n  Map<number, MoveSourceInfo>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Map<number, MoveSourceInfo> = new Map();\n  byAxisThenSpecificSlices[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    // We only want to use the first entry per slice index (in the unlikely case there are multiple).\n    if (!entry.get(moveSourceInfo.from)) {\n      entry.set(moveSourceInfo.from, moveSourceInfo);\n    }\n  }\n}\n\nfunction firstOfType(\n  axis: Axis,\n  moveSourceType: MoveSourceType,\n): MoveSourceInfo {\n  const entry = byAxisThenType[axis][moveSourceType]?.[0];\n  if (!entry) {\n    throw new Error(\n      `Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`,\n    );\n  }\n  return entry;\n}\n\nconst areQuantumMovesSameAxis = (\n  quantumMove1: QuantumMove,\n  quantumMove2: QuantumMove,\n) => {\n  return (\n    byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis\n  );\n};\n\nfunction simplestMove(\n  axis: Axis,\n  from: number,\n  to: number,\n  directedAmount: number,\n): Move {\n  if (from + 1 === to) {\n    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from);\n    if (sliceSpecificInfo) {\n      return new Move(\n        new QuantumMove(sliceSpecificInfo.family),\n        directedAmount * sliceSpecificInfo.direction,\n      );\n    }\n  }\n\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  if (from === 0 && to === sliceDiameter) {\n    const moveSourceInfo = firstOfType(axis, MoveSourceType.ROTATION);\n    return new Move(\n      new QuantumMove(moveSourceInfo.family),\n      directedAmount * moveSourceInfo.direction,\n    );\n  }\n\n  // const specificSliceInfo = byAxisThenSpecificSlices[axis].get(from);\n  const far = from + to > sliceDiameter; // (from + to) / 2 > sliceDiameter / 2\n  if (far) {\n    [from, to] = [sliceDiameter - to, sliceDiameter - from];\n  }\n\n  let outerLayer: number | null = from + 1; // change to 1-indexed\n  let innerLayer: number | null = to; // already 1-indexed\n  const slice = outerLayer === innerLayer;\n  if (slice) {\n    innerLayer = null;\n  }\n\n  if (outerLayer === 1) {\n    outerLayer = null;\n  }\n  if (slice && outerLayer === 1) {\n    innerLayer = null;\n  }\n  if (!slice && innerLayer === 2) {\n    innerLayer = null;\n  }\n\n  const moveSourceType = slice\n    ? far\n      ? MoveSourceType.INDEXABLE_SLICE_FAR\n      : MoveSourceType.INDEXABLE_SLICE_NEAR\n    : far\n    ? MoveSourceType.INDEXABLE_WIDE_FAR\n    : MoveSourceType.INDEXABLE_WIDE_NEAR;\n  const moveSourceInfo = firstOfType(axis, moveSourceType);\n  return new Move(\n    new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer),\n    directedAmount * moveSourceInfo.direction,\n  );\n}\n\nfunction simplifySameAxisMoves(\n  moves: Move[],\n  quantumMod: boolean = true, // TODO\n): Move[] {\n  if (moves.length === 0) {\n    // TODO: can we use the type system to avoid this?\n    return [];\n  }\n\n  const axis: Axis = byFamily[moves[0].family].axis;\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  const sliceDeltas = new Map<number, number>();\n  let lastCandidateRange: {\n    suffixLength: number;\n    sliceDeltas: Map<number, number>;\n  } | null = null;\n\n  function adjustValue(idx: number, relativeDelta: number) {\n    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;\n    if (quantumMod) {\n      newDelta = (newDelta % 4) + (5 % 4) - 1; // TODO: Use a passed-in `modMove`?\n    }\n    if (newDelta === 0) {\n      sliceDeltas.delete(idx);\n    } else {\n      sliceDeltas.set(idx, newDelta);\n    }\n  }\n  // TODO: go as far as possible instead of trying to take all moves, e.g. simplify U y y' to U.\n  let suffixLength = 0;\n  // TODO: Reverse iterator?\n  for (const move of Array.from(moves).reverse()) {\n    suffixLength++;\n    const { moveSourceInfo } = byFamily[move.family];\n    const directedAmount = move.amount * moveSourceInfo.direction;\n    // console.log({ directedAmount });\n    switch (moveSourceInfo.type) {\n      case MoveSourceType.INDEXABLE_SLICE_NEAR: {\n        // We convert to zero-indexing\n        const idx = (move.innerLayer ?? 1) - 1;\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_SLICE_FAR: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        const idx = sliceDiameter - (move.innerLayer ?? 1);\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_NEAR: {\n        adjustValue((move.outerLayer ?? 1) - 1, directedAmount);\n        adjustValue(move.innerLayer ?? 2, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_FAR: {\n        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount);\n        adjustValue(\n          sliceDiameter - ((move.outerLayer ?? 1) - 1),\n          -directedAmount,\n        );\n        break;\n      }\n      case MoveSourceType.SPECIFIC_SLICE: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        adjustValue(moveSourceInfo.from, directedAmount);\n        adjustValue(moveSourceInfo.to, -directedAmount);\n        break;\n      }\n      case MoveSourceType.ROTATION: {\n        adjustValue(0, directedAmount);\n        adjustValue(sliceDiameter, -directedAmount);\n        break;\n      }\n    }\n    if ([0, 2].includes(sliceDeltas.size)) {\n      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };\n    }\n  }\n  if (sliceDeltas.size === 0) {\n    return [];\n  }\n  // TODO: handle this check in the destructuring assignment?\n  if (!lastCandidateRange) {\n    return moves;\n  }\n  let [from, to] = lastCandidateRange.sliceDeltas.keys();\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n  const directedAmount = lastCandidateRange.sliceDeltas.get(from)!;\n  // TODO: Handle empty move\n  return [\n    ...moves.slice(0, -lastCandidateRange.suffixLength),\n    ...(directedAmount !== 0\n      ? [simplestMove(axis, from, to, directedAmount)]\n      : []),\n  ];\n}\n\nexport const puzzleSpecificSimplifyOptions333: PuzzleSpecificSimplifyOptions = {\n  quantumMoveOrder: () => 4,\n  // doQuantumMovesCommute: areQuantumMovesSameAxis,\n  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves },\n};\n","// Include 3x3x3 in the main bundle for better performance.\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { experimental3x3x3KPuzzle } from \"../../cubing-private\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  cubeLikeStickeringMask,\n  cubeStickerings,\n} from \"../../stickerings/cube-like-stickerings\";\nimport { puzzleSpecificSimplifyOptions333 } from \"./puzzle-specific-simplifications\";\n\n/** @category Specific Puzzles */\nexport const cube3x3x3: PuzzleLoader = {\n  id: \"3x3x3\",\n  fullName: \"333 Cube\",\n  inventedBy: [\"Ern Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\")\n    ).cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (\n      await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\")\n    ).cube3x3x3LLSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube3x3x3, stickering),\n  stickerings: () => cubeStickerings(\"3x3x3\"),\n  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333,\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .clockJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).clockSVG;\n  }),\n};\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./mask\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    case \"experimental-fto-f2t\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-sc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l2c\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-lbt\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l3t\": {\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n  override svg = getCached(async () => {\n    return (\n      await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\")\n    ).ftoSVG;\n  });\n}\n\nexport const fto = new FTOPuzzleLoader();\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"./mask\";\nimport { cubeLikeStickeringMask } from \"./cube-like-stickerings\";\n\n// TODO: cache calculations?\nexport async function megaminxStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  switch (stickering) {\n    case \"full\":\n    case \"F2L\":\n    case \"LL\":\n    case \"OLL\":\n    case \"EOLL\":\n    case \"OCLL\":\n    case \"CPLL\":\n    case \"PLL\":\n    case \"ELS\":\n    case \"CLS\":\n      return cubeLikeStickeringMask(puzzleLoader, stickering);\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n  }\n  return cubeLikeStickeringMask(puzzleLoader, \"full\");\n}\n\nexport async function megaminxStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"F2L\",\n    \"LL\",\n    \"OLL\",\n    \"EOLL\",\n    \"OCLL\",\n    \"PLL\",\n    \"CPLL\",\n    \"ELS\",\n    \"CLS\",\n  ];\n}\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  megaminxStickeringMask,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return megaminxStickeringMask(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n\n  llSVG = getCached(async () => {\n    return (\n      await import(\"../dynamic/megaminx/puzzles-dynamic-megaminx\")\n    ).megaminxLLSVG;\n  });\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n","import { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  override svg = getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).pyraminxSVG;\n  });\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hrel\", \"Vojtech Kopsk\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .sq1HyperOrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).sq1HyperOrbitSVG;\n  }),\n};\n","import type { PuzzleLoader } from \"../..\";\nimport type { Move } from \"../../../alg\";\nimport { KPuzzle, KTransformationData } from \"../../../kpuzzle\";\nimport type { ExperimentalPGNotation } from \"../../../puzzle-geometry\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(\n      JSON.stringify(pg.getKPuzzleDefinition(true)),\n    );\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete (moveDefinition as any).CENTERS;\n      delete (moveDefinition as any).CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"../../../puzzle-geometry\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n      pg,\n      pg.getOrbitsDef(true),\n    );\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move: Move): KTransformationData | null => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        },\n      } as ExperimentalPGNotation,\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\")\n    ).kilominxSVG;\n  }),\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n          .rediCubeJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .rediCubeSVG;\n  },\n};\n","import { CubePGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nconst cube4x4x4: PuzzleLoader = new CubePGPuzzleLoader({\n  id: \"4x4x4\",\n  fullName: \"444 Cube\",\n});\n\ncube4x4x4.llSVG = getCached(async () => {\n  return (\n    await import(\"../dynamic/4x4x4/puzzles-dynamic-4x4x4\")\n  ).cube4x4x4LLSVG;\n});\n\nexport { cube4x4x4 };\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const melindas2x2x2x2: PuzzleLoader = {\n  id: \"melindas2x2x2x2\",\n  fullName: \"Melinda's 2222\",\n  inventedBy: [\"Melinda Green\"],\n  // inventionYear: 20__, // TODO\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .melindas2x2x2x2OrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).melindas2x2x2x2OrbitSVG;\n  }),\n};\n","export { eventInfo, wcaEventInfo, wcaEvents, twizzleEvents } from \"./events\";\nexport type { PuzzleLoader };\nexport { cube2x2x2, cube3x3x3 };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { square1 } from \"./implementations/square1\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\nimport { rediCube } from \"./implementations/redi-cube\";\nimport { cube4x4x4 } from \"./implementations/4x4x4\";\nimport { melindas2x2x2x2 } from \"./implementations/melindas2x2x2x2\";\n\n/** @category All Puzzles */\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": cube4x4x4,\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"555 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"666 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"777 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"404040 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  megaminx: megaminx,\n  pyraminx,\n  skewb: new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  fto: fto,\n  gigaminx: new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  master_tetraminx: new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  redi_cube: rediCube,\n  melindas2x2x2x2,\n};\n","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"7RujL\"))).then(() => parcelRequire('lRt2v'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"3INkf\"))).then(() => parcelRequire('bW4o7'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"fxIkj\"))).then(() => parcelRequire('arHwE'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"53f60\"))).then(() => parcelRequire('hziUS'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"kbZbg\"))).then(() => parcelRequire('1Og0z'));"],"names":["pieceStickerings","asyncGetKPuzzle","puzzleOrientationCacheRaw","puzzleOrientationCacheInitialized","transformationData","moveSourceInfo","directedAmount"],"version":3,"file":"index.72ea0aa3.js.map"}